// Package strategy provides trading strategy interfaces and implementations
package strategy

import (
	"time"

	commonpb "github.com/yourusername/quantlink-trade-system/pkg/proto/common"
	mdpb "github.com/yourusername/quantlink-trade-system/pkg/proto/md"
	orspb "github.com/yourusername/quantlink-trade-system/pkg/proto/ors"
)

// OrderSide represents buy or sell
type OrderSide int32

const (
	OrderSideBuy  OrderSide = 1
	OrderSideSell OrderSide = 2
)

// OrderType represents order type
type OrderType int32

const (
	OrderTypeLimit  OrderType = 1
	OrderTypeMarket OrderType = 2
	OrderTypeFOK    OrderType = 3 // Fill or Kill
	OrderTypeFAK    OrderType = 4 // Fill and Kill
)

// TimeInForce represents order time in force
type TimeInForce int32

const (
	TimeInForceGTC TimeInForce = 1 // Good Till Cancel
	TimeInForceIOC TimeInForce = 2 // Immediate or Cancel
	TimeInForceFOK TimeInForce = 3 // Fill or Kill
)

// OpenClose represents open/close flag (for Chinese futures)
type OpenClose int32

const (
	OpenCloseUnknown       OpenClose = 0 // Unknown (should not be used)
	OpenCloseOpen          OpenClose = 1 // Open position
	OpenCloseClose         OpenClose = 2 // Close position
	OpenCloseCloseToday    OpenClose = 3 // Close today position
	OpenCloseCloseYesterday OpenClose = 4 // Close yesterday position
)

// SignalCategory represents signal type for order management
// C++: STANDARD vs CROSS order types for passive vs aggressive orders
type SignalCategory int32

const (
	SignalCategoryPassive    SignalCategory = 1 // 被动单：挂单等待成交
	SignalCategoryAggressive SignalCategory = 2 // 主动单：吃单立即成交
)

// TradingSignal represents a trading signal generated by strategy
type TradingSignal struct {
	StrategyID  string      // Strategy identifier
	Symbol      string      // Symbol to trade
	Exchange    string      // Exchange
	Side        OrderSide   // Buy or Sell
	OpenClose   OpenClose   // Open or Close (for Chinese futures)
	Price       float64     // Limit price (0 for market orders)
	Quantity    int64       // Order quantity
	OrderType   OrderType   // Order type
	TimeInForce TimeInForce // Time in force
	Signal      float64     // Signal strength [-1, 1]
	Confidence  float64     // Confidence level [0, 1]
	Timestamp   time.Time   // Signal generation time
	Metadata    map[string]interface{} // Additional metadata

	// Multi-level quoting fields (C++: MAX_QUOTE_LEVEL support)
	Category   SignalCategory // 订单类别：被动单 vs 主动单
	QuoteLevel int            // 挂单层级：0=一档, 1=二档, ...
}

// ToOrderRequest converts TradingSignal to OrderRequest protobuf
func (ts *TradingSignal) ToOrderRequest() *orspb.OrderRequest {
	req := &orspb.OrderRequest{
		StrategyId: ts.StrategyID,
		Symbol:     ts.Symbol,
		Price:      ts.Price,
		Quantity:   ts.Quantity,
	}

	// Convert side
	switch ts.Side {
	case OrderSideBuy:
		req.Side = orspb.OrderSide_BUY
	case OrderSideSell:
		req.Side = orspb.OrderSide_SELL
	}

	// Convert order type
	switch ts.OrderType {
	case OrderTypeLimit:
		req.OrderType = orspb.OrderType_LIMIT
	case OrderTypeMarket:
		req.OrderType = orspb.OrderType_MARKET
	case OrderTypeFOK:
		req.OrderType = orspb.OrderType_LIMIT // Use LIMIT for FOK
	case OrderTypeFAK:
		req.OrderType = orspb.OrderType_LIMIT // Use LIMIT for FAK
	}

	// Convert exchange
	switch ts.Exchange {
	case "SHFE":
		req.Exchange = commonpb.Exchange_SHFE
	case "DCE":
		req.Exchange = commonpb.Exchange_DCE
	case "CZCE":
		req.Exchange = commonpb.Exchange_CZCE
	case "CFFEX":
		req.Exchange = commonpb.Exchange_CFFEX
	}

	// Convert open/close flag (for Chinese futures)
	switch ts.OpenClose {
	case OpenCloseOpen:
		req.OpenClose = orspb.OpenClose_OPEN
	case OpenCloseClose:
		req.OpenClose = orspb.OpenClose_CLOSE
	case OpenCloseCloseToday:
		req.OpenClose = orspb.OpenClose_CLOSE_TODAY
	case OpenCloseCloseYesterday:
		req.OpenClose = orspb.OpenClose_CLOSE_YESTERDAY
	default:
		// If not specified, default to OPEN
		// This ensures backward compatibility with existing code
		req.OpenClose = orspb.OpenClose_OPEN
	}

	// 传递订单类别到 metadata（用于追单识别）
	// C++: STANDARD vs CROSS order types
	if ts.Category == SignalCategoryAggressive {
		if req.Metadata == nil {
			req.Metadata = make(map[string]string)
		}
		req.Metadata["order_category"] = "aggressive"
	}

	return req
}

// EstimatedPosition represents estimated position calculated from order fills.
// IMPORTANT: This is NOT the real CTP position! It's an internal estimation that may be inaccurate.
// Real positions must be queried from CTP using position query interface.
// This estimation is calculated from order fills received by the strategy, but may differ from
// actual exchange positions due to: network delays, order rejections, partial fills, or system restarts.
//
// 中国期货市场规则：
// - 不允许同一合约同时持有多空双向持仓（净持仓模型）
// - NetQty > 0: 多头持仓，使用 BuyQty 和 BuyAvgPrice
// - NetQty < 0: 空头持仓，使用 SellQty 和 SellAvgPrice
// - NetQty = 0: 空仓
type EstimatedPosition struct {
	Symbol        string    // Symbol
	Exchange      string    // Exchange

	// 中国期货净持仓模型（与 tbsrc 一致）
	NetQty        int64     // 净持仓 = BuyTotalQty - SellTotalQty (正=多头，负=空头，0=空仓)
	BuyQty        int64     // 多头持仓数量（NetQty > 0 时使用）
	SellQty       int64     // 空头持仓数量（NetQty < 0 时使用）
	BuyAvgPrice   float64   // 多头平均成本价
	SellAvgPrice  float64   // 空头平均成本价

	// 累计成交量（用于计算 RealizedPnL）
	BuyTotalQty   int64     // 累计买入总量
	SellTotalQty  int64     // 累计卖出总量
	BuyTotalValue float64   // 累计买入总金额
	SellTotalValue float64  // 累计卖出总金额

	// 今昨仓（中国期货特有）
	TodayQty      int64     // 今仓数量
	YesterdayQty  int64     // 昨仓数量

	// 盈亏
	RealizedPnL   float64   // 已实现盈亏
	UnrealizedPnL float64   // 未实现盈亏
	LastUpdate    time.Time // Last update time

	// 兼容字段（废弃，为了 API 兼容性保留）
	LongQty       int64     `json:"LongQty,omitempty"`       // Deprecated: 使用 BuyQty
	ShortQty      int64     `json:"ShortQty,omitempty"`      // Deprecated: 使用 SellQty
	AvgLongPrice  float64   `json:"AvgLongPrice,omitempty"`  // Deprecated: 使用 BuyAvgPrice
	AvgShortPrice float64   `json:"AvgShortPrice,omitempty"` // Deprecated: 使用 SellAvgPrice
}

// GetNetPosition returns net position (符合中国期货规则)
func (p *EstimatedPosition) GetNetPosition() int64 {
	return p.NetQty
}

// IsFlat returns true if position is flat
func (p *EstimatedPosition) IsFlat() bool {
	return p.NetQty == 0
}

// IsLong returns true if net long (多头持仓)
func (p *EstimatedPosition) IsLong() bool {
	return p.NetQty > 0
}

// IsShort returns true if net short (空头持仓)
func (p *EstimatedPosition) IsShort() bool {
	return p.NetQty < 0
}

// GetAvgPrice returns average cost price based on position direction
func (p *EstimatedPosition) GetAvgPrice() float64 {
	if p.NetQty > 0 {
		return p.BuyAvgPrice
	} else if p.NetQty < 0 {
		return p.SellAvgPrice
	}
	return 0
}

// UpdateCompatibilityFields updates deprecated fields for API compatibility
func (p *EstimatedPosition) UpdateCompatibilityFields() {
	if p.NetQty > 0 {
		p.LongQty = p.BuyQty
		p.ShortQty = 0
		p.AvgLongPrice = p.BuyAvgPrice
		p.AvgShortPrice = 0
	} else if p.NetQty < 0 {
		p.LongQty = 0
		p.ShortQty = p.SellQty
		p.AvgLongPrice = 0
		p.AvgShortPrice = p.SellAvgPrice
	} else {
		p.LongQty = 0
		p.ShortQty = 0
		p.AvgLongPrice = 0
		p.AvgShortPrice = 0
	}
}

// PNL represents profit and loss
type PNL struct {
	RealizedPnL   float64   // Realized P&L
	UnrealizedPnL float64   // Unrealized P&L
	TotalPnL      float64   // Total P&L
	TradingFees   float64   // Trading fees
	NetPnL        float64   // Net P&L after fees
	MaxDrawdown   float64   // Maximum drawdown
	Timestamp     time.Time // Calculation time
}

// RiskMetrics represents risk metrics
type RiskMetrics struct {
	PositionSize    int64     // Current position size
	MaxPositionSize int64     // Maximum allowed position
	ExposureValue   float64   // Position value
	MaxExposure     float64   // Maximum allowed exposure
	VaR             float64   // Value at Risk
	SharpeRatio     float64   // Sharpe ratio
	MaxDrawdown     float64   // Maximum drawdown
	Volatility      float64   // Portfolio volatility
	Timestamp       time.Time // Calculation time
}

// MarketState represents current market state
type MarketState struct {
	Symbol       string
	Exchange     string
	MidPrice     float64
	BidPrice     float64
	AskPrice     float64
	Spread       float64
	BidQty       uint32
	AskQty       uint32
	LastPrice    float64
	Volume       uint64
	Turnover     float64
	Volatility   float64
	OrderImbalance float64
	Timestamp    time.Time
}

// FromMarketDataUpdate creates MarketState from protobuf
func FromMarketDataUpdate(md *mdpb.MarketDataUpdate) *MarketState {
	state := &MarketState{
		Symbol:    md.Symbol,
		Exchange:  md.Exchange,
		LastPrice: md.LastPrice,
		Volume:    md.TotalVolume,
		Turnover:  md.Turnover,
		Timestamp: time.Unix(0, int64(md.Timestamp)),
	}

	if len(md.BidPrice) > 0 && len(md.AskPrice) > 0 {
		state.BidPrice = md.BidPrice[0]
		state.AskPrice = md.AskPrice[0]
		state.MidPrice = (md.BidPrice[0] + md.AskPrice[0]) / 2.0
		state.Spread = md.AskPrice[0] - md.BidPrice[0]
	}

	if len(md.BidQty) > 0 {
		state.BidQty = md.BidQty[0]
	}
	if len(md.AskQty) > 0 {
		state.AskQty = md.AskQty[0]
	}

	return state
}

// StrategyConfig represents strategy configuration
type StrategyConfig struct {
	StrategyID      string                 // Strategy unique ID
	StrategyType    string                 // Strategy type name
	Symbols         []string               // Symbols to trade
	Exchanges       []string               // Exchanges
	MaxPositionSize int64                  // Maximum position size
	MaxExposure     float64                // Maximum exposure value
	Allocation      float64                // Capital allocation (0-1)
	RiskLimits      map[string]float64     // Risk limits
	Parameters      map[string]interface{} // Strategy parameters
	Enabled         bool                   // Is strategy enabled
}

// StrategyStatus represents strategy runtime status
type StrategyStatus struct {
	StrategyID        string             `json:"strategy_id"`
	IsRunning         bool               `json:"is_running"`
	EstimatedPosition *EstimatedPosition `json:"estimated_position"` // Estimated from order fills, NOT real CTP position!
	PNL               *PNL               `json:"pnl"`
	RiskMetrics       *RiskMetrics       `json:"risk_metrics"`
	SignalCount       int64              `json:"signal_count"`
	OrderCount        int64              `json:"order_count"`
	FillCount         int64              `json:"fill_count"`
	RejectCount       int64              `json:"reject_count"`
	LastSignalTime    time.Time          `json:"last_signal_time"`
	LastOrderTime     time.Time          `json:"last_order_time"`
	StartTime         time.Time          `json:"start_time"`
	Errors            []string           `json:"errors"`
}
