// Package strategy provides trading strategy interfaces and implementations
package strategy

import (
	"time"

	commonpb "github.com/yourusername/quantlink-trade-system/pkg/proto/common"
	mdpb "github.com/yourusername/quantlink-trade-system/pkg/proto/md"
	orspb "github.com/yourusername/quantlink-trade-system/pkg/proto/ors"
)

// OrderSide represents buy or sell
type OrderSide int32

const (
	OrderSideBuy  OrderSide = 1
	OrderSideSell OrderSide = 2
)

// OrderType represents order type
type OrderType int32

const (
	OrderTypeLimit  OrderType = 1
	OrderTypeMarket OrderType = 2
	OrderTypeFOK    OrderType = 3 // Fill or Kill
	OrderTypeFAK    OrderType = 4 // Fill and Kill
)

// TimeInForce represents order time in force
type TimeInForce int32

const (
	TimeInForceGTC TimeInForce = 1 // Good Till Cancel
	TimeInForceIOC TimeInForce = 2 // Immediate or Cancel
	TimeInForceFOK TimeInForce = 3 // Fill or Kill
)

// TradingSignal represents a trading signal generated by strategy
type TradingSignal struct {
	StrategyID  string      // Strategy identifier
	Symbol      string      // Symbol to trade
	Exchange    string      // Exchange
	Side        OrderSide   // Buy or Sell
	Price       float64     // Limit price (0 for market orders)
	Quantity    int64       // Order quantity
	OrderType   OrderType   // Order type
	TimeInForce TimeInForce // Time in force
	Signal      float64     // Signal strength [-1, 1]
	Confidence  float64     // Confidence level [0, 1]
	Timestamp   time.Time   // Signal generation time
	Metadata    map[string]interface{} // Additional metadata
}

// ToOrderRequest converts TradingSignal to OrderRequest protobuf
func (ts *TradingSignal) ToOrderRequest() *orspb.OrderRequest {
	req := &orspb.OrderRequest{
		StrategyId: ts.StrategyID,
		Symbol:     ts.Symbol,
		Price:      ts.Price,
		Quantity:   ts.Quantity,
	}

	// Convert side
	switch ts.Side {
	case OrderSideBuy:
		req.Side = orspb.OrderSide_BUY
	case OrderSideSell:
		req.Side = orspb.OrderSide_SELL
	}

	// Convert order type
	switch ts.OrderType {
	case OrderTypeLimit:
		req.OrderType = orspb.OrderType_LIMIT
	case OrderTypeMarket:
		req.OrderType = orspb.OrderType_MARKET
	case OrderTypeFOK:
		req.OrderType = orspb.OrderType_LIMIT // Use LIMIT for FOK
	case OrderTypeFAK:
		req.OrderType = orspb.OrderType_LIMIT // Use LIMIT for FAK
	}

	// Convert exchange
	switch ts.Exchange {
	case "SHFE":
		req.Exchange = commonpb.Exchange_SHFE
	case "DCE":
		req.Exchange = commonpb.Exchange_DCE
	case "CZCE":
		req.Exchange = commonpb.Exchange_CZCE
	case "CFFEX":
		req.Exchange = commonpb.Exchange_CFFEX
	}

	return req
}

// EstimatedPosition represents estimated position calculated from order fills.
// IMPORTANT: This is NOT the real CTP position! It's an internal estimation that may be inaccurate.
// Real positions must be queried from CTP using position query interface.
// This estimation is calculated from order fills received by the strategy, but may differ from
// actual exchange positions due to: network delays, order rejections, partial fills, or system restarts.
type EstimatedPosition struct {
	Symbol        string    // Symbol
	Exchange      string    // Exchange
	LongQty       int64     // Long position quantity (estimated)
	ShortQty      int64     // Short position quantity (estimated)
	NetQty        int64     // Net position (long - short, estimated)
	AvgLongPrice  float64   // Average long price
	AvgShortPrice float64   // Average short price
	RealizedPnL   float64   // Realized P&L
	UnrealizedPnL float64   // Unrealized P&L
	LastUpdate    time.Time // Last update time
}

// GetNetPosition returns net position (estimated)
func (p *EstimatedPosition) GetNetPosition() int64 {
	return p.LongQty - p.ShortQty
}

// IsFlat returns true if position is flat (estimated)
func (p *EstimatedPosition) IsFlat() bool {
	return p.GetNetPosition() == 0
}

// IsLong returns true if net long (estimated)
func (p *EstimatedPosition) IsLong() bool {
	return p.GetNetPosition() > 0
}

// IsShort returns true if net short (estimated)
func (p *EstimatedPosition) IsShort() bool {
	return p.GetNetPosition() < 0
}

// PNL represents profit and loss
type PNL struct {
	RealizedPnL   float64   // Realized P&L
	UnrealizedPnL float64   // Unrealized P&L
	TotalPnL      float64   // Total P&L
	TradingFees   float64   // Trading fees
	NetPnL        float64   // Net P&L after fees
	MaxDrawdown   float64   // Maximum drawdown
	Timestamp     time.Time // Calculation time
}

// RiskMetrics represents risk metrics
type RiskMetrics struct {
	PositionSize    int64     // Current position size
	MaxPositionSize int64     // Maximum allowed position
	ExposureValue   float64   // Position value
	MaxExposure     float64   // Maximum allowed exposure
	VaR             float64   // Value at Risk
	SharpeRatio     float64   // Sharpe ratio
	MaxDrawdown     float64   // Maximum drawdown
	Volatility      float64   // Portfolio volatility
	Timestamp       time.Time // Calculation time
}

// MarketState represents current market state
type MarketState struct {
	Symbol       string
	Exchange     string
	MidPrice     float64
	BidPrice     float64
	AskPrice     float64
	Spread       float64
	BidQty       uint32
	AskQty       uint32
	LastPrice    float64
	Volume       uint64
	Turnover     float64
	Volatility   float64
	OrderImbalance float64
	Timestamp    time.Time
}

// FromMarketDataUpdate creates MarketState from protobuf
func FromMarketDataUpdate(md *mdpb.MarketDataUpdate) *MarketState {
	state := &MarketState{
		Symbol:    md.Symbol,
		Exchange:  md.Exchange,
		LastPrice: md.LastPrice,
		Volume:    md.TotalVolume,
		Turnover:  md.Turnover,
		Timestamp: time.Unix(0, int64(md.Timestamp)),
	}

	if len(md.BidPrice) > 0 && len(md.AskPrice) > 0 {
		state.BidPrice = md.BidPrice[0]
		state.AskPrice = md.AskPrice[0]
		state.MidPrice = (md.BidPrice[0] + md.AskPrice[0]) / 2.0
		state.Spread = md.AskPrice[0] - md.BidPrice[0]
	}

	if len(md.BidQty) > 0 {
		state.BidQty = md.BidQty[0]
	}
	if len(md.AskQty) > 0 {
		state.AskQty = md.AskQty[0]
	}

	return state
}

// StrategyConfig represents strategy configuration
type StrategyConfig struct {
	StrategyID      string                 // Strategy unique ID
	StrategyType    string                 // Strategy type name
	Symbols         []string               // Symbols to trade
	Exchanges       []string               // Exchanges
	MaxPositionSize int64                  // Maximum position size
	MaxExposure     float64                // Maximum exposure value
	Allocation      float64                // Capital allocation (0-1)
	RiskLimits      map[string]float64     // Risk limits
	Parameters      map[string]interface{} // Strategy parameters
	Enabled         bool                   // Is strategy enabled
}

// StrategyStatus represents strategy runtime status
type StrategyStatus struct {
	StrategyID        string             `json:"strategy_id"`
	IsRunning         bool               `json:"is_running"`
	EstimatedPosition *EstimatedPosition `json:"estimated_position"` // Estimated from order fills, NOT real CTP position!
	PNL               *PNL               `json:"pnl"`
	RiskMetrics       *RiskMetrics       `json:"risk_metrics"`
	SignalCount       int64              `json:"signal_count"`
	OrderCount        int64              `json:"order_count"`
	FillCount         int64              `json:"fill_count"`
	RejectCount       int64              `json:"reject_count"`
	LastSignalTime    time.Time          `json:"last_signal_time"`
	LastOrderTime     time.Time          `json:"last_order_time"`
	StartTime         time.Time          `json:"start_time"`
	Errors            []string           `json:"errors"`
}
