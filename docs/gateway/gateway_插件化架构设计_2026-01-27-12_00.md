# Gateway 插件化架构设计

**文档日期**: 2026-01-27
**作者**: 开发团队
**版本**: v1.0
**相关模块**: gateway, plugins

---

## 概述

为了支持接入多个交易机构（CTP、XTP、飞马、恒生等），需要将gateway模块重构为插件化架构。每个交易机构作为独立插件，通过统一接口与核心系统交互。

## 目标

1. **清晰的模块边界**：每个机构的代码完全独立
2. **易于扩展**：添加新机构只需实现统一接口
3. **可选编译**：根据需求选择性编译特定插件
4. **配置隔离**：每个机构的配置独立管理
5. **易于测试和维护**：代码职责清晰

---

## 目录结构设计

```
gateway/
├── include/
│   ├── md_gateway.h              # 通用MD网关（已有）
│   ├── ors_gateway.h             # 通用ORS网关（已有）
│   ├── shm_queue.h               # 共享内存（已有）
│   └── plugin/                   # 插件接口（新增）
│       ├── md_plugin_interface.h # MD插件统一接口
│       └── td_plugin_interface.h # TD插件统一接口
│
├── src/
│   ├── main_md.cpp               # 通用MD网关入口（已有）
│   ├── md_gateway.cpp            # 通用MD网关实现（已有）
│   ├── main_ors.cpp              # 通用ORS网关入口（已有）
│   └── ors_gateway.cpp           # 通用ORS网关实现（已有）
│
├── plugins/                      # 插件目录（新增）
│   ├── ctp/                      # CTP插件
│   │   ├── include/
│   │   │   ├── ctp_config.h
│   │   │   ├── ctp_md_plugin.h
│   │   │   └── ctp_td_plugin.h  # 未来：CTP交易插件
│   │   ├── src/
│   │   │   ├── ctp_config.cpp
│   │   │   ├── ctp_md_plugin.cpp
│   │   │   └── main_ctp_md.cpp
│   │   ├── config/               # CTP专用配置模板
│   │   │   ├── ctp_md.yaml.example
│   │   │   └── ctp_md.secret.yaml.example
│   │   └── CMakeLists.txt        # CTP插件独立编译
│   │
│   ├── xtp/                      # XTP插件（未来）
│   │   ├── include/
│   │   │   ├── xtp_config.h
│   │   │   └── xtp_md_plugin.h
│   │   ├── src/
│   │   │   ├── xtp_config.cpp
│   │   │   ├── xtp_md_plugin.cpp
│   │   │   └── main_xtp_md.cpp
│   │   ├── config/
│   │   │   └── xtp_md.yaml.example
│   │   └── CMakeLists.txt
│   │
│   ├── femas/                    # 飞马插件（未来）
│   │   ├── include/
│   │   │   ├── femas_config.h
│   │   │   └── femas_md_plugin.h
│   │   ├── src/
│   │   │   ├── femas_config.cpp
│   │   │   ├── femas_md_plugin.cpp
│   │   │   └── main_femas_md.cpp
│   │   ├── config/
│   │   │   └── femas_md.yaml.example
│   │   └── CMakeLists.txt
│   │
│   └── README.md                 # 插件开发指南
│
├── third_party/                  # 第三方SDK
│   ├── ctp/                      # CTP SDK
│   │   ├── thostmduserapi_se.framework/
│   │   └── include/
│   ├── xtp/                      # XTP SDK（未来）
│   │   ├── lib/
│   │   └── include/
│   └── femas/                    # 飞马SDK（未来）
│       ├── lib/
│       └── include/
│
└── CMakeLists.txt                # 主CMake配置
```

---

## 插件接口设计

### IMDPlugin - 行情插件统一接口

```cpp
// gateway/include/plugin/md_plugin_interface.h
#pragma once

#include <string>
#include <vector>
#include <cstdint>

namespace hft {
namespace plugin {

/**
 * 行情插件统一接口
 * 所有行情插件（CTP、XTP、飞马等）必须实现此接口
 */
class IMDPlugin {
public:
    virtual ~IMDPlugin() = default;

    // ==================== 生命周期管理 ====================

    /**
     * 初始化插件
     * @param config_file 配置文件路径（YAML格式）
     * @return 成功返回true，失败返回false
     */
    virtual bool Initialize(const std::string& config_file) = 0;

    /**
     * 启动插件（连接到交易所/柜台）
     * @return 成功返回true，失败返回false
     */
    virtual bool Start() = 0;

    /**
     * 停止插件（断开连接，释放资源）
     */
    virtual void Stop() = 0;

    /**
     * 查询插件是否正在运行
     * @return 运行中返回true，否则返回false
     */
    virtual bool IsRunning() const = 0;

    // ==================== 订阅管理 ====================

    /**
     * 订阅行情
     * @param symbols 合约列表（如 ["ag2505", "rb2505"]）
     * @return 成功返回true，失败返回false
     */
    virtual bool Subscribe(const std::vector<std::string>& symbols) = 0;

    /**
     * 取消订阅
     * @param symbols 合约列表
     * @return 成功返回true，失败返回false
     */
    virtual bool Unsubscribe(const std::vector<std::string>& symbols) = 0;

    // ==================== 状态查询 ====================

    /**
     * 查询是否已连接到交易所
     * @return 已连接返回true，否则返回false
     */
    virtual bool IsConnected() const = 0;

    /**
     * 查询是否已登录
     * @return 已登录返回true，否则返回false
     */
    virtual bool IsLoggedIn() const = 0;

    /**
     * 获取插件名称
     * @return 插件名称（如 "CTP", "XTP", "FEMAS"）
     */
    virtual std::string GetPluginName() const = 0;

    /**
     * 获取插件版本
     * @return 版本号（如 "1.0.0"）
     */
    virtual std::string GetPluginVersion() const = 0;

    // ==================== 统计信息 ====================

    /**
     * 获取已接收的行情消息数量
     * @return 消息数量
     */
    virtual uint64_t GetMessageCount() const = 0;

    /**
     * 获取因队列满而丢弃的消息数量
     * @return 丢弃数量
     */
    virtual uint64_t GetDroppedCount() const = 0;
};

} // namespace plugin
} // namespace hft
```

### ITDPlugin - 交易插件统一接口（未来）

```cpp
// gateway/include/plugin/td_plugin_interface.h
#pragma once

#include <string>
#include <cstdint>

namespace hft {
namespace plugin {

/**
 * 订单请求
 */
struct OrderRequest {
    char symbol[16];        // 合约代码
    char exchange[8];       // 交易所
    double price;           // 价格
    uint32_t volume;        // 数量
    char direction;         // 方向：'B'=买，'S'=卖
    char offset;            // 开平：'O'=开仓，'C'=平仓
    // ... 其他字段
};

/**
 * 交易插件统一接口
 * 所有交易插件（CTP、XTP、飞马等）必须实现此接口
 */
class ITDPlugin {
public:
    virtual ~ITDPlugin() = default;

    // ==================== 生命周期管理 ====================

    virtual bool Initialize(const std::string& config_file) = 0;
    virtual bool Login() = 0;
    virtual void Logout() = 0;
    virtual bool IsLoggedIn() const = 0;

    // ==================== 交易功能 ====================

    /**
     * 发送订单
     * @param request 订单请求
     * @return 订单ID（失败返回空字符串）
     */
    virtual std::string SendOrder(const OrderRequest& request) = 0;

    /**
     * 撤销订单
     * @param order_id 订单ID
     * @return 成功返回true，失败返回false
     */
    virtual bool CancelOrder(const std::string& order_id) = 0;

    /**
     * 查询订单状态
     * @param order_id 订单ID
     * @return 订单状态字符串
     */
    virtual std::string QueryOrder(const std::string& order_id) = 0;

    // ==================== 状态查询 ====================

    virtual std::string GetPluginName() const = 0;
    virtual std::string GetPluginVersion() const = 0;

    /**
     * 获取账户资金信息
     */
    virtual double GetAvailableFund() const = 0;
};

} // namespace plugin
} // namespace hft
```

---

## 插件实现示例

### CTP行情插件实现

```cpp
// gateway/plugins/ctp/include/ctp_md_plugin.h
#pragma once

#include "plugin/md_plugin_interface.h"
#include "ThostFtdcMdApi.h"
#include "ctp_config.h"
#include "shm_queue.h"
#include <atomic>
#include <memory>

namespace hft {
namespace plugin {
namespace ctp {

/**
 * CTP行情插件实现
 * 实现IMDPlugin接口，对接CTP行情API
 */
class CTPMDPlugin : public IMDPlugin, public CThostFtdcMdSpi {
public:
    explicit CTPMDPlugin();
    virtual ~CTPMDPlugin();

    // ==================== IMDPlugin接口实现 ====================

    bool Initialize(const std::string& config_file) override;
    bool Start() override;
    void Stop() override;
    bool IsRunning() const override { return m_running.load(); }

    bool Subscribe(const std::vector<std::string>& symbols) override;
    bool Unsubscribe(const std::vector<std::string>& symbols) override;

    bool IsConnected() const override { return m_connected.load(); }
    bool IsLoggedIn() const override { return m_logged_in.load(); }
    std::string GetPluginName() const override { return "CTP"; }
    std::string GetPluginVersion() const override { return "1.0.0"; }

    uint64_t GetMessageCount() const override { return m_md_count.load(); }
    uint64_t GetDroppedCount() const override { return m_md_dropped.load(); }

    // ==================== CTP API回调接口 ====================

    void OnFrontConnected() override;
    void OnFrontDisconnected(int nReason) override;
    void OnRspUserLogin(CThostFtdcRspUserLoginField* pRspUserLogin,
                        CThostFtdcRspInfoField* pRspInfo,
                        int nRequestID, bool bIsLast) override;
    void OnRspSubMarketData(CThostFtdcSpecificInstrumentField* pSpecificInstrument,
                           CThostFtdcRspInfoField* pRspInfo,
                           int nRequestID, bool bIsLast) override;
    void OnRtnDepthMarketData(CThostFtdcDepthMarketDataField* pDepthMarketData) override;
    void OnRspError(CThostFtdcRspInfoField* pRspInfo,
                   int nRequestID, bool bIsLast) override;

private:
    // 内部方法
    void Login();
    void Reconnect();
    void ConvertMarketData(CThostFtdcDepthMarketDataField* ctp_md,
                          hft::shm::MarketDataRaw* raw_md);
    bool IsErrorResponse(CThostFtdcRspInfoField* pRspInfo);

    // 配置
    CTPMDConfig m_config;

    // CTP API
    CThostFtdcMdApi* m_api = nullptr;

    // 共享内存队列
    hft::shm::ShmManager::Queue* m_queue = nullptr;

    // 状态管理
    std::atomic<bool> m_running{false};
    std::atomic<bool> m_connected{false};
    std::atomic<bool> m_logged_in{false};
    std::atomic<int> m_request_id{0};

    // 统计
    std::atomic<uint64_t> m_md_count{0};
    std::atomic<uint64_t> m_md_dropped{0};

    // 重连相关
    int m_reconnect_count = 0;
};

} // namespace ctp
} // namespace plugin
} // namespace hft
```

### CTP插件主程序

```cpp
// gateway/plugins/ctp/src/main_ctp_md.cpp
#include "ctp_md_plugin.h"
#include <iostream>
#include <signal.h>

using namespace hft::plugin::ctp;

// 全局变量用于信号处理
CTPMDPlugin* g_plugin = nullptr;

void SignalHandler(int signal) {
    std::cout << "\n[Main] Received signal " << signal << " (Ctrl+C)" << std::endl;
    if (g_plugin) {
        g_plugin->Stop();
    }
}

void PrintUsage(const char* program_name) {
    std::cout << R"(
Usage: )" << program_name << R"( [OPTIONS]

CTP Market Data Plugin - Connects to CTP and publishes market data

Options:
  -c, --config FILE        Config file path (default: config/ctp/ctp_md.yaml)
  -s, --secret FILE        Secret file path (default: config/ctp/ctp_md.secret.yaml)
  -h, --help              Show this help message

Examples:
  )" << program_name << R"(
  )" << program_name << R"( -c config/ctp/ctp_md.yaml
  )" << program_name << R"( -c config/ctp/ctp_md.yaml -s config/ctp/ctp_md.secret.yaml
)" << std::endl;
}

int main(int argc, char* argv[]) {
    std::cout << R"(
╔═══════════════════════════════════════════════════════╗
║           HFT CTP Market Data Plugin v1.0           ║
╚═══════════════════════════════════════════════════════╝
)" << std::endl;

    // 解析命令行参数
    std::string config_file = "config/ctp/ctp_md.yaml";

    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];

        if (arg == "-h" || arg == "--help") {
            PrintUsage(argv[0]);
            return 0;
        } else if ((arg == "-c" || arg == "--config") && i + 1 < argc) {
            config_file = argv[++i];
        }
    }

    std::cout << "[Main] Config file: " << config_file << std::endl;

    try {
        // 创建插件实例
        auto plugin = std::make_unique<CTPMDPlugin>();
        g_plugin = plugin.get();

        // 注册信号处理
        signal(SIGINT, SignalHandler);
        signal(SIGTERM, SignalHandler);

        // 初始化插件
        if (!plugin->Initialize(config_file)) {
            std::cerr << "[Main] ❌ Failed to initialize plugin" << std::endl;
            return 1;
        }

        // 启动插件
        if (!plugin->Start()) {
            std::cerr << "[Main] ❌ Failed to start plugin" << std::endl;
            return 1;
        }

        // 运行（阻塞）
        std::cout << "[Main] Plugin running... (Press Ctrl+C to stop)" << std::endl;
        while (plugin->IsRunning()) {
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }

        std::cout << "[Main] Goodbye!" << std::endl;
        return 0;

    } catch (const std::exception& e) {
        std::cerr << "[Main] ❌ Fatal error: " << e.what() << std::endl;
        return 1;
    }
}
```

---

## CMake配置

### 主CMakeLists.txt（gateway/CMakeLists.txt）

```cmake
cmake_minimum_required(VERSION 3.15)
project(hft-gateway VERSION 0.2.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# ... 现有的通用组件编译配置 ...

# ==================== 插件编译选项 ====================

option(BUILD_CTP_PLUGIN "Build CTP plugin" ON)
option(BUILD_XTP_PLUGIN "Build XTP plugin" OFF)
option(BUILD_FEMAS_PLUGIN "Build FEMAS plugin" OFF)

# 编译插件
if(BUILD_CTP_PLUGIN)
    message(STATUS "Building CTP plugin...")
    add_subdirectory(plugins/ctp)
endif()

if(BUILD_XTP_PLUGIN)
    message(STATUS "Building XTP plugin...")
    add_subdirectory(plugins/xtp)
endif()

if(BUILD_FEMAS_PLUGIN)
    message(STATUS "Building FEMAS plugin...")
    add_subdirectory(plugins/femas)
endif()

# 打印插件信息
message(STATUS "========================================")
message(STATUS "Plugin Configuration")
message(STATUS "========================================")
message(STATUS "CTP Plugin: ${BUILD_CTP_PLUGIN}")
message(STATUS "XTP Plugin: ${BUILD_XTP_PLUGIN}")
message(STATUS "FEMAS Plugin: ${BUILD_FEMAS_PLUGIN}")
message(STATUS "========================================")
```

### CTP插件CMakeLists.txt（gateway/plugins/ctp/CMakeLists.txt）

```cmake
# CTP插件独立编译配置

# 查找yaml-cpp
find_package(yaml-cpp QUIET)
if(NOT yaml-cpp_FOUND)
    message(WARNING "yaml-cpp not found - CTP plugin will not be built")
    return()
endif()

# macOS CTP Framework路径
if(APPLE)
    set(CTP_FRAMEWORK_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../../third_party/ctp)

    if(NOT EXISTS "${CTP_FRAMEWORK_DIR}/thostmduserapi_se.framework")
        message(WARNING "CTP framework not found at ${CTP_FRAMEWORK_DIR} - CTP plugin will not be built")
        return()
    endif()

    message(STATUS "Found CTP framework: ${CTP_FRAMEWORK_DIR}/thostmduserapi_se.framework")

    # CTP MD Plugin
    add_executable(ctp_md_gateway
        src/ctp_config.cpp
        src/ctp_md_plugin.cpp
        src/main_ctp_md.cpp
    )

    target_include_directories(ctp_md_gateway PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/include
        ${CMAKE_CURRENT_SOURCE_DIR}/../../include  # 访问通用接口
        ${CTP_FRAMEWORK_DIR}/include
        /opt/homebrew/include
    )

    target_link_libraries(ctp_md_gateway
        ${CTP_FRAMEWORK_DIR}/thostmduserapi_se.framework/Versions/A/thostmduserapi_se
        /opt/homebrew/lib/libyaml-cpp.dylib
        pthread
    )

    # 设置RPATH
    set_target_properties(ctp_md_gateway PROPERTIES
        BUILD_WITH_INSTALL_RPATH TRUE
        INSTALL_RPATH "${CTP_FRAMEWORK_DIR}"
    )

    # 安装
    install(TARGETS ctp_md_gateway DESTINATION bin)

    message(STATUS "CTP MD Gateway target added")

elseif(UNIX AND NOT APPLE)
    # Linux CTP库路径（未来支持）
    message(STATUS "CTP plugin on Linux is not yet supported")
else()
    message(STATUS "CTP plugin is only supported on macOS and Linux")
endif()
```

---

## 配置文件组织

```
config/
├── md_gateway.yaml          # 通用MD网关配置（已有）
├── ors_gateway.yaml         # 通用ORS网关配置（已有）
├── trader.yaml              # Golang trader配置（已有）
│
├── ctp/                     # CTP插件配置
│   ├── ctp_md.yaml          # CTP行情配置
│   ├── ctp_md.secret.yaml   # CTP账号密码（gitignore）
│   └── ctp_td.yaml          # CTP交易配置（未来）
│
├── xtp/                     # XTP插件配置（未来）
│   ├── xtp_md.yaml
│   └── xtp_md.secret.yaml
│
└── femas/                   # 飞马插件配置（未来）
    ├── femas_md.yaml
    └── femas_md.secret.yaml
```

**配置文件模板**（config/ctp/ctp_md.yaml.example）：

```yaml
# CTP行情插件配置模板
# 复制为 ctp_md.yaml 并填写实际配置

ctp:
  # CTP连接信息
  front_addr: "tcp://180.168.146.187:10211"  # 行情前置地址
  broker_id: "9999"                          # 经纪商代码

  # 用户信息（从secret文件读取）
  user_id: ""      # 留空，从ctp_md.secret.yaml读取
  password: ""     # 留空，从ctp_md.secret.yaml读取

  # 终端认证
  app_id: "simnow_client_test"
  auth_code: "0000000000000000"

  # 订阅合约
  instruments:
    - "ag2505"
    - "rb2505"

# 共享内存配置
shm:
  queue_name: "md_queue"
  queue_size: 10000

# 重连配置
reconnect:
  interval_sec: 5
  max_attempts: -1

# 日志配置
log:
  level: "info"
  file: "log/ctp_md_gateway.log"
  console: true

# 性能配置
performance:
  enable_latency_monitor: true
  latency_log_interval: 10000
```

---

## 编译和使用

### 编译选项

```bash
cd gateway/build

# 只编译CTP插件
cmake -DBUILD_CTP_PLUGIN=ON -DBUILD_XTP_PLUGIN=OFF ..
make

# 编译所有插件
cmake -DBUILD_CTP_PLUGIN=ON -DBUILD_XTP_PLUGIN=ON -DBUILD_FEMAS_PLUGIN=ON ..
make

# 只编译特定插件
make ctp_md_gateway
make xtp_md_gateway

# 安装到bin目录
make install
```

### 运行插件

```bash
# CTP插件
./bin/ctp_md_gateway -c config/ctp/ctp_md.yaml

# XTP插件
./bin/xtp_md_gateway -c config/xtp/xtp_md.yaml

# 飞马插件
./bin/femas_md_gateway -c config/femas/femas_md.yaml
```

---

## 开发新插件指南

### 步骤1：创建插件目录

```bash
cd gateway/plugins
mkdir -p my_plugin/{include,src,config}
```

### 步骤2：实现插件接口

创建`my_plugin/include/my_md_plugin.h`：

```cpp
#include "plugin/md_plugin_interface.h"

class MyMDPlugin : public IMDPlugin {
public:
    // 实现所有虚函数
    bool Initialize(const std::string& config_file) override { /* ... */ }
    bool Start() override { /* ... */ }
    void Stop() override { /* ... */ }
    // ... 其他接口
};
```

### 步骤3：创建CMakeLists.txt

```cmake
# my_plugin/CMakeLists.txt
add_executable(my_md_gateway
    src/my_md_plugin.cpp
    src/main_my_md.cpp
)

target_include_directories(my_md_gateway PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/include
    ${CMAKE_CURRENT_SOURCE_DIR}/../../include
)

target_link_libraries(my_md_gateway
    # 链接你的SDK库
    pthread
)

install(TARGETS my_md_gateway DESTINATION bin)
```

### 步骤4：在主CMakeLists.txt中添加选项

```cmake
# gateway/CMakeLists.txt
option(BUILD_MY_PLUGIN "Build My plugin" OFF)

if(BUILD_MY_PLUGIN)
    add_subdirectory(plugins/my_plugin)
endif()
```

### 步骤5：测试

```bash
cd gateway/build
cmake -DBUILD_MY_PLUGIN=ON ..
make my_md_gateway
./my_md_gateway -c config/my_plugin/config.yaml
```

---

## 优势总结

### 1. 清晰的模块边界
- 每个机构的代码完全独立在`plugins/xxx/`
- 避免代码混在一起导致的维护困难

### 2. 易于扩展
- 添加新机构只需：
  1. 创建`plugins/new_broker/`目录
  2. 实现`IMDPlugin`接口
  3. 添加CMake选项
- 不影响现有插件

### 3. 可选编译
- 通过CMake选项控制编译哪些插件
- 减少编译时间和依赖冲突
- 适合不同部署环境

### 4. 配置隔离
- 每个机构的配置独立在`config/xxx/`
- 便于管理不同环境的配置

### 5. SDK依赖隔离
- 不同机构的SDK放在`third_party/xxx/`
- 避免库版本冲突

### 6. 易于测试
- 可以单独测试某个插件
- 不影响其他插件

### 7. 统一接口
- 所有插件实现相同接口
- 便于上层系统集成
- 易于Mock测试

---

## 迁移步骤（从当前代码到插件架构）

### 阶段1：准备（不影响现有功能）

1. 创建插件目录结构
   ```bash
   mkdir -p gateway/include/plugin
   mkdir -p gateway/plugins/ctp/{include,src,config}
   ```

2. 定义插件接口
   - 创建`include/plugin/md_plugin_interface.h`
   - 定义`IMDPlugin`接口

### 阶段2：重构CTP代码

3. 移动CTP代码到插件目录
   ```bash
   mv gateway/include/ctp_*.h gateway/plugins/ctp/include/
   mv gateway/src/ctp_*.cpp gateway/plugins/ctp/src/
   mv gateway/src/main_ctp_md.cpp gateway/plugins/ctp/src/
   ```

4. 修改CTP类实现`IMDPlugin`接口
   - `CTPMDGatewayImpl` → `CTPMDPlugin`
   - 实现所有接口方法

5. 调整头文件包含路径

### 阶段3：调整CMake配置

6. 创建`plugins/ctp/CMakeLists.txt`
7. 在主`CMakeLists.txt`中添加插件选项
8. 测试编译

### 阶段4：配置文件迁移

9. 移动配置文件
   ```bash
   mkdir -p config/ctp
   mv config/ctp_md.yaml config/ctp/
   mv config/ctp_md.secret.yaml config/ctp/
   ```

10. 更新配置文件路径引用

### 阶段5：测试验证

11. 编译测试
    ```bash
    cd gateway/build
    cmake -DBUILD_CTP_PLUGIN=ON ..
    make ctp_md_gateway
    ```

12. 功能测试
    - 配置加载
    - CTP连接
    - 行情接收
    - 性能测试

13. 回归测试
    - 确保与原有功能一致

### 阶段6：文档更新

14. 更新BUILD_GUIDE.md
15. 更新USAGE.md
16. 创建插件开发指南

---

## 时间估算

| 阶段 | 工作量 | 说明 |
|------|--------|------|
| 阶段1：准备 | 0.5天 | 创建目录、定义接口 |
| 阶段2：重构CTP代码 | 1天 | 移动代码、实现接口 |
| 阶段3：调整CMake | 0.5天 | 修改编译配置 |
| 阶段4：配置迁移 | 0.5天 | 移动和更新配置 |
| 阶段5：测试验证 | 1天 | 编译、功能、回归测试 |
| 阶段6：文档更新 | 0.5天 | 更新相关文档 |
| **总计** | **4天** | 完整迁移 |

---

## 决策建议

### 方案A：先测试后重构（推荐）⭐️

**流程**：
1. 完成当前CTP实现的端到端测试（2天）
2. 完成性能测试，确保满足要求（1天）
3. 任务#1达到100%
4. 然后进行插件化重构（4天）

**优点**：
- 确保当前实现完全可用
- 有稳定的测试基线
- 避免重构引入新问题
- 风险低

### 方案B：立即重构

**流程**：
1. 立即进行插件化重构（4天）
2. 重构后进行完整测试（2天）

**优点**：
- 一次性建立正确架构
- 避免后续再次大改
- 更适合长期发展

**缺点**：
- 当前代码未经完整测试
- 重构可能引入新问题
- 调试难度增加

---

## 推荐

**推荐方案A**，因为：

1. **稳定性优先**：当前代码刚编译成功，还未经过完整测试
2. **风险控制**：先确保功能正确，再优化架构更稳妥
3. **进度可控**：不影响任务#1的完成进度
4. **经验积累**：通过测试发现问题，为重构提供参考

重构可以作为独立任务（如"任务#1.5"或"任务#7"），在任务#1完成后进行。

---

## 参考资料

- [系统架构文档](../CURRENT_ARCHITECTURE_FLOW.md)
- [构建指南](../BUILD_GUIDE.md)
- [任务跟踪](../../TASKS.md)

---

**最后更新**: 2026-01-27 12:00
