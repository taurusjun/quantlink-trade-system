# æŒä»“ç®¡ç†é‡æ„æ–¹æ¡ˆ

**æ—¶é—´**: 2026-01-30 11:30
**ç›®æ ‡**: å»ºç«‹æ¸…æ™°ã€å‡†ç¡®çš„æŒä»“ç®¡ç†æœºåˆ¶

---

## ğŸ¯ ç›®æ ‡

1. âœ… ç§»é™¤counter_bridgeçš„HTTPæ¥å£ï¼ˆèŒè´£å•ä¸€åŒ–ï¼‰
2. âœ… é€šè¿‡ORS Gatewayçš„gRPCæ¥å£æŸ¥è¯¢æŒä»“
3. âœ… ç­–ç•¥æŒä»“æŒä¹…åŒ–
4. âœ… å®æ—¶è¿½è¸ªæŒä»“å˜åŒ–

---

## ğŸ“Š æŒä»“è¿½è¸ªæœºåˆ¶

### é—®é¢˜4: æ¯æ¬¡å¼€ä»“/å¹³ä»“å¦‚ä½•è¿½è¸ªæŒä»“å˜åŒ–ï¼Ÿ

**ç­”æ¡ˆ**: å½“å‰å·²ç»åœ¨è¿½è¸ªï¼Œé€šè¿‡**è®¢å•æˆäº¤å›æŠ¥ï¼ˆOrderUpdateï¼‰**

### å½“å‰çš„è¿½è¸ªæµç¨‹ï¼ˆå·²å®ç°ï¼‰

```
è®¢å•æˆäº¤ â†’ CTPæŸœå°
    â†“
CTPæˆäº¤å›æŠ¥ (TradeRtn)
    â†“
Counter Bridge æ¥æ”¶
    â†“
ORS Gateway æ¥æ”¶ï¼ˆå…±äº«å†…å­˜ï¼‰
    â†“
NATS å‘å¸ƒ OrderUpdate
    â†“
StrategyEngine è®¢é˜…
    â†“
Strategy.OnOrderUpdate(update)
    â†“
BaseStrategy.UpdatePosition(update)
    â†“
ç­–ç•¥æŒä»“ä¼°ç®—æ›´æ–°
```

**ä»£ç ä½ç½®**: `golang/pkg/strategy/strategy.go:226`

```go
func (bs *BaseStrategy) UpdatePosition(update *orspb.OrderUpdate) {
    if update.Status == orspb.OrderStatus_FILLED {
        if update.Side == orspb.OrderSide_BUY {
            bs.Position.LongQty += qty
            bs.Position.AvgLongPrice = (totalCost + price*qty) / LongQty
        } else {
            bs.Position.ShortQty += qty
            bs.Position.AvgShortPrice = (totalCost + price*qty) / ShortQty
        }
        bs.Position.NetQty = LongQty - ShortQty
    }
}
```

**è¿™ä¸ªæœºåˆ¶å·²ç»åœ¨å·¥ä½œï¼** âœ…

### æŒä»“å˜åŒ–çš„å®æ—¶æ€§

| æ—¶é—´ç‚¹ | CTPçœŸå®æŒä»“ | ç­–ç•¥ä¼°ç®—æŒä»“ | å»¶è¿Ÿ |
|--------|------------|-------------|------|
| T0: è®¢å•å‘å‡º | 0 | 0 | - |
| T1: CTPæˆäº¤ | +4 | 0 | 0ms |
| T2: å›æŠ¥åˆ°è¾¾ | +4 | +4 | ~50ms |

**å»¶è¿Ÿ**: é€šå¸¸ < 100msï¼ˆCTPå›æŠ¥ â†’ NATS â†’ ç­–ç•¥æ›´æ–°ï¼‰

---

## ğŸ”§ éœ€è¦å®ç°çš„æ”¹è¿›

### æ”¹è¿›1: ç§»é™¤Counter Bridgeçš„HTTPæ¥å£

**æ–‡ä»¶**: `gateway/src/counter_bridge.cpp`

**å½“å‰ä»£ç **:
```cpp
// å¯åŠ¨HTTPæœåŠ¡å™¨
void StartHTTPServer(int port = 8080) {
    g_http_server = std::make_unique<httplib::Server>();
    g_http_server->Get("/positions", HandlePositionQuery);
    g_http_server->Get("/health", ...);
    g_http_server->listen("0.0.0.0", port);
}
```

**ç§»é™¤æ–¹æ¡ˆ**:
1. æ³¨é‡Šæ‰HTTPæœåŠ¡å™¨å¯åŠ¨ä»£ç 
2. ç§»é™¤`HandlePositionQuery`å‡½æ•°
3. ç§»é™¤httplibä¾èµ–ï¼ˆæˆ–ä¿ç•™ä¾›å…¶ä»–ç”¨é€”ï¼‰

**ç†ç”±**: Counter BridgeèŒè´£åº”è¯¥å•ä¸€ï¼ˆè®¢å•è½¬å‘+å›æŠ¥ï¼‰ï¼Œä¸åº”æä¾›æŸ¥è¯¢æ¥å£

---

### æ”¹è¿›2: ORS Gatewayæä¾›gRPCæŒä»“æŸ¥è¯¢æ¥å£

**æ–°å¢gRPCæ¥å£å®šä¹‰**

**æ–‡ä»¶**: `proto/ors.proto`

```protobuf
service OrderRoutingService {
    // ç°æœ‰æ¥å£
    rpc SendOrder(OrderRequest) returns (OrderResponse);
    rpc CancelOrder(CancelRequest) returns (CancelResponse);

    // æ–°å¢ï¼šæŸ¥è¯¢æŒä»“
    rpc QueryPositions(PositionQueryRequest) returns (PositionQueryResponse);
}

message PositionQueryRequest {
    string exchange = 1;    // äº¤æ˜“æ‰€ï¼ˆç©º=å…¨éƒ¨ï¼‰
    string symbol = 2;      // åˆçº¦ä»£ç ï¼ˆç©º=å…¨éƒ¨ï¼‰
}

message PositionQueryResponse {
    bool success = 1;
    string message = 2;
    repeated PositionInfo positions = 3;
}

message PositionInfo {
    string exchange = 1;        // äº¤æ˜“æ‰€
    string symbol = 2;          // åˆçº¦ä»£ç 
    string direction = 3;       // LONG/SHORT
    int64 volume = 4;          // æŒä»“é‡
    double avg_price = 5;      // å¼€ä»“å‡ä»·
    double position_profit = 6; // æŒä»“ç›ˆäº
    double margin = 7;         // å ç”¨ä¿è¯é‡‘
    string trading_day = 8;    // äº¤æ˜“æ—¥
}
```

**ORS Gatewayå®ç°**

**æ–‡ä»¶**: `gateway/src/ors_gateway_impl.cpp`

```cpp
grpc::Status ORSGatewayImpl::QueryPositions(
    grpc::ServerContext* context,
    const ors::PositionQueryRequest* request,
    ors::PositionQueryResponse* response) {

    // 1. æ„é€ æŸ¥è¯¢è¯·æ±‚
    PositionQueryRaw query;
    query.exchange = request->exchange();
    query.symbol = request->symbol();

    // 2. é€šè¿‡å…±äº«å†…å­˜å‘é€åˆ°Counter Bridge
    // æ–¹å¼A: å¤ç”¨ç°æœ‰çš„request/responseé˜Ÿåˆ—ï¼ˆéœ€è¦æ·»åŠ æ–°æ¶ˆæ¯ç±»å‹ï¼‰
    // æ–¹å¼B: åˆ›å»ºä¸“é—¨çš„queryé˜Ÿåˆ—

    // 3. ç­‰å¾…Counter Bridgeè¿”å›ç»“æœ
    auto positions = WaitForPositionResponse(timeout);

    // 4. å¡«å……response
    response->set_success(true);
    for (auto& pos : positions) {
        auto* info = response->add_positions();
        info->set_exchange(pos.exchange);
        info->set_symbol(pos.symbol);
        info->set_direction(pos.direction);
        info->set_volume(pos.volume);
        info->set_avg_price(pos.avg_price);
        // ...
    }

    return grpc::Status::OK;
}
```

**Counter Bridgeå¤„ç†**

**æ–‡ä»¶**: `gateway/src/counter_bridge.cpp`

```cpp
// åœ¨è®¢å•å¤„ç†å¾ªç¯ä¸­æ·»åŠ æŒä»“æŸ¥è¯¢å¤„ç†
void ProcessRequests() {
    while (running) {
        // ç°æœ‰ï¼šå¤„ç†è®¢å•è¯·æ±‚
        if (auto req = request_queue.pop()) {
            if (req.type == REQUEST_TYPE_ORDER) {
                HandleOrderRequest(req);
            } else if (req.type == REQUEST_TYPE_POSITION_QUERY) {
                HandlePositionQuery(req);  // æ–°å¢
            }
        }
    }
}

void HandlePositionQuery(const PositionQueryRaw& query) {
    // 1. è°ƒç”¨CTPæŸ¥è¯¢æŒä»“
    std::vector<PositionInfo> positions;
    for (auto& broker : brokers) {
        if (broker->IsLoggedIn()) {
            std::vector<PositionInfo> pos;
            if (broker->QueryPositions(pos, query.symbol, query.exchange)) {
                positions.insert(positions.end(), pos.begin(), pos.end());
            }
        }
    }

    // 2. é€šè¿‡å…±äº«å†…å­˜è¿”å›ç»“æœ
    PositionQueryResponse response;
    response.positions = positions;
    response_queue.push(response);
}
```

---

### æ”¹è¿›3: Traderå¯åŠ¨æ—¶æŸ¥è¯¢æŒä»“

**æ–‡ä»¶**: `golang/pkg/trader/trader.go`

**ä¿®æ”¹å‰**ï¼ˆé€šè¿‡HTTPï¼‰:
```go
func (t *Trader) queryInitialPositions() error {
    // é€šè¿‡HTTPæŸ¥è¯¢
    positions, err := orsClient.QueryPositions(ctx, "", "")  // è¿™ä¸ªæ˜¯HTTP
    // ...
}
```

**ä¿®æ”¹å**ï¼ˆé€šè¿‡gRPCï¼‰:
```go
func (t *Trader) queryInitialPositions() error {
    log.Println("[Trader] Querying initial positions from CTP...")

    // 1. é€šè¿‡ORS Gatewayçš„gRPCæ¥å£æŸ¥è¯¢
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    // è°ƒç”¨æ–°çš„gRPCæ¥å£
    positions, err := t.Engine.GetORSClient().QueryPositionsGRPC(ctx, "", "")
    if err != nil {
        return fmt.Errorf("failed to query positions: %w", err)
    }

    // 2. æŒ‰äº¤æ˜“æ‰€åˆ†ç»„å­˜å‚¨
    t.positionsMu.Lock()
    t.positionsByExchange = groupPositionsByExchange(positions)
    t.positionsMu.Unlock()

    // 3. åˆå§‹åŒ–æ¯ä¸ªç­–ç•¥çš„æŒä»“
    t.initializeStrategyPositions(positions)

    log.Printf("[Trader] âœ“ Loaded %d positions, initialized %d strategies",
        len(positions), len(t.strategies))

    return nil
}

// æ–°å¢ï¼šåˆå§‹åŒ–ç­–ç•¥æŒä»“
func (t *Trader) initializeStrategyPositions(positions []PositionInfo) {
    // æŒ‰å“ç§èšåˆæŒä»“
    posMap := make(map[string]int64)
    for _, pos := range positions {
        if pos.Direction == "LONG" {
            posMap[pos.Symbol] += pos.Volume
        } else {
            posMap[pos.Symbol] -= pos.Volume
        }
    }

    // ä¼ é€’ç»™æ¯ä¸ªç­–ç•¥
    if t.Config.System.MultiStrategy {
        for _, strategyID := range t.StrategyManager.GetStrategyIDs() {
            strategy := t.StrategyManager.GetStrategy(strategyID)
            if initializer, ok := strategy.(PositionInitializer); ok {
                initializer.InitializePositions(posMap)
            }
        }
    } else if t.Strategy != nil {
        if initializer, ok := t.Strategy.(PositionInitializer); ok {
            initializer.InitializePositions(posMap)
        }
    }
}
```

**æ–°å¢æ¥å£**:

**æ–‡ä»¶**: `golang/pkg/strategy/strategy.go`

```go
// PositionInitializer æ¥å£ï¼šæ”¯æŒä»å¤–éƒ¨åˆå§‹åŒ–æŒä»“
type PositionInitializer interface {
    InitializePositions(positions map[string]int64) error
}
```

---

### æ”¹è¿›4: ç­–ç•¥å®ç°æŒä»“åˆå§‹åŒ–

**æ–‡ä»¶**: `golang/pkg/strategy/pairwise_arb_strategy.go`

```go
// å®ç°PositionInitializeræ¥å£
func (pas *PairwiseArbStrategy) InitializePositions(positions map[string]int64) error {
    pas.mu.Lock()
    defer pas.mu.Unlock()

    // åˆå§‹åŒ–legæŒä»“
    if qty, exists := positions[pas.symbol1]; exists {
        pas.leg1Position = qty
        log.Printf("[PairwiseArb:%s] Initialized leg1 position: %s = %d",
            pas.ID, pas.symbol1, qty)
    }

    if qty, exists := positions[pas.symbol2]; exists {
        pas.leg2Position = qty
        log.Printf("[PairwiseArb:%s] Initialized leg2 position: %s = %d",
            pas.ID, pas.symbol2, qty)
    }

    // åŒæ—¶æ›´æ–°BaseStrategyçš„Positionï¼ˆç”¨äºPNLè®¡ç®—ï¼‰
    // æ³¨æ„ï¼šè¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…å¯èƒ½éœ€è¦æ›´å¤æ‚çš„é€»è¾‘
    totalQty := pas.leg1Position + pas.leg2Position
    if totalQty > 0 {
        pas.Position.LongQty = totalQty
        pas.Position.NetQty = totalQty
    } else if totalQty < 0 {
        pas.Position.ShortQty = -totalQty
        pas.Position.NetQty = totalQty
    }

    return nil
}
```

---

### æ”¹è¿›5: ç­–ç•¥æŒä»“æŒä¹…åŒ–

**ç›®çš„**: ç­–ç•¥åœæ­¢æ—¶ä¿å­˜æŒä»“ï¼Œé‡å¯æ—¶æ¢å¤ï¼ˆä½œä¸ºåŒé‡ä¿éšœï¼‰

**æ–‡ä»¶**: `golang/pkg/strategy/pairwise_arb_strategy.go`

```go
// æŒä»“æ•°æ®ç»“æ„
type StrategyPositionSnapshot struct {
    StrategyID    string            `json:"strategy_id"`
    Timestamp     time.Time         `json:"timestamp"`
    Leg1Symbol    string            `json:"leg1_symbol"`
    Leg1Position  int64             `json:"leg1_position"`
    Leg2Symbol    string            `json:"leg2_symbol"`
    Leg2Position  int64             `json:"leg2_position"`
    TotalLongQty  int64             `json:"total_long_qty"`
    TotalShortQty int64             `json:"total_short_qty"`
}

// Stopæ—¶ä¿å­˜æŒä»“
func (pas *PairwiseArbStrategy) Stop() error {
    pas.mu.Lock()
    defer pas.mu.Unlock()

    // ä¿å­˜å½“å‰æŒä»“åˆ°æ–‡ä»¶
    snapshot := StrategyPositionSnapshot{
        StrategyID:    pas.ID,
        Timestamp:     time.Now(),
        Leg1Symbol:    pas.symbol1,
        Leg1Position:  pas.leg1Position,
        Leg2Symbol:    pas.symbol2,
        Leg2Position:  pas.leg2Position,
        TotalLongQty:  pas.Position.LongQty,
        TotalShortQty: pas.Position.ShortQty,
    }

    if err := savePositionSnapshot(snapshot); err != nil {
        log.Printf("[PairwiseArb:%s] Warning: Failed to save position: %v", pas.ID, err)
        // ä¸é˜»æ–­åœæ­¢æµç¨‹
    }

    pas.ControlState.RunState = StrategyRunStateStopped
    pas.Deactivate()
    log.Printf("[PairwiseArbStrategy:%s] Stopped, position saved", pas.ID)
    return nil
}

// æŒä¹…åŒ–å‡½æ•°
func savePositionSnapshot(snapshot StrategyPositionSnapshot) error {
    filename := fmt.Sprintf("data/positions/%s.json", snapshot.StrategyID)

    // ç¡®ä¿ç›®å½•å­˜åœ¨
    os.MkdirAll("data/positions", 0755)

    data, err := json.MarshalIndent(snapshot, "", "  ")
    if err != nil {
        return err
    }

    return os.WriteFile(filename, data, 0644)
}

// å¯åŠ¨æ—¶æ¢å¤æŒä»“
func (pas *PairwiseArbStrategy) Initialize(config *StrategyConfig) error {
    // ... ç°æœ‰åˆå§‹åŒ–ä»£ç  ...

    // å°è¯•ä»æŒä¹…åŒ–æ–‡ä»¶æ¢å¤æŒä»“ï¼ˆä½œä¸ºå¤‡ä»½ï¼‰
    if snapshot, err := loadPositionSnapshot(pas.ID); err == nil {
        log.Printf("[PairwiseArb:%s] Found persisted position from %s",
            pas.ID, snapshot.Timestamp.Format("2006-01-02 15:04:05"))

        // æš‚å­˜ï¼Œç­‰å¾…ä¸CTPæŸ¥è¯¢ç»“æœå¯¹æ¯”
        pas.persistedLeg1Pos = snapshot.Leg1Position
        pas.persistedLeg2Pos = snapshot.Leg2Position
    }

    return nil
}
```

---

### æ”¹è¿›6: å®šæœŸæŒä»“æ ¡éªŒ

**ç›®çš„**: é˜²æ­¢ç­–ç•¥ä¼°ç®—ä¸çœŸå®æŒä»“æ¼‚ç§»

**æ–‡ä»¶**: `golang/pkg/trader/trader.go`

```go
// å¯åŠ¨å®šæœŸæŒä»“æ ¡éªŒ
func (t *Trader) startPositionVerification() {
    ticker := time.NewTicker(5 * time.Minute)
    go func() {
        for range ticker.C {
            if err := t.verifyPositions(); err != nil {
                log.Printf("[Trader] Position verification failed: %v", err)
            }
        }
    }()
}

// æ ¡éªŒæŒä»“
func (t *Trader) verifyPositions() error {
    // 1. æŸ¥è¯¢CTPçœŸå®æŒä»“
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    ctpPositions, err := t.Engine.GetORSClient().QueryPositionsGRPC(ctx, "", "")
    if err != nil {
        return fmt.Errorf("failed to query CTP positions: %w", err)
    }

    // 2. èšåˆCTPæŒä»“ï¼ˆæŒ‰å“ç§ï¼‰
    ctpPosMap := make(map[string]int64)
    for _, pos := range ctpPositions {
        if pos.Direction == "LONG" {
            ctpPosMap[pos.Symbol] += pos.Volume
        } else {
            ctpPosMap[pos.Symbol] -= pos.Volume
        }
    }

    // 3. è·å–ç­–ç•¥ä¼°ç®—æŒä»“
    strategyPosMap := t.aggregateStrategyPositions()

    // 4. å¯¹æ¯”
    mismatches := []string{}
    for symbol, ctpQty := range ctpPosMap {
        strategyQty := strategyPosMap[symbol]
        if ctpQty != strategyQty {
            diff := ctpQty - strategyQty
            mismatches = append(mismatches,
                fmt.Sprintf("%s: CTP=%d, Strategy=%d, Diff=%d",
                    symbol, ctpQty, strategyQty, diff))
        }
    }

    if len(mismatches) > 0 {
        log.Printf("[Trader] âš ï¸  Position mismatch detected:")
        for _, msg := range mismatches {
            log.Printf("[Trader]     %s", msg)
        }

        // å¯é€‰ï¼šè‡ªåŠ¨åŒæ­¥æˆ–å‘Šè­¦
        if t.Config.Risk.EnableAutoPositionSync {
            return t.syncStrategyPositions(ctpPosMap)
        }
    } else {
        log.Printf("[Trader] âœ“ Position verification passed")
    }

    return nil
}

// èšåˆæ‰€æœ‰ç­–ç•¥çš„æŒä»“
func (t *Trader) aggregateStrategyPositions() map[string]int64 {
    posMap := make(map[string]int64)

    if t.Config.System.MultiStrategy {
        for _, strategyID := range t.StrategyManager.GetStrategyIDs() {
            strategy := t.StrategyManager.GetStrategy(strategyID)
            // å‡è®¾ç­–ç•¥æœ‰GetPositionsBySymbolæ–¹æ³•
            if provider, ok := strategy.(PositionProvider); ok {
                for symbol, qty := range provider.GetPositionsBySymbol() {
                    posMap[symbol] += qty
                }
            }
        }
    }

    return posMap
}
```

---

## ğŸ“‹ å®æ–½æ­¥éª¤

### Phase 1: ç§»é™¤HTTPæ¥å£ï¼ˆç«‹å³ï¼‰

1. âœ… æ³¨é‡Šæ‰`counter_bridge.cpp`ä¸­çš„HTTPæœåŠ¡å™¨ä»£ç 
2. âœ… ç§»é™¤`trader.go`ä¸­çš„HTTPæŒä»“æŸ¥è¯¢
3. âœ… æµ‹è¯•ï¼šç³»ç»Ÿæ­£å¸¸è¿è¡Œï¼Œç­–ç•¥ä»è®¢å•å›æŠ¥è¿½è¸ªæŒä»“

**é¢„è®¡æ—¶é—´**: 30åˆ†é’Ÿ

### Phase 2: æ·»åŠ gRPCæŒä»“æŸ¥è¯¢æ¥å£ï¼ˆ1-2å¤©ï¼‰

1. âœ… æ›´æ–°`proto/ors.proto`ï¼Œæ·»åŠ QueryPositionsæ¥å£
2. âœ… é‡æ–°ç”Ÿæˆprotobufä»£ç 
3. âœ… å®ç°`ors_gateway_impl.cpp`çš„QueryPositionsæ–¹æ³•
4. âœ… ä¿®æ”¹Counter Bridgeå¤„ç†æŒä»“æŸ¥è¯¢è¯·æ±‚
5. âœ… å®ç°Golangå®¢æˆ·ç«¯è°ƒç”¨
6. âœ… æµ‹è¯•ï¼šèƒ½æ­£ç¡®æŸ¥è¯¢CTPæŒä»“

**é¢„è®¡æ—¶é—´**: 1-2å¤©

### Phase 3: ç­–ç•¥æŒä»“åˆå§‹åŒ–ï¼ˆåŠå¤©ï¼‰

1. âœ… æ·»åŠ `PositionInitializer`æ¥å£
2. âœ… å®ç°`PairwiseArbStrategy.InitializePositions()`
3. âœ… ä¿®æ”¹`trader.go`å¯åŠ¨æ—¶åˆå§‹åŒ–ç­–ç•¥æŒä»“
4. âœ… æµ‹è¯•ï¼šé‡å¯åç­–ç•¥æŒä»“æ­£ç¡®

**é¢„è®¡æ—¶é—´**: 4å°æ—¶

### Phase 4: æŒä»“æŒä¹…åŒ–ï¼ˆå¯é€‰ï¼ŒåŠå¤©ï¼‰

1. âœ… å®ç°æŒä»“å¿«ç…§ä¿å­˜
2. âœ… å®ç°æŒä»“å¿«ç…§æ¢å¤
3. âœ… ä½œä¸ºåŒé‡ä¿éšœï¼ˆä¸CTPæŸ¥è¯¢äº’è¡¥ï¼‰

**é¢„è®¡æ—¶é—´**: 4å°æ—¶

### Phase 5: å®šæœŸæ ¡éªŒï¼ˆå¯é€‰ï¼ŒåŠå¤©ï¼‰

1. âœ… å®ç°å®šæœŸæŸ¥è¯¢CTPæŒä»“
2. âœ… å¯¹æ¯”ç­–ç•¥ä¼°ç®—ä¸çœŸå®æŒä»“
3. âœ… ä¸ä¸€è‡´æ—¶å‘Šè­¦/åŒæ­¥

**é¢„è®¡æ—¶é—´**: 4å°æ—¶

---

## ğŸ¯ æŒä»“å˜åŒ–è¿½è¸ªæ€»ç»“

### é—®é¢˜4çš„ç­”æ¡ˆ

**æ¯æ¬¡å¼€ä»“/å¹³ä»“å¦‚ä½•è¿½è¸ªæŒä»“å˜åŒ–ï¼Ÿ**

**ç­”æ¡ˆ**: å·²ç»åœ¨è¿½è¸ªï¼é€šè¿‡ä»¥ä¸‹æµç¨‹ï¼š

```
1. è®¢å•æˆäº¤ â†’ CTPå›æŠ¥
2. Counter Bridgeæ¥æ”¶å›æŠ¥
3. ORS Gatewayè½¬å‘ï¼ˆå…±äº«å†…å­˜ï¼‰
4. NATSå‘å¸ƒOrderUpdate
5. StrategyEngineè®¢é˜…
6. Strategy.OnOrderUpdate()
7. BaseStrategy.UpdatePosition() â† è¿™é‡Œæ›´æ–°æŒä»“ï¼
```

**å®æ—¶æ€§**: ~50-100msï¼ˆCTPå›æŠ¥åˆ°ç­–ç•¥æ›´æ–°ï¼‰

**å‡†ç¡®æ€§**:
- âœ… æ­£å¸¸æƒ…å†µä¸‹å‡†ç¡®
- âš ï¸ ç‰¹æ®Šæƒ…å†µå¯èƒ½æ¼‚ç§»ï¼ˆéƒ¨åˆ†æˆäº¤ã€å›æŠ¥ä¸¢å¤±ç­‰ï¼‰
- âœ… é€šè¿‡å®šæœŸæ ¡éªŒä¿®æ­£

---

## ğŸ“Š æœ€ç»ˆæ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Trader (Golang)                      â”‚
â”‚                                                         â”‚
â”‚  å¯åŠ¨æ—¶ï¼š                                                â”‚
â”‚    1. QueryPositions(gRPC) â†’ ORS Gateway               â”‚
â”‚    2. InitializeStrategyPositions()                    â”‚
â”‚    3. LoadPersistedPositions() (å¤‡ä»½)                  â”‚
â”‚                                                         â”‚
â”‚  è¿è¡Œæ—¶ï¼š                                                â”‚
â”‚    - OnOrderUpdate() â†’ UpdatePosition() (å®æ—¶è¿½è¸ª)      â”‚
â”‚    - æ¯5åˆ†é’Ÿï¼šVerifyPositions() (æ ¡éªŒæ¼‚ç§»)              â”‚
â”‚                                                         â”‚
â”‚  åœæ­¢æ—¶ï¼š                                                â”‚
â”‚    - SavePositionSnapshot() (æŒä¹…åŒ–)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†‘ gRPC                â†‘ NATS
                     â”‚                     â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 ORS Gateway (C++)                       â”‚
â”‚                                                         â”‚
â”‚  - SendOrder() (ç°æœ‰)                                   â”‚
â”‚  - QueryPositions() (æ–°å¢) â† gRPCæ¥å£                   â”‚
â”‚    â†’ é€šè¿‡å…±äº«å†…å­˜æŸ¥è¯¢Counter Bridge                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“ å…±äº«å†…å­˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Counter Bridge (C++)                       â”‚
â”‚                                                         â”‚
â”‚  èŒè´£ï¼š                                                  â”‚
â”‚    1. è®¢å•è½¬å‘ï¼ˆORS â†’ CTPï¼‰                             â”‚
â”‚    2. å›æŠ¥è½¬å‘ï¼ˆCTP â†’ ORSï¼‰                             â”‚
â”‚    3. å¤„ç†æŒä»“æŸ¥è¯¢è¯·æ±‚ï¼ˆORS â†’ CTPï¼‰â† æ–°å¢               â”‚
â”‚                                                         â”‚
â”‚  ä¸å†æä¾›ï¼šHTTPæ¥å£ âŒ                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“ CTP API
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   CTPæŸœå° (çœŸå®æŒä»“)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

**æ–¹æ¡ˆæ—¶é—´**: 2026-01-30 11:30
**æ€»å·¥ä½œé‡**: 2-3å¤©ï¼ˆPhase 1+2+3ï¼‰
**ä¼˜å…ˆçº§**: Phase 1ï¼ˆç«‹å³ï¼‰, Phase 2-3ï¼ˆæœ¬å‘¨ï¼‰, Phase 4-5ï¼ˆå¯é€‰ï¼‰

