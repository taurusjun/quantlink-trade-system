# æ¨¡æ‹Ÿäº¤æ˜“æ‰€å®Œæ•´æ–¹æ¡ˆ

**æ–‡æ¡£æ—¥æœŸ**: 2026-01-30
**ç‰ˆæœ¬**: v1.0
**ç›¸å…³æ¨¡å—**: Counter Bridge, Simulator Plugin, Dashboard
**ä¼˜å…ˆçº§**: P2-High

---

## 1. æ¦‚è¿°

### 1.1 ç›®æ ‡

å®ç°ç”Ÿäº§çº§æ¨¡æ‹Ÿäº¤æ˜“æ‰€ä½œä¸º Pluginï¼Œä¸ CTP Plugin åŒç­‰åœ°ä½ï¼Œé€šè¿‡é…ç½®åˆ‡æ¢å®ç°çœŸå®æ¨¡æ‹Ÿç¯å¢ƒã€‚

### 1.2 æ ¸å¿ƒç‰¹æ€§

- **Plugin æ¶æ„**: å®ç° ITDPlugin æ¥å£ï¼Œä¸ CTP åŒç­‰åœ°ä½
- **é…ç½®åˆ‡æ¢**: ä»…ä¿®æ”¹é…ç½®æ–‡ä»¶å³å¯åœ¨æ¨¡æ‹Ÿ/å®ç›˜é—´åˆ‡æ¢
- **çœŸå®æ¨¡æ‹Ÿ**: æ”¯æŒéƒ¨åˆ†æˆäº¤ã€æ’¤å•ã€æ»‘ç‚¹ã€æŒä»“ç®¡ç†
- **Dashboard é›†æˆ**: å¤ç”¨ç°æœ‰ Vue 3 Dashboardï¼Œæ–°å¢æ¨¡æ‹Ÿå™¨ Tab
- **ä¼˜é›…åœæ­¢**: é˜²æ­¢ UNE çŠ¶æ€ï¼Œå®Œæ•´æ¸…ç†æµç¨‹

---

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 æ¶æ„å›¾

```
Golang Trader (ç­–ç•¥å¼•æ“)
  â†“ gRPC (è®¢å•è¯·æ±‚)
ORS Gateway (è®¢å•è·¯ç”±æœåŠ¡)
  â†“ å…±äº«å†…å­˜ IPC
Counter Bridge (ç»Ÿä¸€ Broker é€‚é…å™¨)
  â†“ ITDPlugin æ¥å£
  â”œâ”€ CTP Plugin (å®ç›˜äº¤æ˜“)
  â””â”€ Simulator Plugin (æ¨¡æ‹Ÿäº¤æ˜“) â† æ–°å¢
       â”œâ”€ MatchingEngine (æ’®åˆå¼•æ“)
       â”œâ”€ OrderBook (è®¢å•ç°¿)
       â”œâ”€ PositionManager (æŒä»“ç®¡ç†)
       â””â”€ HTTP API (æŸ¥è¯¢æ¥å£)
```

### 2.2 ä¸ CTP å¯¹æ¯”

| ç‰¹æ€§ | CTP Plugin | Simulator Plugin |
|------|-----------|------------------|
| **æ¥å£** | ITDPlugin | ITDPlugin (ç›¸åŒ) |
| **é…ç½®** | config/counter_bridge.ctp.yaml | config/counter_bridge.sim.yaml |
| **åˆå§‹åŒ–** | Initialize() | Initialize() |
| **ç™»å½•** | Login() (CTP ç½‘ç»œ) | Login() (å†…å­˜åˆå§‹åŒ–) |
| **ä¸‹å•** | SendOrder() (å‘é€ CTP) | SendOrder() (æ’®åˆå¼•æ“) |
| **æ’¤å•** | CancelOrder() (å‘é€ CTP) | CancelOrder() (å–æ¶ˆè®¢å•) |
| **æŒä»“æŸ¥è¯¢** | QueryPositions() (CTP æ¥å£) | QueryPositions() (å†…å­˜æ•°æ®) |
| **æ‰©å±•æ¥å£** | - | è®¢å•ç°¿å¿«ç…§ã€ç»Ÿè®¡æ•°æ®ã€è´¦æˆ·ä¿¡æ¯ |

---

## 3. é…ç½®åˆ‡æ¢

### 3.1 Counter Bridge é…ç½®

**å®ç›˜æ¨¡å¼** (`config/counter_bridge.ctp.yaml`):
```yaml
brokers:
  - name: ctp
    type: ctp
    config: config/ctp/ctp.yaml
    symbols: [ag2505, ag2507, au2506, au2508]
```

**æ¨¡æ‹Ÿæ¨¡å¼** (`config/counter_bridge.sim.yaml`):
```yaml
brokers:
  - name: simulator
    type: simulator
    config: config/simulator/simulator.yaml
    symbols: [ag2505, ag2507, au2506, au2508]
```

### 3.2 Simulator é…ç½®

**æ–‡ä»¶**: `config/simulator/simulator.yaml`

```yaml
# è´¦æˆ·è®¾ç½®
trading:
  initial_balance: 1000000.0      # åˆå§‹èµ„é‡‘
  margin_rate: 0.1                # ä¿è¯é‡‘ç‡
  commission_rate: 0.0001         # æ‰‹ç»­è´¹ç‡

# æ’®åˆç­–ç•¥
matching:
  strategy: market_driven         # IMMEDIATE | MARKET_DRIVEN | PROBABILISTIC
  accept_delay_ms: 10             # è®¢å•æ¥å—å»¶è¿Ÿ
  fill_delay_ms: 50               # æˆäº¤å»¶è¿Ÿ
  enable_partial_fill: true       # å…è®¸éƒ¨åˆ†æˆäº¤
  partial_fill_ratio: 0.7         # éƒ¨åˆ†æˆäº¤æ¯”ä¾‹

# é£é™©å‚æ•°
risk:
  slippage_ticks: 0.5             # æ»‘ç‚¹ï¼ˆè·³ï¼‰
  reject_probability: 0.0         # æ‹’å•æ¦‚ç‡
  max_position_volume: 100        # æœ€å¤§æŒä»“é‡
  enable_margin_check: true       # ä¿è¯é‡‘æ£€æŸ¥

# æŒä¹…åŒ–
persistence:
  save_interval_sec: 60           # çŠ¶æ€ä¿å­˜é—´éš”
  data_dir: data/simulator        # æ•°æ®ç›®å½•
  enable_recovery: true           # å¯ç”¨æ¢å¤
```

---

## 4. æ ¸å¿ƒç»„ä»¶å®ç°

### 4.1 SimulatorPlugin

**å¤´æ–‡ä»¶**: `gateway/plugins/simulator/include/simulator_plugin.h`

```cpp
#pragma once
#include "td_plugin_interface.h"
#include <memory>
#include <atomic>

class MatchingEngine;
class PositionManager;
class AccountManager;

class SimulatorPlugin : public ITDPlugin {
public:
    SimulatorPlugin();
    ~SimulatorPlugin() override;

    // ITDPlugin æ¥å£å®ç°
    bool Initialize(const std::string& config_file) override;
    bool Login() override;
    void Logout() override;
    bool IsLoggedIn() const override;

    int SendOrder(const OrderRequest& request, std::string& order_id) override;
    int CancelOrder(const std::string& order_id) override;
    std::vector<PositionInfo> QueryPositions(const std::string& symbol = "") override;
    AccountInfo QueryAccount() override;

    // æ‰©å±•æ¥å£ï¼ˆæ¨¡æ‹Ÿå™¨ç‰¹æœ‰ï¼‰
    struct OrderBookSnapshot {
        std::string symbol;
        std::vector<PriceLevel> bids;  // ä¹°å•
        std::vector<PriceLevel> asks;  // å–å•
        uint64_t timestamp;
    };

    OrderBookSnapshot GetOrderBookSnapshot(const std::string& symbol);

    struct Statistics {
        uint64_t total_orders;
        uint64_t filled_orders;
        uint64_t rejected_orders;
        uint64_t cancelled_orders;
        double avg_fill_latency_ms;
    };

    Statistics GetStatistics() const;

    // å¸‚åœºæ•°æ®é©±åŠ¨ï¼ˆä» NATS è®¢é˜…ï¼‰
    void OnMarketUpdate(const std::string& symbol, double bid, double ask,
                        int bid_vol, int ask_vol);

    // ä¼˜é›…åœæ­¢ï¼ˆé˜²æ­¢ UNE çŠ¶æ€ï¼‰
    void PrepareShutdown();

private:
    std::unique_ptr<MatchingEngine> matching_engine_;
    std::unique_ptr<PositionManager> position_manager_;
    std::unique_ptr<AccountManager> account_manager_;

    std::atomic<bool> logged_in_{false};
    std::atomic<bool> shutdown_requested_{false};
    std::atomic<bool> accept_new_orders_{true};

    // é…ç½®å‚æ•°
    struct Config {
        double initial_balance;
        double margin_rate;
        double commission_rate;
        std::string match_strategy;
        int accept_delay_ms;
        int fill_delay_ms;
        bool enable_partial_fill;
        double partial_fill_ratio;
        double slippage_ticks;
        double reject_probability;
        int max_position_volume;
        bool enable_margin_check;
        bool force_cancel_pending;
        std::string data_dir;
        int save_interval_sec;
    } config_;

    bool LoadConfig(const std::string& config_file);
    void SaveState();
    bool LoadState();
};
```

### 4.2 MatchingEngine

**å¤´æ–‡ä»¶**: `gateway/plugins/simulator/include/matching_engine.h`

```cpp
#pragma once
#include <string>
#include <vector>
#include <map>
#include <mutex>

struct Order {
    std::string order_id;
    std::string symbol;
    char direction;      // 'B' = Buy, 'S' = Sell
    double price;
    int volume;
    int filled_volume;
    char status;         // 'P'=Pending, 'F'=Filled, 'C'=Cancelled, 'R'=Rejected
    uint64_t timestamp;
};

struct MatchResult {
    std::string order_id;
    double fill_price;
    int fill_volume;
    uint64_t timestamp;
};

class MatchingEngine {
public:
    enum class MatchStrategy {
        IMMEDIATE,       // ç«‹å³æˆäº¤ï¼ˆå¯¹æ‰‹ä»·ï¼‰
        MARKET_DRIVEN,   // è¡Œæƒ…é©±åŠ¨ï¼ˆæ¨èï¼‰
        PROBABILISTIC    // æ¦‚ç‡æˆäº¤
    };

    MatchingEngine(MatchStrategy strategy);

    // è®¢å•ç®¡ç†
    std::string AddOrder(const Order& order);
    bool CancelOrder(const std::string& order_id);
    Order GetOrder(const std::string& order_id) const;
    std::vector<std::string> GetPendingOrders() const;
    bool HasPendingOrders() const;

    // è¡Œæƒ…æ›´æ–°ï¼ˆè§¦å‘æ’®åˆï¼‰
    void OnMarketUpdate(const std::string& symbol, double bid, double ask,
                        int bid_vol, int ask_vol);

    // æ’®åˆæ‰§è¡Œ
    std::vector<MatchResult> Match(const std::string& symbol,
                                    double bid_price, double ask_price);

    // æ§åˆ¶
    void Stop();
    void ForceStop();
    bool IsProcessing() const;

private:
    MatchStrategy strategy_;
    std::map<std::string, Order> orders_;
    mutable std::mutex mutex_;
    std::atomic<bool> running_{true};
    std::atomic<bool> processing_{false};

    // æ’®åˆç­–ç•¥å®ç°
    std::vector<MatchResult> MatchImmediate(const Order& order,
                                             double bid, double ask);
    std::vector<MatchResult> MatchMarketDriven(const Order& order,
                                                double bid, double ask);
    std::vector<MatchResult> MatchProbabilistic(const Order& order,
                                                 double bid, double ask);
};
```

### 4.3 OrderBook

**å¤´æ–‡ä»¶**: `gateway/plugins/simulator/include/order_book.h`

```cpp
#pragma once
#include <string>
#include <map>
#include <vector>

struct PriceLevel {
    double price;
    int volume;
    int order_count;
};

class OrderBook {
public:
    explicit OrderBook(const std::string& symbol);

    // è®¢å•ç°¿æ“ä½œ
    void AddOrder(const std::string& order_id, char side, double price, int volume);
    void RemoveOrder(const std::string& order_id);
    void UpdateOrder(const std::string& order_id, int new_volume);

    // æŸ¥è¯¢
    std::vector<PriceLevel> GetBids(int depth = 5) const;
    std::vector<PriceLevel> GetAsks(int depth = 5) const;
    double GetBestBid() const;
    double GetBestAsk() const;
    double GetSpread() const;

    // å¸‚åœºæ•°æ®æ›´æ–°
    void UpdateMarketPrice(double bid, double ask);

private:
    std::string symbol_;
    std::map<double, PriceLevel, std::greater<double>> bids_;  // é™åº
    std::map<double, PriceLevel, std::less<double>> asks_;     // å‡åº

    struct OrderInfo {
        char side;
        double price;
        int volume;
    };
    std::map<std::string, OrderInfo> order_map_;
};
```

### 4.4 PositionManager

**å¤´æ–‡ä»¶**: `gateway/plugins/simulator/include/position_manager.h`

```cpp
#pragma once
#include "common/position_info.h"
#include <string>
#include <map>
#include <mutex>

class PositionManager {
public:
    PositionManager();

    // æŒä»“æ›´æ–°
    void OnTrade(const std::string& symbol, char direction,
                 double price, int volume, double commission);

    // æŸ¥è¯¢
    std::vector<PositionInfo> GetAllPositions() const;
    PositionInfo GetPosition(const std::string& symbol) const;
    bool HasPosition(const std::string& symbol) const;

    // é£æ§æ£€æŸ¥
    bool CheckMargin(const std::string& symbol, int volume,
                     double price, double margin_rate) const;
    bool CheckMaxPosition(const std::string& symbol, int volume,
                          int max_volume) const;

    // æŒä¹…åŒ–
    bool SaveToFile(const std::string& file_path) const;
    bool LoadFromFile(const std::string& file_path);

private:
    struct Position {
        std::string symbol;
        int long_volume = 0;
        int short_volume = 0;
        double long_cost = 0.0;
        double short_cost = 0.0;
        double realized_pnl = 0.0;
        double commission = 0.0;
    };

    std::map<std::string, Position> positions_;
    mutable std::mutex mutex_;

    double CalculateUnrealizedPnL(const Position& pos, double current_price) const;
};
```

---

## 5. Counter Bridge é›†æˆ

### 5.1 ä¼˜é›…åœæ­¢æœºåˆ¶

**æ–‡ä»¶**: `gateway/src/counter_bridge.cpp`

```cpp
// å…¨å±€æ ‡å¿—
std::atomic<bool> g_shutdown_in_progress{false};
std::atomic<bool> g_running{true};

void SignalHandler(int signal) {
    if (signal == SIGTERM || signal == SIGINT) {
        if (g_shutdown_in_progress) {
            LOG_WARN("[CounterBridge] Force exit on second signal");
            _exit(1);
        }

        LOG_INFO("[CounterBridge] Graceful shutdown initiated...");
        g_shutdown_in_progress = true;

        // 1. åœæ­¢ HTTP æœåŠ¡å™¨
        StopHTTPServer();

        // 2. åœæ­¢è®¢å•å¤„ç†çº¿ç¨‹
        g_running = false;

        // 3. å‡†å¤‡ Plugin å…³é—­ï¼ˆæ’¤å•ã€ä¿å­˜çŠ¶æ€ï¼‰
        for (auto& [name, broker] : g_brokers) {
            auto* sim = dynamic_cast<SimulatorPlugin*>(broker.get());
            if (sim) {
                LOG_INFO("[CounterBridge] Preparing simulator shutdown...");
                sim->PrepareShutdown();  // æ–°å¢ï¼šæ’¤å•å¹¶ä¿å­˜çŠ¶æ€
            }
        }

        // ç­‰å¾…è®¢å•å¤„ç†å®Œæˆï¼ˆæœ€å¤š5ç§’ï¼‰
        auto start = std::chrono::steady_clock::now();
        while (g_processing_count > 0) {
            auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(
                std::chrono::steady_clock::now() - start).count();
            if (elapsed > 5) {
                LOG_WARN("[CounterBridge] Force exit after 5s timeout");
                break;
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }

        // 4. Logout æ‰€æœ‰ Pluginsï¼ˆå¸¦è¶…æ—¶ï¼‰
        for (auto& [name, broker] : g_brokers) {
            if (broker && broker->IsLoggedIn()) {
                LOG_INFO("[CounterBridge] Logging out broker: %s", name.c_str());
                broker->Logout();
            }
        }

        // 5. æ¸…ç†å…±äº«å†…å­˜
        CleanupSharedMemory();

        LOG_INFO("[CounterBridge] Shutdown complete");

        // å¼ºåˆ¶é€€å‡ºä¿æŠ¤ï¼ˆ15ç§’åï¼‰
        std::thread([]() {
            std::this_thread::sleep_for(std::chrono::seconds(15));
            if (g_shutdown_in_progress) {
                LOG_ERROR("[CounterBridge] Force exit after 15s");
                _exit(1);
            }
        }).detach();

        exit(0);
    }
}

// PrepareShutdown å®ç°
void SimulatorPlugin::PrepareShutdown() {
    shutdown_requested_ = true;
    accept_new_orders_ = false;

    // 1. æ’¤é”€æ‰€æœ‰æŒ‚å•
    if (config_.force_cancel_pending) {
        auto pending = matching_engine_->GetPendingOrders();
        LOG_INFO("[Simulator] Cancelling %zu pending orders", pending.size());
        for (const auto& order_id : pending) {
            CancelOrder(order_id);
        }
    }

    // 2. ç­‰å¾…æŒ‚å•æ¸…ç©ºï¼ˆæœ€å¤š5ç§’ï¼‰
    auto start = std::chrono::steady_clock::now();
    while (matching_engine_->HasPendingOrders()) {
        auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(
            std::chrono::steady_clock::now() - start).count();
        if (elapsed > 5) {
            LOG_WARN("[Simulator] Timeout waiting for pending orders");
            break;
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    // 3. ä¿å­˜çŠ¶æ€
    SaveState();
    LOG_INFO("[Simulator] State saved successfully");
}
```

### 5.2 HTTP API æ‰©å±•

**æ–°å¢ç«¯ç‚¹** (Counter Bridge):

```cpp
// GET /orderbook?symbol=ag2505
void HandleOrderBookQuery(const httplib::Request& req, httplib::Response& res) {
    std::string symbol = req.get_param_value("symbol");

    auto* sim = dynamic_cast<SimulatorPlugin*>(GetBroker("simulator"));
    if (!sim) {
        res.status = 404;
        res.set_content("{\"error\":\"Simulator not found\"}", "application/json");
        return;
    }

    auto snapshot = sim->GetOrderBookSnapshot(symbol);

    nlohmann::json j;
    j["symbol"] = snapshot.symbol;
    j["timestamp"] = snapshot.timestamp;
    j["bids"] = nlohmann::json::array();
    for (const auto& level : snapshot.bids) {
        j["bids"].push_back({{"price", level.price}, {"volume", level.volume}});
    }
    j["asks"] = nlohmann::json::array();
    for (const auto& level : snapshot.asks) {
        j["asks"].push_back({{"price", level.price}, {"volume", level.volume}});
    }

    res.set_content(j.dump(), "application/json");
}

// GET /stats
void HandleSimulatorStats(const httplib::Request& req, httplib::Response& res) {
    auto* sim = dynamic_cast<SimulatorPlugin*>(GetBroker("simulator"));
    if (!sim) {
        res.status = 404;
        return;
    }

    auto stats = sim->GetStatistics();
    nlohmann::json j{
        {"total_orders", stats.total_orders},
        {"filled_orders", stats.filled_orders},
        {"rejected_orders", stats.rejected_orders},
        {"cancelled_orders", stats.cancelled_orders},
        {"avg_latency", stats.avg_fill_latency_ms}
    };

    res.set_content(j.dump(), "application/json");
}

// GET /account
void HandleAccountInfo(const httplib::Request& req, httplib::Response& res) {
    auto* sim = dynamic_cast<SimulatorPlugin*>(GetBroker("simulator"));
    if (!sim) {
        res.status = 404;
        return;
    }

    auto account = sim->QueryAccount();
    nlohmann::json j{
        {"initial_balance", account.initial_balance},
        {"current_balance", account.balance},
        {"available", account.available},
        {"margin", account.margin},
        {"commission", account.commission},
        {"unrealized_pnl", account.unrealized_pnl},
        {"realized_pnl", account.realized_pnl}
    };

    res.set_content(j.dump(), "application/json");
}
```

---

## 6. Golang Trader API é€ä¼ 

**æ–‡ä»¶**: `golang/pkg/trader/api_handlers.go`

```go
// GET /api/v1/simulator/orderbook?symbol=ag2505
func (t *Trader) handleSimulatorOrderBook(w http.ResponseWriter, r *http.Request) {
    symbol := r.URL.Query().Get("symbol")
    if symbol == "" {
        http.Error(w, "symbol required", http.StatusBadRequest)
        return
    }

    url := fmt.Sprintf("http://%s/orderbook?symbol=%s",
                       t.Config.Engine.CounterBridgeAddr, symbol)
    resp, err := http.Get(url)
    if err != nil {
        log.Printf("[API] Failed to query orderbook: %v", err)
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    defer resp.Body.Close()

    // ç›´æ¥è½¬å‘å“åº”
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(resp.StatusCode)
    io.Copy(w, resp.Body)
}

// GET /api/v1/simulator/stats
func (t *Trader) handleSimulatorStats(w http.ResponseWriter, r *http.Request) {
    url := fmt.Sprintf("http://%s/stats", t.Config.Engine.CounterBridgeAddr)
    resp, err := http.Get(url)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    defer resp.Body.Close()

    w.Header().Set("Content-Type", "application/json")
    io.Copy(w, resp.Body)
}

// GET /api/v1/simulator/account
func (t *Trader) handleSimulatorAccount(w http.ResponseWriter, r *http.Request) {
    url := fmt.Sprintf("http://%s/account", t.Config.Engine.CounterBridgeAddr)
    resp, err := http.Get(url)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    defer resp.Body.Close()

    w.Header().Set("Content-Type", "application/json")
    io.Copy(w, resp.Body)
}

// æ³¨å†Œè·¯ç”±
func (t *Trader) setupSimulatorRoutes() {
    http.HandleFunc("/api/v1/simulator/orderbook", t.handleSimulatorOrderBook)
    http.HandleFunc("/api/v1/simulator/stats", t.handleSimulatorStats)
    http.HandleFunc("/api/v1/simulator/account", t.handleSimulatorAccount)
}
```

---

## 7. Dashboard æ‰©å±•

### 7.1 æ–°å¢ Simulator Tab

**æ–‡ä»¶**: `golang/web/dashboard.html` (æ‰©å±•)

```html
<!-- Tab æŒ‰é’® -->
<div class="tabs">
    <button @click="activeTab = 'overview'" :class="{active: activeTab === 'overview'}">
        Overview
    </button>
    <button @click="activeTab = 'simulator'" :class="{active: activeTab === 'simulator'}"
            v-if="isSimulatorMode">
        Simulator ğŸ“Š
    </button>
</div>

<!-- Simulator Panel -->
<div v-if="activeTab === 'simulator'" class="simulator-panel">
    <!-- è´¦æˆ·ä¿¡æ¯ -->
    <div class="card">
        <h2>æ¨¡æ‹Ÿè´¦æˆ·</h2>
        <div class="account-info">
            <div class="info-row">
                <span>åˆå§‹èµ„é‡‘</span>
                <span>Â¥{{ formatNumber(simulatorAccount.initial_balance) }}</span>
            </div>
            <div class="info-row">
                <span>å½“å‰æƒç›Š</span>
                <span>Â¥{{ formatNumber(simulatorAccount.current_balance) }}</span>
            </div>
            <div class="info-row">
                <span>å¯ç”¨èµ„é‡‘</span>
                <span>Â¥{{ formatNumber(simulatorAccount.available) }}</span>
            </div>
            <div class="info-row">
                <span>å ç”¨ä¿è¯é‡‘</span>
                <span>Â¥{{ formatNumber(simulatorAccount.margin) }}</span>
            </div>
            <div class="info-row">
                <span>æµ®åŠ¨ç›ˆäº</span>
                <span :class="getPnLClass(simulatorAccount.unrealized_pnl)">
                    {{ formatPnL(simulatorAccount.unrealized_pnl) }}
                </span>
            </div>
            <div class="info-row">
                <span>å·²å®ç°ç›ˆäº</span>
                <span :class="getPnLClass(simulatorAccount.realized_pnl)">
                    {{ formatPnL(simulatorAccount.realized_pnl) }}
                </span>
            </div>
        </div>
    </div>

    <!-- è®¢å•ç°¿ -->
    <div class="card">
        <h2>è®¢å•ç°¿</h2>
        <div class="controls">
            <select v-model="selectedSymbol" @change="loadOrderBook">
                <option v-for="sym in symbols" :key="sym" :value="sym">{{ sym }}</option>
            </select>
        </div>
        <div class="orderbook">
            <!-- å–å• (asks) -->
            <div class="book-side asks-side">
                <div v-for="(level, i) in orderBook.asks" :key="'ask-'+i"
                     class="book-level ask">
                    <span class="price">{{ level.price }}</span>
                    <span class="volume">{{ level.volume }}</span>
                    <div class="depth-bar"
                         :style="{width: (level.volume / maxVolume * 100) + '%'}">
                    </div>
                </div>
            </div>

            <!-- ä»·å·® -->
            <div class="spread-info">
                <span>ä»·å·®: {{ spread.toFixed(2) }}</span>
            </div>

            <!-- ä¹°å• (bids) -->
            <div class="book-side bids-side">
                <div v-for="(level, i) in orderBook.bids" :key="'bid-'+i"
                     class="book-level bid">
                    <span class="price">{{ level.price }}</span>
                    <span class="volume">{{ level.volume }}</span>
                    <div class="depth-bar"
                         :style="{width: (level.volume / maxVolume * 100) + '%'}">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ç»Ÿè®¡ä¿¡æ¯ -->
    <div class="card">
        <h2>æ’®åˆç»Ÿè®¡</h2>
        <div class="stats-grid">
            <div class="stat-item">
                <div class="stat-label">æ€»è®¢å•æ•°</div>
                <div class="stat-value">{{ simulatorStats.total_orders }}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">æˆäº¤è®¢å•</div>
                <div class="stat-value success">{{ simulatorStats.filled_orders }}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">æ‹’å•æ•°</div>
                <div class="stat-value error">{{ simulatorStats.rejected_orders }}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">å·²æ’¤å•</div>
                <div class="stat-value">{{ simulatorStats.cancelled_orders }}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">æˆäº¤ç‡</div>
                <div class="stat-value">{{ fillRate }}%</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">å¹³å‡å»¶è¿Ÿ</div>
                <div class="stat-value">{{ simulatorStats.avg_latency.toFixed(2) }}ms</div>
            </div>
        </div>
    </div>
</div>

<script>
const { ref, computed, onMounted, onUnmounted } = Vue;

const app = Vue.createApp({
    setup() {
        const activeTab = ref('overview');
        const isSimulatorMode = ref(false);
        const selectedSymbol = ref('ag2505');
        const symbols = ref(['ag2505', 'ag2507', 'au2506', 'au2508']);

        const simulatorAccount = ref({
            initial_balance: 0,
            current_balance: 0,
            available: 0,
            margin: 0,
            commission: 0,
            unrealized_pnl: 0,
            realized_pnl: 0
        });

        const orderBook = ref({
            symbol: '',
            bids: [],
            asks: [],
            timestamp: 0
        });

        const simulatorStats = ref({
            total_orders: 0,
            filled_orders: 0,
            rejected_orders: 0,
            cancelled_orders: 0,
            avg_latency: 0
        });

        const spread = computed(() => {
            if (orderBook.value.asks.length && orderBook.value.bids.length) {
                return orderBook.value.asks[0].price - orderBook.value.bids[0].price;
            }
            return 0;
        });

        const maxVolume = computed(() => {
            const allVolumes = [
                ...orderBook.value.bids.map(l => l.volume),
                ...orderBook.value.asks.map(l => l.volume)
            ];
            return Math.max(...allVolumes, 1);
        });

        const fillRate = computed(() => {
            if (simulatorStats.value.total_orders === 0) return 0;
            return ((simulatorStats.value.filled_orders /
                     simulatorStats.value.total_orders) * 100).toFixed(1);
        });

        const loadSimulatorData = async () => {
            try {
                // è´¦æˆ·ä¿¡æ¯
                const accountRes = await fetch(`${getApiBase()}/simulator/account`);
                if (accountRes.ok) {
                    simulatorAccount.value = await accountRes.json();
                    isSimulatorMode.value = true;
                }

                // ç»Ÿè®¡ä¿¡æ¯
                const statsRes = await fetch(`${getApiBase()}/simulator/stats`);
                if (statsRes.ok) {
                    simulatorStats.value = await statsRes.json();
                }

                // è®¢å•ç°¿
                await loadOrderBook();
            } catch (err) {
                console.error('Failed to load simulator data:', err);
            }
        };

        const loadOrderBook = async () => {
            try {
                const res = await fetch(
                    `${getApiBase()}/simulator/orderbook?symbol=${selectedSymbol.value}`
                );
                if (res.ok) {
                    orderBook.value = await res.json();
                }
            } catch (err) {
                console.error('Failed to load orderbook:', err);
            }
        };

        const formatNumber = (num) => {
            return num.toLocaleString('zh-CN', {minimumFractionDigits: 2});
        };

        const formatPnL = (pnl) => {
            const sign = pnl >= 0 ? '+' : '';
            return sign + formatNumber(pnl);
        };

        const getPnLClass = (pnl) => {
            return pnl >= 0 ? 'profit' : 'loss';
        };

        let refreshInterval;

        onMounted(() => {
            loadSimulatorData();
            refreshInterval = setInterval(loadSimulatorData, 5000);
        });

        onUnmounted(() => {
            if (refreshInterval) clearInterval(refreshInterval);
        });

        return {
            activeTab,
            isSimulatorMode,
            selectedSymbol,
            symbols,
            simulatorAccount,
            orderBook,
            simulatorStats,
            spread,
            maxVolume,
            fillRate,
            loadOrderBook,
            formatNumber,
            formatPnL,
            getPnLClass
        };
    }
});

app.mount('#app');
</script>

<style>
.simulator-panel {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
}

.orderbook {
    font-family: monospace;
}

.book-level {
    display: grid;
    grid-template-columns: 1fr 1fr;
    padding: 4px 8px;
    position: relative;
}

.book-level.ask {
    color: #ef5350;
}

.book-level.bid {
    color: #26a69a;
}

.depth-bar {
    position: absolute;
    height: 100%;
    top: 0;
    right: 0;
    background: rgba(255,255,255,0.1);
    z-index: -1;
}

.spread-info {
    text-align: center;
    padding: 10px;
    background: #37474f;
    font-weight: bold;
}

.stats-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 15px;
}

.stat-item {
    text-align: center;
}

.stat-label {
    font-size: 0.9rem;
    color: #b0bec5;
    margin-bottom: 5px;
}

.stat-value {
    font-size: 1.5rem;
    font-weight: bold;
}

.stat-value.success {
    color: #26a69a;
}

.stat-value.error {
    color: #ef5350;
}

.profit {
    color: #26a69a;
}

.loss {
    color: #ef5350;
}
</style>
```

---

## 8. è¿ç»´è„šæœ¬

### 8.1 å¯åŠ¨è„šæœ¬

**æ–‡ä»¶**: `scripts/start_simulator.sh`

```bash
#!/bin/bash
set -e

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$PROJECT_ROOT"

echo "========================================="
echo "  Starting Simulator Mode"
echo "========================================="

# 1. æ£€æŸ¥å¹¶åœæ­¢æ—§è¿›ç¨‹
echo "[1/7] Checking old processes..."
OLD_PIDS=$(ps aux | grep -E "md_gateway|ors_gateway|counter_bridge|trader" | grep -v grep | awk '{print $2}')
if [ -n "$OLD_PIDS" ]; then
    echo "Found old processes, stopping..."
    echo "$OLD_PIDS" | xargs kill -TERM 2>/dev/null || true
    sleep 2
fi

# 2. æ¸…ç†å…±äº«å†…å­˜
echo "[2/7] Cleaning shared memory..."
ipcs -m | grep $(whoami) | awk '{print $2}' | xargs -r ipcrm -m 2>/dev/null || true

# 3. åˆ›å»ºå¿…è¦ç›®å½•
echo "[3/7] Creating directories..."
mkdir -p log data/simulator bin

# 4. å¯åŠ¨ NATS
echo "[4/7] Starting NATS..."
if ! pgrep -x "nats-server" > /dev/null; then
    nats-server -p 4222 -m 8222 > log/nats.log 2>&1 &
    sleep 1
    echo "NATS started (PID: $!)"
else
    echo "NATS already running"
fi

# 5. å¯åŠ¨ ORS Gateway
echo "[5/7] Starting ORS Gateway..."
./bin/ors_gateway > log/ors_gateway.log 2>&1 &
ORS_PID=$!
sleep 1
if ! ps -p $ORS_PID > /dev/null; then
    echo "ERROR: ORS Gateway failed to start"
    exit 1
fi
echo "ORS Gateway started (PID: $ORS_PID)"

# 6. å¯åŠ¨ Counter Bridge (Simulatoræ¨¡å¼)
echo "[6/7] Starting Counter Bridge (Simulator)..."
./bin/counter_bridge -config config/counter_bridge.sim.yaml > log/counter_bridge.log 2>&1 &
CB_PID=$!
sleep 2
if ! ps -p $CB_PID > /dev/null; then
    echo "ERROR: Counter Bridge failed to start"
    cat log/counter_bridge.log
    exit 1
fi
echo "Counter Bridge started (PID: $CB_PID)"

# 7. å¯åŠ¨ Trader
echo "[7/7] Starting Trader..."
./bin/trader -config config/trader.sim.yaml > log/trader.log 2>&1 &
TRADER_PID=$!
sleep 2
if ! ps -p $TRADER_PID > /dev/null; then
    echo "ERROR: Trader failed to start"
    cat log/trader.log
    exit 1
fi
echo "Trader started (PID: $TRADER_PID)"

echo ""
echo "========================================="
echo "  All components started successfully!"
echo "========================================="
echo "Dashboard: http://localhost:9201"
echo "Logs: tail -f log/trader.log"
echo ""
echo "To stop: ./scripts/stop_all.sh"
```

### 8.2 åœæ­¢è„šæœ¬

**æ–‡ä»¶**: `scripts/stop_all.sh`

```bash
#!/bin/bash

echo "========================================="
echo "  Graceful Shutdown"
echo "========================================="

# æŒ‰é¡ºåºåœæ­¢ï¼ˆåå‘å¯åŠ¨é¡ºåºï¼‰
COMPONENTS=("trader" "counter_bridge" "ors_gateway" "md_gateway" "md_simulator")
TIMEOUTS=(10 15 10 5 5)

for i in "${!COMPONENTS[@]}"; do
    COMPONENT="${COMPONENTS[$i]}"
    TIMEOUT="${TIMEOUTS[$i]}"

    PIDS=$(pgrep -f "$COMPONENT" 2>/dev/null)
    if [ -z "$PIDS" ]; then
        echo "[$COMPONENT] Not running"
        continue
    fi

    echo "[$COMPONENT] Sending SIGTERM to PIDs: $PIDS"
    echo "$PIDS" | xargs kill -TERM 2>/dev/null

    # ç­‰å¾…è¿›ç¨‹é€€å‡º
    for j in $(seq 1 $TIMEOUT); do
        if ! pgrep -f "$COMPONENT" > /dev/null 2>&1; then
            echo "[$COMPONENT] Stopped gracefully"
            break
        fi
        sleep 1
    done

    # è¶…æ—¶åå¼ºåˆ¶æ€æ­»
    if pgrep -f "$COMPONENT" > /dev/null 2>&1; then
        echo "[$COMPONENT] Timeout, force killing..."
        pkill -9 -f "$COMPONENT"
        sleep 1
    fi
done

# åœæ­¢ NATS
if pgrep -x "nats-server" > /dev/null; then
    echo "[NATS] Stopping..."
    pkill -TERM nats-server
    sleep 2
    pkill -9 nats-server 2>/dev/null || true
fi

# æ¸…ç†å…±äº«å†…å­˜
echo "Cleaning shared memory..."
ipcs -m | grep $(whoami) | awk '{print $2}' | xargs -r ipcrm -m 2>/dev/null || true

echo "========================================="
echo "  Shutdown complete"
echo "========================================="
```

### 8.3 çŠ¶æ€æ£€æŸ¥è„šæœ¬

**æ–‡ä»¶**: `scripts/status.sh`

```bash
#!/bin/bash

echo "========================================="
echo "  System Status"
echo "========================================="

# æ£€æŸ¥è¿›ç¨‹
check_process() {
    local name=$1
    local pid=$(pgrep -f "$name" 2>/dev/null)
    if [ -n "$pid" ]; then
        echo "âœ“ $name (PID: $pid)"
        return 0
    else
        echo "âœ— $name (not running)"
        return 1
    fi
}

echo "[Processes]"
check_process "nats-server"
check_process "ors_gateway"
check_process "counter_bridge"
check_process "trader"

# æ£€æŸ¥ HTTP ç«¯ç‚¹
echo ""
echo "[HTTP Endpoints]"
check_http() {
    local name=$1
    local url=$2
    if curl -s -f -m 2 "$url" > /dev/null 2>&1; then
        echo "âœ“ $name ($url)"
    else
        echo "âœ— $name ($url) - unreachable"
    fi
}

check_http "Counter Bridge" "http://localhost:8080/health"
check_http "Trader API" "http://localhost:9201/api/v1/dashboard/overview"
check_http "Simulator Stats" "http://localhost:9201/api/v1/simulator/stats"

# æ£€æŸ¥å…±äº«å†…å­˜
echo ""
echo "[Shared Memory]"
SHM_COUNT=$(ipcs -m | grep $(whoami) | wc -l)
echo "Active segments: $SHM_COUNT"

# æœ€è¿‘æ—¥å¿—
echo ""
echo "[Recent Logs]"
if [ -f log/trader.log ]; then
    echo "Last 5 lines from trader.log:"
    tail -5 log/trader.log
fi
```

### 8.4 å¥åº·æ£€æŸ¥è„šæœ¬

**æ–‡ä»¶**: `scripts/healthcheck.sh`

```bash
#!/bin/bash

# æŒç»­ç›‘æ§è„šæœ¬ï¼Œæ¯30ç§’æ£€æŸ¥ä¸€æ¬¡

while true; do
    TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

    # æ£€æŸ¥è¿›ç¨‹æ˜¯å¦å­˜æ´»
    DEAD_PROCESSES=""
    for proc in "trader" "counter_bridge" "ors_gateway"; do
        if ! pgrep -f "$proc" > /dev/null; then
            DEAD_PROCESSES="$DEAD_PROCESSES $proc"
        fi
    done

    if [ -n "$DEAD_PROCESSES" ]; then
        echo "[$TIMESTAMP] ALERT: Dead processes:$DEAD_PROCESSES"
        # å¯ä»¥å‘é€é‚®ä»¶æˆ–çŸ­ä¿¡å‘Šè­¦
    fi

    # æ£€æŸ¥ UNE çŠ¶æ€
    UNE_PROCS=$(ps aux | awk '$8 ~ /D/ && $1 == "'$(whoami)'"' | \
                grep -E "trader|counter_bridge|ors_gateway")
    if [ -n "$UNE_PROCS" ]; then
        echo "[$TIMESTAMP] WARNING: Processes in UNE state:"
        echo "$UNE_PROCS"
    fi

    # æ£€æŸ¥ CPU ä½¿ç”¨ç‡
    HIGH_CPU=$(ps aux | grep -E "trader|counter_bridge" | grep -v grep | \
               awk '$3 > 50 {print $11 " " $3"%"}')
    if [ -n "$HIGH_CPU" ]; then
        echo "[$TIMESTAMP] WARNING: High CPU usage:"
        echo "$HIGH_CPU"
    fi

    # æ£€æŸ¥æ‹’å•ç‡
    if [ -f log/trader.log ]; then
        RECENT_REJECTS=$(tail -100 log/trader.log | grep -c "Order rejected")
        if [ "$RECENT_REJECTS" -gt 5 ]; then
            echo "[$TIMESTAMP] WARNING: High reject rate: $RECENT_REJECTS in last 100 lines"
        fi
    fi

    sleep 30
done
```

---

## 9. å®æ–½è®¡åˆ’

### 9.1 Phase åˆ’åˆ†

**Phase 1: åŸºç¡€æ¡†æ¶ (3å¤©)**
- SimulatorPlugin ç±»æ¡†æ¶
- ITDPlugin æ¥å£å®ç°
- ç«‹å³æˆäº¤æ¨¡å¼ï¼ˆIMMEDIATEï¼‰
- Counter Bridge é›†æˆ
- é…ç½®æ–‡ä»¶æ”¯æŒ

**Phase 2: æ’®åˆå¼•æ“ (4å¤©)**
- OrderBook å®ç°
- MatchingEngine æ ¸å¿ƒé€»è¾‘
- è¡Œæƒ…é©±åŠ¨æ¨¡å¼ï¼ˆMARKET_DRIVENï¼‰
- éƒ¨åˆ†æˆäº¤æ”¯æŒ
- å»¶è¿Ÿæ¨¡æ‹Ÿ

**Phase 3: æŒä»“ç®¡ç† (3å¤©)**
- PositionManager å®ç°
- æˆäº¤åæŒä»“æ›´æ–°
- ä¿è¯é‡‘è®¡ç®—
- é£æ§æ£€æŸ¥
- æŒä¹…åŒ–ï¼ˆJSONï¼‰

**Phase 4: API + Dashboard (5å¤©)**
- Counter Bridge HTTP æ¥å£
- Golang Trader API é€ä¼ 
- Dashboard Simulator Tab
- è®¢å•ç°¿å¯è§†åŒ–
- å®æ—¶æ•°æ®æ›´æ–°

**Phase 5: è¿ç»´å·¥å…· (2å¤©)**
- å¯åŠ¨/åœæ­¢è„šæœ¬
- çŠ¶æ€æ£€æŸ¥è„šæœ¬
- å¥åº·ç›‘æ§è„šæœ¬
- ä¼˜é›…åœæ­¢æœºåˆ¶
- æ–‡æ¡£ç¼–å†™

### 9.2 æ—¶é—´ä¼°ç®—

| Phase | å·¥ä½œé‡ | ä¾èµ– |
|-------|--------|------|
| Phase 1 | 3å¤© | - |
| Phase 2 | 4å¤© | Phase 1 |
| Phase 3 | 3å¤© | Phase 2 |
| Phase 4 | 5å¤© | Phase 3 |
| Phase 5 | 2å¤© | Phase 4 |
| **æ€»è®¡** | **17å¤©** | - |

---

## 10. æµ‹è¯•éªŒè¯

### 10.1 å•å…ƒæµ‹è¯•

```bash
# C++ å•å…ƒæµ‹è¯•
cd gateway/plugins/simulator/tests
./run_tests.sh

# Golang å•å…ƒæµ‹è¯•
cd golang
go test ./pkg/trader/...
```

### 10.2 é›†æˆæµ‹è¯•

```bash
# å¯åŠ¨æ¨¡æ‹Ÿç¯å¢ƒ
./scripts/start_simulator.sh

# è¿è¡Œç«¯åˆ°ç«¯æµ‹è¯•
./test_simulator_e2e.sh

# éªŒè¯è®¢å•æµç¨‹
# éªŒè¯æŒä»“æ›´æ–°
# éªŒè¯Dashboardæ˜¾ç¤º
```

### 10.3 å‹åŠ›æµ‹è¯•

```bash
# é«˜é¢‘è®¢å•æµ‹è¯•
./test_high_frequency.sh

# å¹¶å‘è®¢å•æµ‹è¯•
./test_concurrent_orders.sh

# 24å°æ—¶ç¨³å®šæ€§æµ‹è¯•
nohup ./test_stability.sh &
```

---

## 11. é£é™©ä¸ç¼“è§£

| é£é™© | å½±å“ | ç¼“è§£æªæ–½ |
|------|------|---------|
| è¡Œä¸ºå·®å¼‚ | æ¨¡æ‹Ÿä¸å®ç›˜ä¸ä¸€è‡´ | ä½¿ç”¨æ¦‚ç‡æ¨¡å‹ã€å¯é…ç½®å»¶è¿Ÿ |
| UNE çŠ¶æ€ | è¿›ç¨‹æ— æ³•åœæ­¢ | PrepareShutdown + è¶…æ—¶æœºåˆ¶ |
| æ€§èƒ½é—®é¢˜ | å½±å“æµ‹è¯•çœŸå®æ€§ | æ·»åŠ å»¶è¿Ÿé…ç½®åŒ¹é…å®ç›˜ |
| çŠ¶æ€ä¸¢å¤± | å´©æºƒåæ•°æ®ä¸¢å¤± | å®šæœŸæŒä¹…åŒ– + æ¢å¤æœºåˆ¶ |

---

## 12. äº¤ä»˜ç‰©

- [ ] SimulatorPlugin å®Œæ•´å®ç°
- [ ] Counter Bridge é›†æˆä»£ç 
- [ ] Golang Trader API æ‰©å±•
- [ ] Dashboard Simulator Tab
- [ ] é…ç½®æ–‡ä»¶æ¨¡æ¿
- [ ] è¿ç»´è„šæœ¬é›†
- [ ] å•å…ƒæµ‹è¯•ï¼ˆè¦†ç›–ç‡ > 80%ï¼‰
- [ ] é›†æˆæµ‹è¯•è„šæœ¬
- [ ] API æ¥å£æ–‡æ¡£
- [ ] è¿ç»´æ“ä½œæ‰‹å†Œ

---

## 13. å‚è€ƒèµ„æ–™

- Counter Bridge æºç : `gateway/src/counter_bridge.cpp`
- CTP Plugin å®ç°: `gateway/plugins/ctp/`
- ITDPlugin æ¥å£: `gateway/include/td_plugin_interface.h`
- Dashboard å®ç°: `golang/web/dashboard.html`
- æŒä»“ç®¡ç†æŠ¥å‘Š: @docs/å®ç›˜/Phase2-5_å®Œæ•´æŒä»“ç®¡ç†åŠŸèƒ½å®æ–½æŠ¥å‘Š_2026-01-30-11_35.md

---

**æœ€åæ›´æ–°**: 2026-01-30 23:55
