# Trader_P1优化_Model热加载和命令行兼容

**文档日期**: 2026-01-26
**作者**: Claude
**版本**: v1.0
**相关模块**: golang/pkg/trader, golang/cmd/trader
**优先级**: P1 (高优先级)

---

## 概述

本文档设计两个关键功能，以提升新系统的运维友好性和向后兼容性：

1. **Model文件热加载** - 运行时动态重新加载策略参数，无需重启
2. **命令行参数兼容** - 支持旧系统启动方式，降低迁移成本

---

## 需求分析

### 1. Model热加载需求

**场景**:
- 策略运行中发现参数需要调整（如 entry_zscore 从 1.5 改为 2.0）
- 不想停止策略（会错过交易机会）
- 希望实时生效新参数

**当前问题**:
- 参数修改后必须重启 trader
- 重启导致策略中断、订单取消、持仓平仓风险
- 错过交易信号

**目标**:
- ✅ 支持 model 文件热加载
- ✅ 检测文件变化并自动重载
- ✅ 保持策略状态（持仓、订单）
- ✅ 提供手动触发接口
- ✅ 加载失败时保持旧配置

### 2. 命令行兼容需求

**旧系统启动方式**:
```bash
nohup ./TradeBot \
  --Live \
  --controlFile ./controls/day/control.ag2502.ag2504.par.txt.92201 \
  --strategyID 92201 \
  --configFile ./config/config_CHINA.92201.cfg \
  --adjustLTP 1 \
  --printMod 1 \
  --updateInterval 300000 \
  --logFile ./log/log.control.ag2502.ag2504.par.txt.92201.20241226 \
  >> nohup.out.92201 2>&1 &
```

**control文件格式**:
```
ag_F_2_SFE ./models/model.ag2502.ag2504.par.txt.92201 SFE 4 TB_PAIR_STRAT 0900 1500 ag_F_4_SFE
```

**新系统当前方式**:
```bash
./bin/trader -config config/trader_92201.yaml
```

**目标**:
- ✅ 支持旧系统所有关键参数
- ✅ 兼容 controlFile 格式
- ✅ 兼容 model 文件格式
- ✅ 降低运维人员迁移成本
- ✅ 保持新系统 YAML 配置优势

---

## 功能 1: Model 文件热加载

### 1.1 设计方案

#### 架构设计

```
┌─────────────────────────────────────────────────────────┐
│                      Trader Main                        │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  ┌────────────────┐       ┌─────────────────────┐      │
│  │ Config Watcher │──────>│  Model File Watcher │      │
│  │  (已有框架)     │       │     (新增)          │      │
│  └────────────────┘       └─────────────────────┘      │
│          │                          │                   │
│          │                          │                   │
│          v                          v                   │
│  ┌────────────────────────────────────────┐            │
│  │       Hot Reload Manager               │            │
│  │  - 解析 model 文件                      │            │
│  │  - 验证参数合法性                       │            │
│  │  - 通知策略引擎更新                     │            │
│  │  - 记录变更历史                         │            │
│  └────────────────���───────────────────────┘            │
│          │                                              │
│          v                                              │
│  ┌────────────────────────────────────────┐            │
│  │         Strategy Engine                │            │
│  │  - ApplyNewParameters()                │            │
│  │  - ValidateParameters()                │            │
│  │  - RollbackIfFailed()                  │            │
│  └────────────────────────────────────────┘            │
│                                                          │
└─────────────────────────────────────────────────────────┘

触发方式:
  1. 文件变化自动触发 (watchModelFile)
  2. HTTP API 手动触发 (POST /api/v1/model/reload)
  3. 定时检查触发 (每N秒)
```

#### 数据结构

```go
// pkg/trader/model_watcher.go

// ModelWatcher 监控 model 文件变化
type ModelWatcher struct {
    modelFilePath string
    lastModTime   time.Time
    checkInterval time.Duration
    stopChan      chan struct{}
    onReload      func(newParams map[string]interface{}) error
    mu            sync.RWMutex
    enabled       bool
}

// ModelReloadHistory 重载历史记录
type ModelReloadHistory struct {
    Timestamp   time.Time
    FilePath    string
    OldParams   map[string]interface{}
    NewParams   map[string]interface{}
    Success     bool
    ErrorMsg    string
}

// ModelFileParser model文件解析器
type ModelFileParser struct {
    filePath string
}
```

#### 核心算法

```go
// watchModelFile 监控 model 文件变化
func (w *ModelWatcher) watchModelFile() {
    ticker := time.NewTicker(w.checkInterval)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            if err := w.checkAndReload(); err != nil {
                log.Printf("[ModelWatcher] Reload error: %v", err)
            }
        case <-w.stopChan:
            log.Println("[ModelWatcher] Stopped")
            return
        }
    }
}

// checkAndReload 检查文件并重载
func (w *ModelWatcher) checkAndReload() error {
    w.mu.RLock()
    if !w.enabled {
        w.mu.RUnlock()
        return nil
    }
    filePath := w.modelFilePath
    lastModTime := w.lastModTime
    w.mu.RUnlock()

    // 检查文件修改时间
    stat, err := os.Stat(filePath)
    if err != nil {
        return fmt.Errorf("stat file: %w", err)
    }

    // 文件未修改
    if !stat.ModTime().After(lastModTime) {
        return nil
    }

    log.Printf("[ModelWatcher] Model file changed: %s", filePath)

    // 解析新参数
    parser := &ModelFileParser{filePath: filePath}
    newParams, err := parser.Parse()
    if err != nil {
        return fmt.Errorf("parse model file: %w", err)
    }

    // 验证参数
    if err := validateParameters(newParams); err != nil {
        return fmt.Errorf("validate parameters: %w", err)
    }

    // 调用回调函数应用新参数
    if w.onReload != nil {
        if err := w.onReload(newParams); err != nil {
            return fmt.Errorf("apply parameters: %w", err)
        }
    }

    // 更新修改时间
    w.mu.Lock()
    w.lastModTime = stat.ModTime()
    w.mu.Unlock()

    log.Printf("[ModelWatcher] ✓ Model reloaded successfully")
    return nil
}

// Parse 解析 model 文件
func (p *ModelFileParser) Parse() (map[string]interface{}, error) {
    file, err := os.Open(p.filePath)
    if err != nil {
        return nil, err
    }
    defer file.Close()

    params := make(map[string]interface{})
    scanner := bufio.NewScanner(file)

    for scanner.Scan() {
        line := strings.TrimSpace(scanner.Text())

        // 跳过空行和注释
        if line == "" || strings.HasPrefix(line, "#") {
            continue
        }

        // 跳过符号定义行
        if strings.Contains(line, "FUTCOM") {
            continue
        }

        // 解析参数行: KEY VALUE
        parts := strings.Fields(line)
        if len(parts) < 2 {
            continue
        }

        key := parts[0]
        value := parts[1]

        // 类型转换
        params[key] = parseValue(value)
    }

    if err := scanner.Err(); err != nil {
        return nil, err
    }

    return params, nil
}

// parseValue 解析值类型
func parseValue(s string) interface{} {
    // 尝试解析为整数
    if intVal, err := strconv.Atoi(s); err == nil {
        return intVal
    }

    // 尝试解析为浮点数
    if floatVal, err := strconv.ParseFloat(s, 64); err == nil {
        return floatVal
    }

    // 默认字符串
    return s
}

// validateParameters 验证参数合法性
func validateParameters(params map[string]interface{}) error {
    // 必填参数检查
    required := []string{"BEGIN_PLACE", "BEGIN_REMOVE", "MAX_SIZE"}
    for _, key := range required {
        if _, exists := params[key]; !exists {
            return fmt.Errorf("missing required parameter: %s", key)
        }
    }

    // 参数范围检查
    if size, ok := params["SIZE"].(int); ok {
        if size <= 0 || size > 100 {
            return fmt.Errorf("SIZE out of range: %d", size)
        }
    }

    if beginPlace, ok := params["BEGIN_PLACE"].(float64); ok {
        if beginPlace < 0 || beginPlace > 10 {
            return fmt.Errorf("BEGIN_PLACE out of range: %.2f", beginPlace)
        }
    }

    return nil
}
```

### 1.2 Strategy Engine 集成

```go
// pkg/strategy/strategy_engine.go

// ApplyNewParameters 应用新参数（热加载）
func (s *StrategyEngine) ApplyNewParameters(newParams map[string]interface{}) error {
    s.mu.Lock()
    defer s.mu.Unlock()

    // 保存旧参数（回滚用）
    oldParams := s.copyCurrentParameters()

    log.Println("[Strategy] Applying new parameters...")

    // 策略特定参数映射
    if err := s.mapParameters(newParams); err != nil {
        return fmt.Errorf("map parameters: %w", err)
    }

    // 验证新参数
    if err := s.validateNewParameters(); err != nil {
        log.Printf("[Strategy] Validation failed, rolling back: %v", err)
        s.restoreParameters(oldParams)
        return fmt.Errorf("validate: %w", err)
    }

    // 应用参数到策略实例
    switch strategy := s.strategy.(type) {
    case *PairwiseArbStrategy:
        strategy.UpdateParameters(newParams)
    // 其他策略类型...
    default:
        return fmt.Errorf("unsupported strategy type")
    }

    log.Printf("[Strategy] ✓ Parameters applied successfully")
    log.Printf("[Strategy]   Entry Z-Score: %.2f", s.getParam("entry_zscore"))
    log.Printf("[Strategy]   Exit Z-Score: %.2f", s.getParam("exit_zscore"))

    return nil
}

// PairwiseArbStrategy 扩展
type PairwiseArbStrategy struct {
    // ... 现有字段

    // 参数锁（热加载时使用）
    paramMu sync.RWMutex
}

// UpdateParameters 更新策略参数（线程安全）
func (s *PairwiseArbStrategy) UpdateParameters(params map[string]interface{}) {
    s.paramMu.Lock()
    defer s.paramMu.Unlock()

    // 映射 model 参数到策略参数
    if val, ok := params["BEGIN_PLACE"]; ok {
        if entryZScore, ok := val.(float64); ok {
            s.entryZScore = entryZScore
        }
    }

    if val, ok := params["BEGIN_REMOVE"]; ok {
        if exitZScore, ok := val.(float64); ok {
            s.exitZScore = exitZScore
        }
    }

    if val, ok := params["SIZE"]; ok {
        if size, ok := val.(int); ok {
            s.orderSize = int32(size)
        }
    }

    if val, ok := params["MAX_SIZE"]; ok {
        if maxSize, ok := val.(int); ok {
            s.maxPositionSize = int32(maxSize)
        }
    }

    if val, ok := params["STOP_LOSS"]; ok {
        if stopLoss, ok := val.(float64); ok {
            s.stopLoss = stopLoss
        }
    }

    log.Printf("[PairwiseArb] ✓ Parameters updated: entry=%.2f, exit=%.2f, size=%d",
        s.entryZScore, s.exitZScore, s.orderSize)
}

// GenerateSignal 使用参数时加锁
func (s *PairwiseArbStrategy) GenerateSignal(md1, md2 *mdpb.MarketDataUpdate) (strategy.Signal, error) {
    s.paramMu.RLock()
    entryZScore := s.entryZScore
    exitZScore := s.exitZScore
    orderSize := s.orderSize
    s.paramMu.RUnlock()

    // 使用参数生成信号...
    // ...
}
```

### 1.3 HTTP API 接口

```go
// pkg/trader/api.go

// Model相关API端点
func (api *TraderAPI) setupModelRoutes() {
    api.router.POST("/api/v1/model/reload", api.handleModelReload)
    api.router.GET("/api/v1/model/status", api.handleModelStatus)
    api.router.GET("/api/v1/model/history", api.handleModelHistory)
}

// handleModelReload 手动触发model重载
func (api *TraderAPI) handleModelReload(c *gin.Context) {
    log.Println("[API] Manual model reload triggered")

    if err := api.trader.ReloadModel(); err != nil {
        c.JSON(500, gin.H{
            "error": err.Error(),
            "message": "Failed to reload model",
        })
        return
    }

    c.JSON(200, gin.H{
        "success": true,
        "message": "Model reloaded successfully",
        "timestamp": time.Now().Format(time.RFC3339),
    })
}

// handleModelStatus model状态查询
func (api *TraderAPI) handleModelStatus(c *gin.Context) {
    status := api.trader.GetModelStatus()
    c.JSON(200, status)
}

// handleModelHistory 重载历史查询
func (api *TraderAPI) handleModelHistory(c *gin.Context) {
    history := api.trader.GetModelReloadHistory()
    c.JSON(200, history)
}
```

### 1.4 配置扩展

```yaml
# config/trader.yaml

system:
  strategy_id: "92201"
  mode: live

strategy:
  type: pairwise_arb
  symbols: [ag2502, ag2504]

  # Model文件路径（用于热加载）
  model_file: "./production_configs/models/model.ag2502.ag2504.par.txt.92201"

  # 热加载配置
  hot_reload:
    enabled: true              # 启用热加载
    check_interval: 5s         # 检查间隔
    auto_reload: true          # 自动重载
    manual_trigger: true       # 允许手动触发

  parameters:
    # 这些参数作为初始值，会被 model 文件覆盖
    entry_zscore: 1.5
    exit_zscore: 1.0
    lookback_window: 20
    max_position_size: 10

logging:
  level: info
  file: log/trader_92201.log

  # 热加载日志
  log_model_reload: true       # 记录重载事件
```

---

## 功能 2: 命令行参数兼容

### 2.1 参数映射设计

#### 旧系统 → 新系统参数映射表

| 旧参数 | 新参数/配置 | 说明 |
|-------|-----------|------|
| `--Live` | `--mode live` | 运行模式 |
| `--Backtest` | `--mode backtest` | 回测模式 |
| `--Simulation` | `--mode simulation` | 模拟模式 |
| `--controlFile` | `--control-file` | control文件路径 |
| `--strategyID` | `--strategy-id` | 策略ID |
| `--configFile` | `--legacy-config` | 旧配置文件 |
| `--logFile` | `--log-file` | 日志文件 |
| `--updateInterval` | `--update-interval` | 更新间隔(μs) |
| `--adjustLTP` | `--adjust-ltp` | 调整最后成交价 |
| `--printMod` | `--print-mode` | 打印模式 |

#### Control文件解析

**格式**:
```
ag_F_2_SFE ./models/model.ag2502.ag2504.par.txt.92201 SFE 4 TB_PAIR_STRAT 0900 1500 ag_F_4_SFE
```

**字段定义**:
```
[0] ag_F_2_SFE        - 合约1内部代码
[1] ./models/...      - model文件路径
[2] SFE               - 交易所
[3] 4                 - 合约2索引
[4] TB_PAIR_STRAT     - 策略类型
[5] 0900              - 开始时间
[6] 1500              - 结束时间
[7] ag_F_4_SFE        - 合约2内部代码
```

### 2.2 实现方案

#### 命令行参数扩展

```go
// cmd/trader/main.go

var (
    // 新增：旧系统兼容参数
    legacyMode      = flag.Bool("Live", false, "Legacy: Live trading mode")
    backtestMode    = flag.Bool("Backtest", false, "Legacy: Backtest mode")
    simulationMode  = flag.Bool("Simulation", false, "Legacy: Simulation mode")
    controlFile     = flag.String("controlFile", "", "Legacy: Control file path")
    legacyConfigFile = flag.String("configFile", "", "Legacy: Legacy config file path")
    adjustLTP       = flag.Int("adjustLTP", 0, "Legacy: Adjust last trade price")
    printMode       = flag.Int("printMod", 0, "Legacy: Print mode")
    updateInterval  = flag.Int("updateInterval", 300000, "Legacy: Update interval in microseconds")

    // 新增：新系统参数别名
    controlFilePath = flag.String("control-file", "", "Control file path (model + symbols)")
    updateIntervalMs = flag.Int("update-interval", 300, "Update interval in milliseconds")

    // 现有参数保持不变
    configFile  = flag.String("config", "./config/trader.yaml", "Configuration file path")
    strategyID  = flag.String("strategy-id", "", "Strategy ID (overrides config)")
    // ...
)
```

#### Control文件解析器

```go
// pkg/config/control_parser.go

// ControlFile control文件结构
type ControlFile struct {
    Symbol1       string
    Symbol2       string
    ModelFilePath string
    Exchange      string
    StrategyType  string
    StartTime     string
    EndTime       string
}

// ParseControlFile 解析control文件
func ParseControlFile(filePath string) (*ControlFile, error) {
    file, err := os.Open(filePath)
    if err != nil {
        return nil, fmt.Errorf("open control file: %w", err)
    }
    defer file.Close()

    scanner := bufio.NewScanner(file)
    if !scanner.Scan() {
        return nil, fmt.Errorf("empty control file")
    }

    line := strings.TrimSpace(scanner.Text())
    parts := strings.Fields(line)

    if len(parts) < 8 {
        return nil, fmt.Errorf("invalid control file format: expected 8 fields, got %d", len(parts))
    }

    control := &ControlFile{
        Symbol1:       convertInternalSymbol(parts[0]),
        ModelFilePath: parts[1],
        Exchange:      parts[2],
        StrategyType:  parts[4],
        StartTime:     formatTime(parts[5]),
        EndTime:       formatTime(parts[6]),
        Symbol2:       convertInternalSymbol(parts[7]),
    }

    return control, nil
}

// convertInternalSymbol 转换内部合约代码到标准代码
// ag_F_2_SFE -> ag2502
func convertInternalSymbol(internal string) string {
    // 示例: ag_F_2_SFE -> ag + 25 + 02 -> ag2502
    parts := strings.Split(internal, "_")
    if len(parts) < 3 {
        return internal
    }

    symbol := parts[0]  // ag
    month := parts[2]   // 2 (表示2月)

    // 根据月份推算合约代码
    // 简化实现，实际需要根据当前日期判断年份
    year := "25"  // 2025年
    monthStr := fmt.Sprintf("%02d", mustAtoi(month))

    return symbol + year + monthStr
}

// formatTime 格式化时间 0900 -> 09:00:00
func formatTime(t string) string {
    if len(t) != 4 {
        return t
    }
    return t[:2] + ":" + t[2:] + ":00"
}
```

#### Legacy配置转换器

```go
// pkg/config/legacy_converter.go

// ConvertLegacyToTraderConfig 转换旧配置到新配置
func ConvertLegacyToTraderConfig(
    controlFile *ControlFile,
    legacyConfigFile string,
    strategyID string,
    mode string,
    logFile string,
) (*TraderConfig, error) {

    // 解析 model 文件
    modelParser := &ModelFileParser{filePath: controlFile.ModelFilePath}
    modelParams, err := modelParser.Parse()
    if err != nil {
        return nil, fmt.Errorf("parse model file: %w", err)
    }

    // 创建新配置
    cfg := &TraderConfig{
        System: SystemConfig{
            StrategyID: strategyID,
            Mode:       mode,
        },
        Strategy: StrategyConfig{
            Type:    mapStrategyType(controlFile.StrategyType),
            Symbols: []string{controlFile.Symbol1, controlFile.Symbol2},
            Exchanges: []string{controlFile.Exchange},
            Parameters: convertModelToStrategyParams(modelParams),
            ModelFile: controlFile.ModelFilePath,
            HotReload: HotReloadConfig{
                Enabled:       true,
                CheckInterval: "5s",
                AutoReload:    true,
            },
        },
        Session: SessionConfig{
            StartTime: controlFile.StartTime,
            EndTime:   controlFile.EndTime,
            Timezone:  "Asia/Shanghai",
            AutoStart: false,
            AutoStop:  true,
        },
        Risk: RiskConfig{
            StopLoss: getFloatParam(modelParams, "STOP_LOSS", 100000),
            MaxLoss:  getFloatParam(modelParams, "MAX_LOSS", 100000),
        },
        Logging: LoggingConfig{
            Level: "info",
            File:  logFile,
        },
        // ... 其他配置
    }

    return cfg, nil
}

// mapStrategyType 映射策略类型
func mapStrategyType(legacyType string) string {
    switch legacyType {
    case "TB_PAIR_STRAT":
        return "pairwise_arb"
    case "TB_HEDGE_STRAT":
        return "hedging"
    default:
        return "passive"
    }
}

// convertModelToStrategyParams 转换model参数到策略参数
func convertModelToStrategyParams(modelParams map[string]interface{}) map[string]interface{} {
    params := make(map[string]interface{})

    // BEGIN_PLACE -> entry_zscore
    if val, ok := modelParams["BEGIN_PLACE"]; ok {
        params["entry_zscore"] = val
    }

    // BEGIN_REMOVE -> exit_zscore
    if val, ok := modelParams["BEGIN_REMOVE"]; ok {
        params["exit_zscore"] = val
    }

    // SIZE -> order_size
    if val, ok := modelParams["SIZE"]; ok {
        params["order_size"] = val
    }

    // MAX_SIZE -> max_position_size
    if val, ok := modelParams["MAX_SIZE"]; ok {
        params["max_position_size"] = val
    }

    // ALPHA -> alpha (spread decay factor)
    if val, ok := modelParams["ALPHA"]; ok {
        params["alpha"] = val
    }

    return params
}
```

#### Main函数集成

```go
// cmd/trader/main.go

func main() {
    flag.Parse()

    // 检测是否使用旧系统模式
    isLegacyMode := *controlFile != "" || *controlFilePath != ""

    var cfg *config.TraderConfig
    var err error

    if isLegacyMode {
        // 旧系统兼容模式
        log.Println("[Main] Running in legacy compatibility mode")
        cfg, err = loadLegacyConfig()
        if err != nil {
            log.Fatalf("[Main] Failed to load legacy config: %v", err)
        }
    } else {
        // 新系统模式
        log.Printf("[Main] Loading configuration from: %s", *configFile)
        cfg, err = config.LoadTraderConfig(*configFile)
        if err != nil {
            log.Fatalf("[Main] Failed to load config: %v", err)
        }
    }

    // 命令行参数覆盖
    applyCommandLineOverrides(cfg)

    // 继续启动流程...
    // ...
}

// loadLegacyConfig 加载旧系统配置
func loadLegacyConfig() (*config.TraderConfig, error) {
    // 确定control文件路径
    ctrlFile := *controlFile
    if ctrlFile == "" {
        ctrlFile = *controlFilePath
    }

    // 解析control文件
    control, err := config.ParseControlFile(ctrlFile)
    if err != nil {
        return nil, fmt.Errorf("parse control file: %w", err)
    }

    // 确定运行模式
    mode := "live"
    if *backtestMode {
        mode = "backtest"
    } else if *simulationMode {
        mode = "simulation"
    }

    // 确定日志文件
    logFilePath := *logFile
    if logFilePath == "" {
        logFilePath = fmt.Sprintf("./log/trader_%s.log", *strategyID)
    }

    // 转换为新配置
    cfg, err := config.ConvertLegacyToTraderConfig(
        control,
        *legacyConfigFile,
        *strategyID,
        mode,
        logFilePath,
    )
    if err != nil {
        return nil, fmt.Errorf("convert legacy config: %w", err)
    }

    log.Println("[Main] ✓ Legacy config converted successfully")
    return cfg, nil
}

// applyCommandLineOverrides 应用命令行参数覆盖
func applyCommandLineOverrides(cfg *config.TraderConfig) {
    if *strategyID != "" {
        cfg.System.StrategyID = *strategyID
    }

    if *mode != "" {
        cfg.System.Mode = *mode
    }

    if *logFile != "" {
        cfg.Logging.File = *logFile
    }

    if *updateIntervalMs > 0 {
        // 转换毫秒到持续时间
        cfg.Engine.TimerInterval = fmt.Sprintf("%dms", *updateIntervalMs)
    }

    // 旧参数兼容
    if *updateInterval > 0 {
        // 微秒转毫秒
        ms := *updateInterval / 1000
        cfg.Engine.TimerInterval = fmt.Sprintf("%dms", ms)
    }
}
```

### 2.3 启动脚本生成

修改生产配置生成器，同时生成兼容旧系统的启动脚本：

```go
// pkg/backtest/production_config.go

// generateStartScript 生成启动脚本（两种模式）
func (g *ProductionConfigGenerator) generateStartScript(cfg *ProductionConfig) error {
    // 生成新系统启动脚本
    newScript := g.generateNewSystemScript(cfg)
    newScriptPath := filepath.Join(g.outputDir, "scripts",
        fmt.Sprintf("start_%s.sh", cfg.SymbolPair))

    if err := os.WriteFile(newScriptPath, []byte(newScript), 0755); err != nil {
        return err
    }

    // 生成旧系统兼容启动脚本
    legacyScript := g.generateLegacySystemScript(cfg)
    legacyScriptPath := filepath.Join(g.outputDir, "scripts",
        fmt.Sprintf("start_%s.legacy.sh", cfg.SymbolPair))

    if err := os.WriteFile(legacyScriptPath, []byte(legacyScript), 0755); err != nil {
        return err
    }

    return nil
}

// generateLegacySystemScript 生成旧系统兼容启动脚本
func (g *ProductionConfigGenerator) generateLegacySystemScript(cfg *ProductionConfig) string {
    controlPath := filepath.Join("controls", cfg.ControlFileName)
    logFile := fmt.Sprintf("./log/log.%s.%s.txt",
        cfg.ControlFileName, time.Now().Format("20060102"))

    return fmt.Sprintf(`#!/bin/bash
# Legacy-compatible start script
# Generated: %s
# Strategy: %s (%s/%s)

# Check if NATS is running
if ! pgrep -x "nats-server" > /dev/null; then
    echo "Starting NATS server..."
    nats-server &
    sleep 2
fi

# Start trader (legacy mode)
echo "Starting trader in legacy compatibility mode..."
nohup ./bin/trader \
  --Live \
  --controlFile %s \
  --strategyID %s \
  --adjustLTP 1 \
  --printMod 1 \
  --updateInterval 300000 \
  --logFile %s \
  >> nohup.out.%s 2>&1 &

# Display process info
sleep 2
PID=$(pgrep -f "trader.*%s" | tail -1)
echo "Trader started. PID: $PID"
echo "Log file: %s"
echo "API endpoint: http://localhost:%d"
echo ""
echo "To activate strategy, run:"
echo "  curl -X POST http://localhost:%d/api/v1/strategy/activate"
`,
        time.Now().Format("2006-01-02 15:04:05"),
        cfg.StrategyID,
        cfg.Symbol1, cfg.Symbol2,
        controlPath,
        cfg.StrategyID,
        logFile,
        cfg.StrategyID,
        cfg.StrategyID,
        logFile,
        cfg.APIPort,
        cfg.APIPort,
    )
}
```

---

## 测试方案

### 1. Model热加载测试

#### 测试用例 1: 文件变化自动重载

```bash
# 1. 启动trader
./bin/trader -config config/trader_92201.yaml

# 2. 等待启动完成
sleep 5

# 3. 修改model文件
sed -i '' 's/BEGIN_PLACE 1.500000/BEGIN_PLACE 2.000000/' \
  production_configs/models/model.ag2502.ag2504.par.txt.92201

# 4. 等待自动重载（5秒）
sleep 6

# 5. 验证日志
grep "Model reloaded successfully" log/trader_92201.log
```

**预期结果**:
```
[ModelWatcher] Model file changed: production_configs/models/model.ag2502.ag2504.par.txt.92201
[ModelWatcher] ✓ Model reloaded successfully
[PairwiseArb] ✓ Parameters updated: entry=2.00, exit=1.00, size=4
```

#### 测试用例 2: API手动触发重载

```bash
# 1. 手动触发重载
curl -X POST http://localhost:9201/api/v1/model/reload

# 2. 检查响应
{
  "success": true,
  "message": "Model reloaded successfully",
  "timestamp": "2026-01-26T21:30:00+08:00"
}

# 3. 查询重载历史
curl http://localhost:9201/api/v1/model/history
```

#### 测试用例 3: 无效参数回滚

```bash
# 1. 写入无效参数
echo "BEGIN_PLACE 999.0" >> production_configs/models/model.ag2502.ag2504.par.txt.92201

# 2. 等待自动重载
sleep 6

# 3. 验证错误日志
grep "BEGIN_PLACE out of range" log/trader_92201.log

# 4. 验证策略仍使用旧参数
curl http://localhost:9201/api/v1/strategy/status | jq '.parameters.entry_zscore'
# 应该输出旧值: 1.5
```

#### 测试用例 4: 持仓保持测试

```bash
# 场景: 持有仓位时重载参数

# 1. 激活策略并等待建仓
curl -X POST http://localhost:9201/api/v1/strategy/activate
sleep 30

# 2. 检查持仓
curl http://localhost:9201/api/v1/position | jq '.net_qty'
# 假设输出: 10

# 3. 重载model
curl -X POST http://localhost:9201/api/v1/model/reload

# 4. 再次检查持仓（应该保持不变）
curl http://localhost:9201/api/v1/position | jq '.net_qty'
# 应该输出: 10
```

### 2. 命令行兼容测试

#### 测试用例 5: 旧系统启动方式

```bash
# 1. 使用旧系统参数启动
./bin/trader \
  --Live \
  --controlFile ./production_configs/controls/control.ag2502.ag2504.par.txt.92201 \
  --strategyID 92201 \
  --logFile ./log/trader_92201_legacy.log

# 2. 验证启动成功
tail -f log/trader_92201_legacy.log | grep "Trader is running"

# 3. 验证配置转换正确
curl http://localhost:9201/api/v1/strategy/status | jq '.'
```

**预期输出**:
```json
{
  "strategy_id": "92201",
  "type": "pairwise_arb",
  "symbols": ["ag2502", "ag2504"],
  "parameters": {
    "entry_zscore": 1.5,
    "exit_zscore": 1.0,
    ...
  }
}
```

#### 测试用例 6: Legacy启动脚本

```bash
# 1. 生成的legacy启动脚本
./production_configs/scripts/start_ag2502_ag2504.legacy.sh

# 2. 验证进程启动
ps aux | grep trader

# 3. 验证日志
tail -f log/log.control.ag2502.ag2504.par.txt.92201.*
```

#### 测试用例 7: 参数覆盖

```bash
# 1. 使用新参数覆盖control文件设置
./bin/trader \
  --control-file ./production_configs/controls/control.ag2502.ag2504.par.txt.92201 \
  --strategy-id 92201 \
  --mode simulation \
  --log-file ./log/test.log

# 2. 验证mode被覆盖
curl http://localhost:9201/api/v1/status | jq '.mode'
# 应该输出: "simulation"
```

### 3. 集成测试

```bash
#!/bin/bash
# test_hot_reload_and_legacy.sh

echo "=== Test 1: Model Hot Reload ==="
./bin/trader -config config/trader_92201.yaml &
TRADER_PID=$!
sleep 5

# Modify model
sed -i '' 's/BEGIN_PLACE 1.5/BEGIN_PLACE 2.0/' \
  production_configs/models/model.ag2502.ag2504.par.txt.92201
sleep 6

# Check reload
if grep -q "Model reloaded successfully" log/trader_92201.log; then
    echo "✓ Hot reload works"
else
    echo "✗ Hot reload failed"
fi

kill $TRADER_PID
sleep 2

echo "=== Test 2: Legacy Mode ==="
./bin/trader \
  --Live \
  --controlFile production_configs/controls/control.ag2502.ag2504.par.txt.92201 \
  --strategyID 92201 &
TRADER_PID=$!
sleep 5

# Check if running
if ps -p $TRADER_PID > /dev/null; then
    echo "✓ Legacy mode works"
else
    echo "✗ Legacy mode failed"
fi

kill $TRADER_PID

echo "=== All tests completed ==="
```

---

## 实施计划

### Phase 1: Model热加载 (2-3天)

**任务**:
1. ✅ 实现 ModelWatcher (文件监控)
2. ✅ 实现 ModelFileParser (model文件解析)
3. ✅ Strategy Engine 集成 (ApplyNewParameters)
4. ✅ HTTP API 接口 (reload, status, history)
5. ✅ 配置文件扩展 (hot_reload section)
6. ✅ 单元测试

**文件修改/新增**:
- `golang/pkg/trader/model_watcher.go` (新增)
- `golang/pkg/config/model_parser.go` (新增)
- `golang/pkg/strategy/strategy_engine.go` (修改)
- `golang/pkg/strategy/pairwise_arb.go` (修改)
- `golang/pkg/trader/api.go` (修改)
- `golang/cmd/trader/main.go` (修改)

### Phase 2: 命令行兼容 (2-3天)

**任务**:
1. ✅ 实现 ControlFile 解析器
2. ✅ 实现 Legacy配置转换器
3. ✅ 扩展命令行参数
4. ✅ Main函数集成
5. ✅ 生成Legacy启动脚本
6. ✅ 集成测试

**文件修改/新增**:
- `golang/pkg/config/control_parser.go` (新增)
- `golang/pkg/config/legacy_converter.go` (新增)
- `golang/cmd/trader/main.go` (修改)
- `golang/pkg/backtest/production_config.go` (修改)

### Phase 3: 测试和文档 (1-2天)

**任务**:
1. ✅ 编写测试脚本
2. ✅ 执行完整测试
3. ✅ 更新用户文档
4. ✅ 编写迁移指南

**文件新增**:
- `test_hot_reload.sh`
- `test_legacy_mode.sh`
- `docs/Trader_Model热加载使用指南.md`
- `docs/Trader_旧系统迁移指南.md`

**总工作量**: 5-8天

---

## 使用示例

### 1. 使用Model热加载

#### 新系统YAML配置方式

```yaml
# config/trader_92201.yaml
system:
  strategy_id: "92201"
  mode: live

strategy:
  type: pairwise_arb
  symbols: [ag2502, ag2504]

  # 启用model热加载
  model_file: "./production_configs/models/model.ag2502.ag2504.par.txt.92201"
  hot_reload:
    enabled: true
    check_interval: 5s
    auto_reload: true
```

```bash
# 启动
./bin/trader -config config/trader_92201.yaml

# 运行中修改参数
vi production_configs/models/model.ag2502.ag2504.par.txt.92201
# 修改 BEGIN_PLACE 1.5 -> 2.0

# 5秒后自动重载，或手动触发:
curl -X POST http://localhost:9201/api/v1/model/reload
```

### 2. 旧系统兼容模式

#### 方式1: 使用control文件

```bash
./bin/trader \
  --Live \
  --controlFile ./production_configs/controls/control.ag2502.ag2504.par.txt.92201 \
  --strategyID 92201 \
  --logFile ./log/trader_92201.log
```

#### 方式2: 使用Legacy启动脚本

```bash
# 自动生成的脚本
./production_configs/scripts/start_ag2502_ag2504.legacy.sh
```

#### 方式3: 传统nohup方式

```bash
nohup ./bin/trader \
  --Live \
  --controlFile ./production_configs/controls/control.ag2502.ag2504.par.txt.92201 \
  --strategyID 92201 \
  --adjustLTP 1 \
  --printMod 1 \
  --updateInterval 300000 \
  --logFile ./log/trader_92201.$(date +%Y%m%d).log \
  >> nohup.out.92201 2>&1 &
```

---

## 风险和注意事项

### 1. Model热加载风险

**问题**: 参数热加载可能影响运行中的策略

**缓解措施**:
- ✅ 参数验证（范围检查）
- ✅ 加载失败自动回滚
- ✅ 保持持仓和订单状态
- ✅ 记录变更历史
- ✅ 提供手动触发选项
- ✅ 可配置禁用自动重载

**最佳实践**:
- 交易时段外修改参数
- 先在模拟环境测试
- 逐步调整参数（不要大幅改动）
- 监控重载后的策略行为

### 2. 命令行兼容风险

**问题**: 旧参数可能无法完全映射到新系统

**缓解措施**:
- ✅ 提供参数映射文档
- ✅ 不支持的参数给出警告
- ✅ 保留新系统YAML配置优势
- ✅ 建议逐步迁移到新配置

### 3. 文件格式兼容性

**问题**: Control/Model文件格式可能有变化

**缓解措施**:
- ✅ 容错解析（跳过不识别的行）
- ✅ 提供格式验证工具
- ✅ 详细的错误提示

---

## 性能影响

### Model热加载

| 操作 | 时间 | 影响 |
|------|------|------|
| 文件检查 | < 1ms | 每5秒一次，可忽略 |
| 文件解析 | < 10ms | 仅在重载时 |
| 参数应用 | < 5ms | 加锁操作，极小 |
| 总体影响 | 0 | 策略性能无影响 |

### 命令行解析

| 操作 | 时间 | 影响 |
|------|------|------|
| Control文件解析 | < 5ms | 仅启动时 |
| 配置转换 | < 10ms | 仅启动时 |
| Model文件解析 | < 10ms | 仅启动时 |
| 总启动时间增加 | +25ms | 可忽略 |

---

## 总结

本设计实现了两个P1优先级功能：

1. **Model热加载**
   - 运行时动态更新策略参数
   - 保持策略状态不变
   - 提供API手动触发
   - 完善的错误处理和回滚

2. **命令行参数兼容**
   - 支持旧系统启动方式
   - 自动转换control/model文件
   - 降低迁移成本
   - 保持新系统优势

**核心价值**:
- ✅ 提升运维便利性（无需重启）
- ✅ 降低迁移成本（兼容旧系统）
- ✅ 保持系统稳定性（状态保持）
- ✅ 提供灵活性（手动+自动）

**建议**: 作为P1优先级，建议在Phase 3稳定后立即实施。

---

**最后更新**: 2026-01-26 21:30
