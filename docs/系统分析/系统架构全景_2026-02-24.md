# QuantLink Trade System — 系统架构全景

**文档日期**: 2026-02-24
**适用架构**: SysV MWMR SHM 直连架构（tbsrc-golang v2）

---

## 1. 系统总览

QuantLink Trade System 是面向中国期货市场（SHFE、CFFEX、DCE、ZCE、GFEX）的高频量化交易系统，采用 **C++ 网关 + Golang 策略引擎** 的混合架构。所有进程间通信通过 **SysV 共享内存 MWMR（Multi-Writer Multi-Reader）队列** 完成，交易热路径无网络序列化开销。

### 1.1 进程架构图

```
┌─────────────────────────────────────────────────────────────────────┐
│                        QuantLink Trade System                       │
│                                                                     │
│  ┌──────────────────┐    SysV SHM 0x1001    ┌───────────────────┐  │
│  │  md_shm_feeder   │──── MarketUpdateNew ──→│                   │  │
│  │  (C++ 行情注入)   │    (816 bytes/tick)    │                   │  │
│  └──────────────────┘                        │   Go trader       │  │
│         ▲                                    │   (策略引擎)       │  │
│         │                                    │                   │  │
│    CTP行情服务器                              │  ┌─────────────┐  │  │
│    或 模拟器                                  │  │ PairwiseArb │  │  │
│                                              │  │  Strategy   │  │  │
│  ┌──────────────────┐    SysV SHM 0x2001    │  └─────────────┘  │  │
│  │  counter_bridge   │←── RequestMsg ────────│                   │  │
│  │  (C++ 成交网关)   │    (256 bytes/order)   │                   │  │
│  │                   │                        │                   │  │
│  │                   │── ResponseMsg ────────→│                   │  │
│  └──────────────────┘    SysV SHM 0x3001     └───────────────────┘  │
│         │                (176 bytes/resp)           │               │
│         ▼                                           ▼               │
│    CTP交易服务器                              REST/WebSocket        │
│    或 模拟器                                  :9201 Dashboard       │
│                                                                     │
│  ┌──────────────────┐                                               │
│  │   webserver       │  :8080 Overview 总览页面                      │
│  │   (Go)            │                                               │
│  └──────────────────┘                                               │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.2 核心进程

| 进程 | 语言 | 职责 |
|------|------|------|
| `md_shm_feeder` | C++ | 行情注入器。接收 CTP 行情或生成模拟行情，转换为 `MarketUpdateNew` 写入 SHM |
| `counter_bridge` | C++ | 统一成交网关。从 SHM 读取订单请求，路由到 CTP/模拟器，将回报写入 SHM |
| `trader` | Go | 策略引擎。直接读写 SysV SHM，执行配对套利策略，管理订单和持仓 |
| `webserver` | Go | Web 监控服务。提供 Overview 总览页面（端口 8080） |

### 1.3 与旧架构的对比

| 方面 | 旧架构（NATS/gRPC 5 进程） | 新架构（SysV MWMR SHM 直连） |
|------|---------------------------|------------------------------|
| 行情路径 | md_simulator → SHM → md_gateway → NATS → trader | md_shm_feeder → SHM → trader |
| 订单路径 | trader → gRPC → ors_gateway → SHM → counter_bridge | trader → SHM → counter_bridge |
| 进程数 | 5 个（md_sim + md_gw + trader + ors_gw + counter_bridge） | 3 个（md_shm_feeder + trader + counter_bridge） |
| IPC 机制 | POSIX SHM + NATS + gRPC | SysV MWMR SHM（全链路） |
| 序列化 | NATS JSON + gRPC Protobuf | 零拷贝二进制（struct 直传） |

---

## 2. 核心组件详解

### 2.1 md_shm_feeder（C++ 行情注入器）

**源码**: `gateway/src/md_shm_feeder.cpp`（约 543 行）

**职责**: 创建行情 MWMR 队列（key `0x1001`），将行情数据以 `MarketUpdateNew` 格式写入队列。

**运行模式**:

| 模式 | 启动命令 | 数据源 |
|------|---------|--------|
| 模拟器 | `md_shm_feeder simulator:ag2603,ag2605` | 内置随机游走价格生成器，支持 5 档盘口 |
| CTP | `md_shm_feeder ctp:config/ctp/ctp_md.secret.yaml` | CTP 行情服务器（`CThostFtdcMdSpi` 回调） |

**模拟器特性**:
- 生成相关性随机游走价格（两个品种之间有价差相关性）
- 支持 `--rate` 参数控制 tick 频率
- 支持 `--queue-size` 参数控制队列容量
- 生成完整的 5 档买卖盘口

**CTP 模式流程**:
```
CTP Server → OnRtnDepthMarketData() → 转换 CThostFtdcDepthMarketDataField
                                           → 填充 MarketUpdateNew
                                           → g_md_queue->enqueue(md)
```

### 2.2 counter_bridge（C++ 统一成交网关）

**源码**: `gateway/src/counter_bridge.cpp`（约 892 行）

**职责**: 创建订单请求队列（key `0x2001`）、回报队列（key `0x3001`）和 ClientStore（key `0x4001`）。读取订单请求，路由到券商插件，将回报写回 SHM。

**核心功能**:

1. **订单路由**: 从 Request 队列 dequeue `RequestMsg`，转换为 `ITDPlugin::OrderRequest`，发送到 CTP 或模拟器插件
2. **开平判断** (`SetCombOffsetFlag`): 自动判断 OPEN / CLOSE_TODAY / CLOSE_YESTERDAY（翻译自 `ors/China/src/ORSServer.cpp:488-605`），遵循 SHFE/INE 平今优先规则
3. **持仓跟踪** (`updatePosition`): 维护每个合约的 `contractPos`（隔夜多/今多/隔夜空/今空）
4. **回报分发**: 将券商回调转换为 `ResponseMsg`，enqueue 到 Response 队列
5. **ClientStore**: 原子分配客户端 ID，多个 trader 进程可共享同一组队列

**插件架构**:
```
ITDPlugin (接口)
  ├── CTPTDPlugin    — CTP 交易 API 对接
  └── SimulatorPlugin — 即时成交模拟（测试用）
```

### 2.3 trader（Go 策略引擎）

**源码**: `tbsrc-golang/cmd/trader/main.go`（约 322 行）

**职责**: 策略主进程。直接读写 SysV SHM，运行配对套利策略，管理订单生命周期和持仓。

**内部结构**:
```
trader 进程
├── Connector            — SHM 连接管理，OrderID 生成，轮询 goroutine
│   ├── pollMD()         — goroutine: 轮询行情队列
│   └── pollORS()        — goroutine: 轮询回报队列
├── Client               — 行情/回报路由，订单构造
├── PairwiseArbStrategy  — 配对套利策略
│   ├── LegManager(leg1) — 被动腿管理（挂单）
│   └── LegManager(leg2) — 主动腿管理（追单）
├── SpreadTracker        — 价差 EWMA 跟踪
├── API Server           — REST/WebSocket 监控接口
└── Signal Handler       — SIGUSR1/SIGUSR2/SIGTSTP 信号处理
```

### 2.4 webserver（Go Web 监控）

**源码**: `tbsrc-golang/cmd/webserver/main.go`

**职责**: 提供 Overview 总览页面（端口 8080），扫描各策略的 Dashboard 端口（9201-9210），聚合展示所有策略状态。

---

## 3. SysV MWMR SHM 队列设计

### 3.1 SHM Key 分配

| SysV Key | 十进制 | 用途 | 写入方 | 读取方 | 元素类型 |
|----------|--------|------|--------|--------|----------|
| `0x1001` | 4097 | 行情队列 | md_shm_feeder | trader | `MarketUpdateNew` (816B) |
| `0x2001` | 8193 | 订单请求队列 | trader | counter_bridge | `RequestMsg` (256B) |
| `0x3001` | 12289 | 订单回报队列 | counter_bridge | trader | `ResponseMsg` (176B) |
| `0x4001` | 16385 | ClientStore | trader / counter_bridge | trader / counter_bridge | `ClientData` (16B) |

### 3.2 MWMR 队列内存布局

每个 MWMR 队列占用一个 SysV SHM 段，内存结构如下：

```
偏移 0:
┌──────────────────────────────────────────┐
│ MWMRHeader (8 bytes)                     │
│   head: atomic<int64>  (初始值 = 1)      │
├──────────────────────────────────────────┤
│ Slot[0]: QueueElem<T>                    │
│   data: T              (sizeof(T) bytes) │
│   seqNo: uint64        (8 bytes)         │
├──────────────────────────────────────────┤
│ Slot[1]: QueueElem<T>                    │
│   ...                                    │
├──────────────────────────────────────────┤
│ ...                                      │
├──────────────────────────────────────────┤
│ Slot[size-1]: QueueElem<T>               │
└──────────────────────────────────────────┘

总大小 = 8 + size * sizeof(QueueElem<T>)
```

**关键设计点**:
- `size` 始终为 2 的幂（使用 `nextPowerOf2()` 对齐）
- `mask = size - 1`，用于位运算取模（`head & mask`）
- `head` 从 1 开始（不是 0），这对正确性至关重要
- `tail` 是每个读者进程的本地变量（不在 SHM 中），每个读者独立追踪自己的 `localTail`
- 写入顺序：先写 `data`，后写 `seqNo`（作为 release barrier）
- 读取时通过 `seqNo >= localTail` 判断数据就绪

### 3.3 队列元素大小

| 类型 | `sizeof(T)` | `sizeof(QueueElem<T>)` | 说明 |
|------|-------------|------------------------|------|
| `MarketUpdateNew` | 816 | 824 (816+8) | 无额外对齐填充 |
| `RequestMsg` | 256 | 320 (256+8+56 pad) | `aligned(64)` 导致填充到 5×64 |
| `ResponseMsg` | 176 | 184 (176+8) | 无额外对齐填充 |

### 3.4 ClientStore

```
┌──────────────────────────────┐
│ ClientData (16 bytes)        │
│   data: atomic<int64>  ← 当前计数器（原子递增）
│   firstClientId: int64 ← 初始值
└──────────────────────────────┘
```

多个 trader 进程通过 `atomic.AddInt64(&data, 1) - 1` 获取唯一的 `clientID`。每个进程用 `clientID` 来：
- 生成 OrderID: `clientID * 1_000_000 + 自增序号`
- 过滤回报: `resp.OrderID / 1_000_000 == clientID`（只处理自己的订单）

---

## 4. 消息结构体

### 4.1 MarketUpdateNew（816 bytes）— 行情消息

由 md_shm_feeder 写入，trader 读取。与 hftbase 原始 C++ 结构体二进制兼容。

```
MarketUpdateNew (816 bytes)
├── MDHeaderPart (96 bytes)
│   ├── ExchTS          int64    [0:8]     交易所时间戳
│   ├── Timestamp        int64    [8:16]    本地时间戳
│   ├── Seqnum           int64    [16:24]   序列号
│   ├── RptSeqnum        int32    [24:28]   报告序列号
│   ├── TokenId          int32    [28:32]   Token ID
│   ├── Symbol           [48]byte [32:80]   合约代码（如 "ag2603\0..."）
│   ├── SymbolID         int32    [80:84]   合约数字 ID
│   └── ExchangeName     int32    [84:88]   交易所代码
│       _pad             [8]byte  [88:96]
│
└── MDDataPart (720 bytes)
    ├── NewPrice         float64  [96:104]   最新价
    ├── OldPrice         float64  [104:112]  上一价
    ├── LastTradedPrice  float64  [112:120]  最新成交价
    ├── LastTradedTime   int64    [120:128]  最新成交时间
    ├── TotalTradedValue float64  [128:136]  成交金额
    ├── TotalTradedQty   float64  [136:144]  成交量
    ├── Yield            float64  [144:152]  收益率
    ├── BidUpdates       [20]BookElement [152:472]  买盘 20 档
    ├── AskUpdates       [20]BookElement [472:792]  卖盘 20 档
    ├── NewQuant         int32    [792:796]  最新数量
    ├── OldQuant         int32    [796:800]  上一数量
    ├── LastTradedQty    int32    [800:804]  最新成交数量
    ├── ValidBids        int16    [804:806]  有效买档数
    ├── ValidAsks        int16    [806:808]  有效卖档数
    ├── UpdateLevel      int16    [808:810]
    ├── EndPkt           byte     [810:811]
    ├── Side             byte     [811:812]
    ├── UpdateType       byte     [812:813]
    └── FeedType         byte     [813:814]
        _pad             [2]byte  [814:816]
```

**BookElement**（16 bytes）:
```
├── Quantity    int32    [0:4]    数量
├── OrderCount  int32    [4:8]    委托笔数
└── Price       float64  [8:16]   价格
```

### 4.2 RequestMsg（256 bytes, aligned(64)）— 订单请求

由 trader 写入，counter_bridge 读取。

```
RequestMsg (256 bytes)
├── ContractDescription (96 bytes)
│   ├── InstrumentName  [32]byte [0:32]    合约名称
│   ├── Symbol          [50]byte [32:82]   合约代码
│   ├── _pad            [2]byte  [82:84]
│   ├── ExpiryDate      int32    [84:88]   到期日 (YYYYMMDD)
│   ├── StrikePrice     float64  [88:96]   行权价
│
├── Request_Type        int32    [96:100]   请求类型（NEWORDER=0, CANCEL=1, MODIFY=2）
├── OrdType             int32    [100:104]  LIMIT=0, MARKET=1
├── Duration            int32    [104:108]  FAK / DAY / IOC
├── PxType              int32    [108:112]  PERUNIT=0
├── PosDirection        int32    [112:116]  持仓方向
├── OrderID             uint32   [116:120]  订单 ID（clientID * 1M + seq）
├── Token               int32    [120:124]
├── Quantity            int32    [124:128]  数量
├── QuantityFilled      int32    [128:132]  已成交量
├── DisclosedQnty       int32    [132:136]
├── Price               float64  [136:144]  价格
├── TimeStamp           uint64   [144:152]  时间戳
├── AccountID           [11]byte [152:163]  账户 ID
├── TransactionType     byte     [163:164]  'B' = 买, 'S' = 卖
├── ExchangeType        byte     [164:165]  交易所类型
├── Padding             [20]byte [165:185]
├── Product             [32]byte [185:217]  品种代码
├── _pad                [3]byte  [217:220]
├── StrategyID          int32    [220:224]  策略 ID
└── _pad                [32]byte [224:256]
```

### 4.3 ResponseMsg（176 bytes）— 订单回报

由 counter_bridge 写入，trader 读取。

```
ResponseMsg (176 bytes)
├── Response_Type       int32    [0:4]     回报类型（见下表）
├── OrderID             uint32   [4:8]     订单 ID
├── ErrorCode           uint32   [8:12]    错误码
├── Quantity            int32    [12:16]   数量
├── Price               float64  [16:24]   价格
├── TimeStamp           uint64   [24:32]   时间戳
├── Side                byte     [32:33]   'B' / 'S'
├── Symbol              [50]byte [33:83]   合约代码
├── AccountID           [11]byte [83:94]
├── ExchangeOrderId     float64  [94:102]  交易所订单号
├── ExchangeTradeId     [21]byte [102:123] 交易所成交号
├── OpenClose           int8     [123:124] 开/平标志
├── ExchangeID          int8     [124:125] 交易所 ID
├── Product             [32]byte [125:157] 品种代码
├── StrategyID          int32    [157:161] 策略 ID
└── _pad                [15]byte [161:176]
```

**Response_Type 枚举**:

| 值 | 名称 | 含义 |
|----|------|------|
| 0 | `NEW_ORDER_CONFIRM` | 新订单确认 |
| 1 | `REPLACE_ORDER_CONFIRM` | 改单确认 |
| 2 | `ORDER_NOT_FOUND` | 订单未找到 |
| 3 | `CANCEL_ORDER_CONFIRM` | 撤单确认 |
| 4 | `TRADE_CONFIRM` | 成交确认 |
| 5 | `ORDER_ERROR` | 订单错误 |
| 6 | `FROZEN` | 冻结 |
| 7 | `DISCONNECTED` | 断连 |
| 8 | `ORS_REJECT` | ORS 拒绝 |
| 9 | `RMS_REJECT` | 风控拒绝 |
| 10 | `CANCEL_REJECT` | 撤单拒绝 |
| 11 | `TRADE_CANCEL_CONFIRM` | 成交撤销确认 |
| 12 | `TRADE_CORRECT_CONFIRM` | 成交更正确认 |

---

## 5. 数据流

### 5.1 行情路径

```
CTP 行情服务器 / 模拟器随机数发生器
        │
        ▼
md_shm_feeder (C++)
  ① 构建 MarketUpdateNew 结构体（零初始化 + 填充字段）
  ② g_md_queue->enqueue(md)  [atomic head++, memcpy data, store seqNo]
        │
        ▼  [SysV MWMR SHM, key=0x1001]
        │
Go trader: Connector.pollMD() goroutine
  ③ mdQueue.Dequeue(&md)  [检查 seqNo >= localTail, memcpy out, advance tail]
  ④ mdCallback(&md) → Client.OnMDUpdate(md)
        │
        ▼
Client.OnMDUpdate(md)
  ⑤ extractSymbol(md.Header.Symbol[:])  → 提取合约代码
  ⑥ instruments[symbol].UpdateFromMD(md) → 更新 BBO、LTP、成交量
  ⑦ strategies[symbol].MDCallBack(inst, md)
        │
        ▼
PairwiseArbStrategy.MDCallBack(inst, md)
  ⑧ 价差跟踪: EWMA 更新 avgSpreadRatio
  ⑨ 阈值重算: SetThresholds()
  ⑩ 信号生成: SendOrder() 挂出被动腿报价
```

### 5.2 订单路径

```
PairwiseArbStrategy
  SendOrder() / SendAggressiveOrder()
        │
        ▼
LegManager.SendBidOrder() / SendAskOrder()
        │
        ▼
OrderManager.SendNewOrder()
        │
        ▼
Client.SendNewOrder(inst, side, price, qty, ordHitType, cb)
  ① 填充 RequestMsg 字段: Symbol, TransactionType('B'/'S'), Price, Quantity,
     Product, StrategyID, AccountID, OrdType=LIMIT, Duration=FAK/DAY
        │
        ▼
Connector.SendNewOrder(&reqMsg)
  ② orderID = clientID * 1_000_000 + atomic_seq++
  ③ reqMsg.OrderID = orderID
  ④ reqMsg.Request_Type = NEWORDER
  ⑤ reqQueue.Enqueue(&reqMsg)  [atomic head++, memcpy, store seqNo]
        │
        ▼  [SysV MWMR SHM, key=0x2001]
        │
counter_bridge (C++): 订单处理线程
  ⑥ req_queue->dequeuePtr(&req)
  ⑦ SetCombOffsetFlag(): 自动判断 OPEN / CLOSE_TODAY / CLOSE_YESTERDAY
  ⑧ 转换为 ITDPlugin::OrderRequest
  ⑨ broker->SendOrder(unified_req) → CTP API 或模拟器
```

### 5.3 回报路径

```
券商回调（CTP/模拟器）→ OnBrokerOrderCallback()
        │
        ▼
counter_bridge: OnBrokerOrderCallback(order_info)
  ① 通过 broker_order_id 查找 CachedOrderInfo
  ② 填充 ResponseMsg: OrderID, StrategyID, Side, Symbol, Response_Type
  ③ updatePosition(): 更新 contractPos（隔夜多/今多/隔夜空/今空）
  ④ g_response_queue->enqueue(resp)
        │
        ▼  [SysV MWMR SHM, key=0x3001]
        │
Go trader: Connector.pollORS() goroutine
  ⑤ respQueue.Dequeue(&resp)
  ⑥ 过滤: resp.OrderID / 1_000_000 == clientID  [只处理自己的订单]
  ⑦ orsCallback(&resp) → Client.OnORSUpdate(resp)
        │
        ▼
Client.OnORSUpdate(resp)
  ⑧ orderIDMap[resp.OrderID] → 查找策略回调
  ⑨ cb.ORSCallBack(resp)
        │
        ▼
PairwiseArbStrategy.ORSCallBack(resp)
  ⑩ 根据 resp.Response_Type 分支处理:
     - TRADE_CONFIRM:  ProcessTrade(), 更新持仓, 触发 leg2 SendAggressiveOrder()
     - CANCEL_ORDER_CONFIRM: 清理订单映射
     - ORDER_ERROR / ORS_REJECT / RMS_REJECT: 处理拒绝
```

### 5.4 客户端注册路径

```
Go trader 启动: connector.New(cfg, mdCb, orsCb)
        │
        ▼
shm.NewClientStore(cfg.ClientStoreShmKey)  [ShmOpen key=0x4001]
  cs.GetClientIDAndIncrement()  [atomic.AddInt64(&data, 1) - 1]
  返回唯一 clientID (1, 2, 3...)
        │
        ▼
Connector 保存 clientID，用于:
  ● OrderID 生成: clientID * 1_000_000 + seq
  ● 回报过滤:    resp.OrderID / 1_000_000 == clientID
```

多个 trader 进程可共享同一组 SHM 队列，每个进程通过原子计数器获取唯一 clientID，只处理自己的回报。

---

## 6. Go 包职责

### 6.1 包结构总览

```
tbsrc-golang/
├── cmd/
│   ├── trader/main.go        # 策略引擎主程序入口
│   └── webserver/main.go     # Web 监控主程序入口
│
└── pkg/
    ├── shm/                   # SysV SHM 底层封装
    ├── connector/             # SHM 连接管理 + 轮询
    ├── client/                # 行情/回报路由 + 订单构造
    ├── strategy/              # 配对套利策略
    ├── execution/             # 单腿订单/持仓/PNL 管理
    ├── instrument/            # 合约信息 + 盘口更新
    ├── types/                 # 阈值集、枚举、公共类型
    ├── config/                # YAML 配置加载
    └── api/                   # REST/WebSocket 监控接口
```

### 6.2 各包详解

| 包 | 关键文件 | 职责 |
|----|---------|------|
| **`shm`** | `sysv.go`, `mwmr_queue.go`, `types.go`, `client_store.go`, `tvar.go` | SysV SHM 系统调用封装（`shmget`/`shmat`/`shmdt`，纯 Go syscall 无 CGO）；MWMR 泛型队列实现；二进制兼容的消息结构体定义；ClientStore 原子 ID 分配；TVar 外部参数 SHM |
| **`connector`** | `connector.go` | 管理 3 个 MWMR 队列 + ClientStore；分配 clientID；生成 OrderID（`clientID * 1M + seq`）；运行 `pollMD()` 和 `pollORS()` goroutine；按 clientID 过滤回报；暴露 `SendNewOrder()` / `SendCancelOrder()` / `SendModifyOrder()` |
| **`client`** | `client.go` | C++ `CommonClient` 的 Go 翻译；按合约代码路由行情到 instrument 和 strategy；按 OrderID 路由回报到策略回调；构造 `RequestMsg`（填充字段映射）；管理 `orderIDMap` |
| **`strategy`** | `pairwise_arb_strategy.go`, `pairwise_callbacks.go`, `spread_tracker.go` 等 19 文件 | `PairwiseArbStrategy` 主策略；组合两个 `LegManager`（leg1=被动, leg2=主动）；EWMA 价差跟踪 `SpreadTracker`；动态阈值 `SetThresholds()`；信号生成 `SendOrder()`、`SendAggressiveOrder()`；全仓处理 `HandleSquareoff()`；`sync.Mutex` 保护并发安全 |
| **`execution`** | `leg_manager.go`, `order_manager.go`, `execution_state.go`, `pnl.go`, `squareoff.go` 等 12 文件 | `LegManager`（翻译自 C++ `ExtraStrategy`）— 单腿订单/持仓/PNL 管理；`OrderManager` — 订单生命周期（新建/改单/撤单/成交）；`ExecutionState` — 持仓跟踪（Netpos, NetposPass, NetposPassYtd, NetposAgg）、PNL 计算；平仓逻辑、阈值应用 |
| **`instrument`** | `instrument.go` | `Instrument` 结构体 — 合约代码、tick size、lot size、20 档 BBO 数组；`UpdateFromMD()` 从 `MarketUpdateNew` 更新盘口 |
| **`types`** | `threshold_set.go`, `order_stats.go` 等 5 文件 | `ThresholdSet` — 40+ 阈值参数，从 YAML map 加载；订单统计；交易类型/订单类型枚举 |
| **`config`** | `config.go`, `daily_init.go` 等 5 文件 | YAML 配置加载与验证（`Config`, `StrategyConfig`, `InstrumentConfig`, `ORSConfig`）；`DailyInit` 文件读写（avgSpreadOri, 持仓） |
| **`api`** | `server.go`, `handlers.go`, `snapshot.go`, `websocket.go` | REST API 服务器；策略快照采集；WebSocket 实时更新；HTTP 处理（activate, deactivate, squareoff, reload_thresholds） |

### 6.3 关键设计：Go 的并发模型

C++ 原系统是单线程的（所有回调串行执行）。Go 版本有两个轮询 goroutine（`pollMD` 和 `pollORS`），因此 `PairwiseArbStrategy` 使用 `sync.Mutex` 保护所有共享状态。

---

## 7. 配置体系

### 7.1 配置文件结构

每个策略一个配置文件，命名格式：`config/trader.{strategy_id}.yaml`

```yaml
# config/trader.92201.yaml

ors:                                    # SHM 连接参数
  md_shm_key: 0x1001                    # 行情队列 SysV key
  md_queue_size: 65536                  # 队列容量（必须为 2 的幂）
  req_shm_key: 0x2001                   # 订单请求队列 key
  req_queue_size: 4096
  resp_shm_key: 0x3001                  # 订单回报队列 key
  resp_queue_size: 4096
  client_store_shm_key: 0x4001          # ClientStore key

strategy:
  strategy_id: 92201                    # 策略唯一标识
  account: "account_id"                 # 交易账户
  product: "ag"                         # 品种代码
  symbols: [ag2603, ag2605]             # 交易合约（必须 >= 2 个）
  instruments:                          # 每个合约的配置
    ag2603:
      exchange: "SHFE"
      tick_size: 1.0
      lot_size: 15.0
      contract_factor: 15.0
      send_in_lots: false
      token: 0
      expiry_date: 20260315
  thresholds:                           # 每腿的阈值参数
    first:                              # leg1（被动腿）
      begin_place: 0.5                  # 开始挂单的 Z-Score 阈值
      long_place: 2.0                   # 做多阈值
      short_place: -2.0                 # 做空阈值
      begin_remove: 0.2                 # 撤单阈值
      alpha: 0.01                       # EWMA 衰减系数
      max_quote_level: 3                # 最大挂单档位
      size: 1                           # 单次下单手数
      max_size: 10                      # 最大持仓手数
      tvar_key: 0x5001                  # 可选：外部 TVar SHM key
    second:                             # leg2（主动腿）
      max_size: 10
  exchange_costs:
    buy_exch_tx: 0.0001                 # 买入手续费率
    sell_exch_tx: 0.0001                # 卖出手续费率

system:
  api_port: 9201                        # REST/WebSocket 端口
  log_level: "info"
```

### 7.2 Daily Init 文件

路径：`data/daily_init.{strategyID}`

用于跨交易日持久化策略状态：

| 字段 | 含义 |
|------|------|
| `AvgSpreadOri` | EWMA 基准价差 |
| `NetposYtd1` | leg1 昨仓 |
| `Netpos2day1` | leg1 今仓 |
| `NetposAgg2` | leg2 主动腿持仓 |

**生命周期**: 策略 shutdown 时写入 → 下次启动时读取 → 恢复上一交易日的状态

### 7.3 CTP 配置

```yaml
# config/ctp/ctp_md.secret.yaml（行情账号，gitignored）
broker_id: "9999"
user_id: "your_user_id"
password: "your_password"
front_addr: "tcp://180.168.146.187:10131"

# config/ctp/ctp_td.secret.yaml（交易账号，gitignored）
broker_id: "9999"
user_id: "your_user_id"
password: "your_password"
auth_code: "your_auth_code"
app_id: "your_app_id"
front_addr: "tcp://180.168.146.187:10130"
```

### 7.4 热重载

发送 `SIGUSR2` 信号给 trader 进程可热重载阈值参数（重新读取 YAML），无需重启进程。

---

## 8. 启动与停止流程

### 8.1 启动顺序

```
1. start_gateway.sh [sim|ctp]
   ├── 启动 md_shm_feeder (创建 SHM 0x1001，开始写入行情)
   ├── 启动 counter_bridge (创建 SHM 0x2001, 0x3001, 0x4001)
   └── 启动 webserver (端口 8080)

2. start_strategy.sh <strategy_id>
   └── 启动 trader (读取 trader.{id}.yaml, 连接 SHM, 运行策略)
```

**trader 内部启动序列**（`cmd/trader/main.go`）:

```
 ① 解析命令行参数: -config (YAML 路径), -data (daily_init 目录)
 ② 加载配置: config.Load(configPath) → 验证 SHM key 非零
 ③ 验证策略合约: 至少需要 2 个合约（配对套利）
 ④ 创建 Connector: 连接 4 个 SysV SHM 段, 分配 clientID
 ⑤ 创建 Client: 设置行情/回报路由
 ⑥ 创建 Instrument: 加载每个合约的 tick size, lot size 等
 ⑦ 注册 Instrument: cli.RegisterInstrument(inst1), cli.RegisterInstrument(inst2)
 ⑧ 加载 ThresholdSet: 从 YAML 读取 "first" 和 "second" 阈值集
 ⑨ 创建 PairwiseArbStrategy: 两个 LegManager + SpreadTracker + ORS 回调
 ⑩ 设置交易所费用: SetExchangeCosts()
 ⑪ 注册策略: 两个合约都路由到同一个 strategy
 ⑫ 加载 daily_init: 恢复上一交易日状态（avgSpreadOri, 昨仓）
 ⑬ 打开 TVar SHM: 可选的外部调整参数
 ⑭ 启动 API Server: REST/WebSocket (默认 :9201)
 ⑮ 启动 Connector: pollMD() + pollORS() goroutine 开始轮询
 ⑯ 激活策略: pas.SetActive(true)
 ⑰ 注册信号: SIGINT/SIGTERM(停止), SIGUSR1(重新激活), SIGUSR2(热重载), SIGTSTP(平仓)
 ⑱ 主循环: select on 信号通道、1秒快照 ticker、API 命令通道
```

### 8.2 停止顺序

```
stop_all.sh:
  ① SIGTERM → trader (等待 graceful shutdown，保存 daily_init)
  ② 等待最多 10 秒，超时则 SIGKILL
  ③ 停止 counter_bridge
  ④ 停止 md_shm_feeder
  ⑤ 停止 webserver
  ⑥ 清理 SysV 共享内存段 (ipcrm)
```

**trader 内部停止序列**（收到 SIGINT/SIGTERM）:

```
 ① pas.HandleSquareoff() — 撤销所有挂单，保存 daily_init
 ② conn.Stop() — 停止 pollMD/pollORS goroutine
 ③ 保存 daily_init 文件
 ④ 关闭 TVar SHM
 ⑤ conn.Close() — detach 所有 SHM 段
```

### 8.3 信号处理

| 信号 | 行为 |
|------|------|
| `SIGINT` / `SIGTERM` | Graceful shutdown（保存状态后退出） |
| `SIGUSR1` | 重新激活策略 |
| `SIGUSR2` | 热重载阈值参数（重读 YAML） |
| `SIGTSTP` | 触发平仓（squareoff） |

---

## 9. 关键设计决策

### 9.1 为什么选择 SysV MWMR SHM 而不是 NATS/gRPC？

| 考量 | NATS/gRPC 旧方案 | SysV MWMR SHM 新方案 |
|------|-----------------|---------------------|
| 延迟 | NATS ~5ms, gRPC ~10ms | SHM < 1μs |
| 进程数 | 5 个（需 md_gateway, ors_gateway 中转） | 3 个（Go 直连 SHM） |
| 序列化 | JSON (NATS) + Protobuf (gRPC) | 零拷贝（二进制 struct 直传） |
| 依赖 | 需要 nats-server、gRPC 库 | 仅 OS 内核 SysV SHM |
| 复杂度 | 多层抽象、多种协议 | 单一 IPC 机制 |

### 9.2 为什么使用 SysV SHM 而不是 POSIX SHM？

- hftbase 原始 C++ 代码使用 SysV SHM（`shmget`/`shmat`，整数 key）
- 保持与 C++ 二进制兼容，无需修改 C++ 网关代码
- SysV SHM 在 Go 中可通过 `syscall.Syscall` 直接调用，无需 CGO

### 9.3 为什么 Go 端不使用 CGO？

- 纯 Go `syscall.Syscall(SYS_SHMGET, ...)` 直接调用 SysV SHM
- 无 CGO 意味着可以交叉编译（macOS 上编译 Linux 二进制）
- 避免 CGO 的线程模型问题和构建复杂度
- Go struct 通过手工填充 `_pad` 字段确保与 GCC x86-64 布局完全一致

### 9.4 二进制兼容如何保证？

- Go 消息结构体（`MarketUpdateNew`、`RequestMsg`、`ResponseMsg`）手工添加 `_pad` 字段
- 使用 `offset_check` 工具比较 C++ `sizeof`/`offsetof` 与 Go `unsafe.Sizeof`/`unsafe.Offsetof`
- 保证字节级一致：Go 写的 `RequestMsg` 在 C++ 端可直接 `memcpy` 读取

### 9.5 Lock-free 队列如何工作？

- **写入方**: `atomic.AddInt64(&head, 1)` 获取 slot，写入 data，最后写入 seqNo（release barrier）
- **读取方**: 本地 `localTail` 跟踪读取位置，检查 `slot.seqNo >= localTail` 判断数据就绪
- **多写安全**: head 使用 atomic fetch_add，多个写者可并发
- **多读安全**: 每个读者独立维护 localTail，互不干扰
- **环形覆盖**: `slot = head & mask`，旧数据被自然覆盖

### 9.6 为什么 Go 需要 Mutex 而 C++ 不需要？

C++ 原系统是单线程事件驱动（所有回调在同一线程串行执行）。Go 版本有两个并发 goroutine：
- `pollMD()` — 行情回调触发策略逻辑
- `pollORS()` — 回报回调触发成交处理

两者都可能修改 `PairwiseArbStrategy` 的状态，因此需要 `sync.Mutex` 保护。

---

## 10. 参考文档

| 文档 | 内容 | 路径 |
|------|------|------|
| 部署指南 | 编译、配置、启动、监控、停止 | `docs/核心文档/DEPLOY_GUIDE_2026-02-24.md` |
| 架构更新 | C++ → Go 迁移方案、文件对照表 | `docs/系统分析/tbsrc-golang_v2_架构更新_2026-02-13-16_00.md` |
| MWMR 技术规格 | 队列实现细节、内存布局、原子操作 | `docs/系统分析/hftbase_MWMR_Go复刻技术规格_2026-02-13-16_00.md` |
| counter_bridge 改造 | 订单网关 MWMR 改造方案 | `docs/系统分析/counter_bridge_MWMR改造方案_2026-02-13-19_00.md` |

---

**最后更新**: 2026-02-24
