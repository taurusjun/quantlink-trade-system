# 配对策略架构对比分析：独立 Strategy 对象 vs 独立持仓统计

**文档日期**: 2026-01-30
**作者**: Claude Code
**版本**: v1.0
**相关模块**: Golang Strategy, Architecture Design

---

## 问题背景

在修复配对策略 P&L 计算时，我们采用了"为每条腿添加独立持仓统计字段"的方案。但 tbsrc 的设计是"每条腿有独立的 ExecutionStrategy 对象"。

**核心问题**：是否应该重构为每条腿独立的 Strategy 对象？

---

## tbsrc 的架构设计

### 1. 类层次结构

```
ExecutionStrategy (基类)
    ↓ 继承
ExtraStrategy (单腿策略，增强功能)
    ↓ 被包含
PairwiseArbStrategy (配对策略)
    - m_firstStrat: ExtraStrategy*  (Leg1)
    - m_secondStrat: ExtraStrategy* (Leg2)
```

### 2. ExecutionStrategy 的职责

**文件**: `tbsrc/Strategies/include/ExecutionStrategy.h`

#### 核心成员变量（60+ 个）

```cpp
class ExecutionStrategy {
    // ===== 持仓管理 =====
    int32_t m_netpos;              // 净持仓
    double m_buyQty;               // 多头数量
    double m_sellQty;              // 空头数量
    double m_buyTotalQty;          // 累计买入
    double m_sellTotalQty;         // 累计卖出
    double m_buyAvgPrice;          // 买入均价
    double m_sellAvgPrice;         // 卖出均价
    double m_buyPrice;             // 当前买价
    double m_sellPrice;            // 当前卖价

    // ===== P&L 计算 =====
    double m_realisedPNL;          // 已实现盈亏
    double m_unrealisedPNL;        // 浮动盈亏
    double m_netPNL;               // 净盈亏
    double m_grossPNL;             // 总盈亏
    double m_buyTotalValue;        // 买入总金额
    double m_sellTotalValue;       // 卖出总金额
    double m_transTotalValue;      // 手续费

    // ===== 订单管理 =====
    int32_t m_orderCount;          // 订单数
    int32_t m_tradeCount;          // 成交数
    int32_t m_rejectCount;         // 拒单数
    int32_t m_cancelCount;         // 撤单数
    OrderMap m_ordMap;             // 订单映射

    // ===== 状态控制 =====
    bool m_Active;                 // 是否激活
    bool m_onFlat;                 // 是否平仓
    bool m_onExit;                 // 是否退出
    bool m_onStopLoss;             // 止损标志

    // ===== 风控参数 =====
    int32_t m_rmsQty;              // 风控数量
    double m_maxTradedQty;         // 最大交易量

    // ===== 其他 =====
    Instrument* m_instru;          // 关联的合约
    SimConfig* m_simConfig;        // 配置
    CommonClient* m_client;        // 客户端连接
};
```

#### 核心方法

```cpp
class ExecutionStrategy {
    // 市场数据回调
    virtual void MDCallBack(MarketUpdateNew* up);

    // 订单回报回调
    virtual void ORSCallBack(ResponseMsg* response);

    // 成交回调
    virtual void TradeCallBack(ResponseMsg* response);

    // 计算 P&L
    void CalculatePNL();

    // 发送订单
    virtual void SendOrder();

    // 平仓处理
    virtual void HandleSquareoff();

    // 风控检查
    bool CheckRisk();
};
```

### 3. PairwiseArbStrategy 的设计

**文件**: `tbsrc/Strategies/PairwiseArbStrategy.cpp`

#### 构造函数

```cpp
PairwiseArbStrategy::PairwiseArbStrategy(CommonClient *client, SimConfig *simConfig)
    : ExecutionStrategy(client, simConfig)
{
    // 创建两个独立的 ExtraStrategy 对象
    m_firstStrat = new ExtraStrategy(client, simConfig);
    m_secondStrat = new ExtraStrategy(client, simConfig);

    // 设置第二条腿的合约
    m_secondStrat->m_instru = m_secondStrat->m_instru_sec;

    // 获取订单映射的引用
    m_ordMap1 = &m_firstStrat->m_ordMap;
    m_ordMap2 = &m_secondStrat->m_ordMap;

    // 从文件加载初始持仓
    auto mx_daily_init2 = LoadMatrix2("../data/daily_init." + std::to_string(m_strategyID));
    m_firstStrat->m_netpos_pass_ytd = netpos_ytd1;
    m_firstStrat->m_netpos = netpos_ytd1 + netpos_2day1;
}
```

#### 订单回报处理

```cpp
void PairwiseArbStrategy::ORSCallBack(ResponseMsg *response) {
    // 根据 OrderID 判断是哪条腿的订单
    if (m_ordMap1->find(response->OrderID) != m_ordMap1->end()) {
        // Leg1 的订单，委托给 m_firstStrat 处理
        m_firstStrat->ORSCallBack(response);

        if (response->Response_Type == TRADE_CONFIRM) {
            // 计算配对策略的总 P&L（两条腿相加）
            double arbi_unrealisedPNL = m_firstStrat->m_unrealisedPNL +
                                       m_secondStrat->m_unrealisedPNL;
            double arbi_realisedPNL = (m_firstStrat->m_realisedPNL - m_firstStrat->m_transTotalValue) +
                                      (m_secondStrat->m_realisedPNL - m_secondStrat->m_transTotalValue);

            // 上报配对策略的持仓和 P&L
            SendMonitorStratPos(...);
            SendMonitorStratPNL(...);
        }
    }
    else if (m_ordMap2->find(response->OrderID) != m_ordMap2->end()) {
        // Leg2 的订单，委托给 m_secondStrat 处理
        m_secondStrat->ORSCallBack(response);
        // ...
    }
}
```

#### 发送订单

```cpp
void PairwiseArbStrategy::SendOrder() {
    // 计算价差
    currSpreadRatio = i1_bestBid - expectedRatio * i2_bestAsk;

    if (currSpreadRatio > threshold_buy) {
        // 发送 Leg1 买单（通过 m_firstStrat）
        m_firstStrat->SendBidOrder(...);

        // 发送 Leg2 卖单（通过 m_secondStrat）
        m_secondStrat->SendAskOrder(...);
    }
}
```

### 4. 关键设计特点

#### ✅ 优点

1. **完全解耦**
   - 每条腿有独立的 ExecutionStrategy 对象
   - 所有持仓、P&L、订单管理都是独立的
   - 不会出现数据混淆

2. **代码复用**
   - ExecutionStrategy 的所有功能（持仓管理、P&L 计算、风控等）都可以被每条腿复用
   - 不需要在 PairwiseArbStrategy 中重复实现这些逻辑

3. **易于扩展**
   - 如果需要 3 条腿，只需添加 `m_thirdStrat`
   - 每条腿可以有不同的配置和策略

4. **职责清晰**
   - ExecutionStrategy 负责单腿的交易执行
   - PairwiseArbStrategy 负责价差计算和腿之间的协调

#### ⚠️ 缺点

1. **内存开销**
   - 每个 ExecutionStrategy 对象有 60+ 个成员变量
   - 两条腿就是双倍内存

2. **构造复杂**
   - 需要在构造函数中创建和初始化两个 Strategy 对象
   - 需要管理两个对象的生命周期

3. **回调路由**
   - 订单回报需要根据 OrderID 路由到正确的腿
   - 增加了一层间接调用

---

## 我们当前的实现

### 架构设计

```
BaseStrategy (基类)
    - EstimatedPosition (共享)
    - PNL (共享)
    - RiskMetrics (共享)
    ↓ 继承
PairwiseArbStrategy (配对策略)
    - leg1Position: int64
    - leg2Position: int64
    - leg1BuyQty, leg1SellQty, leg1BuyAvgPrice, leg1SellAvgPrice (独立字段)
    - leg2BuyQty, leg2SellQty, leg2BuyAvgPrice, leg2SellAvgPrice (独立字段)
```

### 代码结构

**文件**: `golang/pkg/strategy/pairwise_arb_strategy.go`

```go
type PairwiseArbStrategy struct {
    *BaseStrategy  // 嵌入 BaseStrategy

    // 配对策略特有字段
    symbol1, symbol2 string

    // 每条腿的持仓统计（16 个字段）
    leg1Position, leg2Position int64
    leg1BuyQty, leg1SellQty int64
    leg1BuyAvgPrice, leg1SellAvgPrice float64
    leg1BuyTotalQty, leg1SellTotalQty int64
    leg1BuyTotalValue, leg1SellTotalValue float64

    leg2BuyQty, leg2SellQty int64
    leg2BuyAvgPrice, leg2SellAvgPrice float64
    leg2BuyTotalQty, leg2SellTotalQty int64
    leg2BuyTotalValue, leg2SellTotalValue float64
}

// 更新每条腿的持仓
func (pas *PairwiseArbStrategy) updateLeg1Position(side, qty, price) {
    // 实现中国期货净持仓逻辑
}

func (pas *PairwiseArbStrategy) updateLeg2Position(side, qty, price) {
    // 实现中国期货净持仓逻辑
}

// 计算 P&L
func (pas *PairwiseArbStrategy) updatePairwisePNL() {
    // 使用每条腿的独立平均价格计算
    leg1PnL := calculateLeg1PnL(pas.leg1BuyAvgPrice, pas.leg1SellAvgPrice)
    leg2PnL := calculateLeg2PnL(pas.leg2BuyAvgPrice, pas.leg2SellAvgPrice)
    unrealizedPnL = leg1PnL + leg2PnL
}
```

### 特点

#### ✅ 优点

1. **轻量级**
   - 只添加了 16 个字段（每条腿 8 个）
   - 没有额外的对象创建和管理

2. **实现简单**
   - 直接在 PairwiseArbStrategy 中管理两条腿的持仓
   - 不需要复杂的对象路由

3. **性能好**
   - 没有额外的间接调用
   - 内存局部性好

#### ⚠️ 缺点

1. **代码重复**
   - `updateLeg1Position` 和 `updateLeg2Position` 逻辑几乎完全相同
   - 如果有 3 条腿，需要再写一遍 `updateLeg3Position`

2. **扩展性差**
   - 添加新腿需要手动添加所有字段和方法
   - 不够灵活

3. **混合职责**
   - PairwiseArbStrategy 既要管理价差，又要管理每条腿的持仓
   - 职责不够清晰

---

## 方案对比

### 方案 A：独立 Strategy 对象（类似 tbsrc）

#### 设计

```go
// 单腿策略（类似 ExecutionStrategy）
type LegStrategy struct {
    *BaseStrategy

    symbol string
    // 所有持仓管理、P&L 计算都在这里
}

// 配对策略
type PairwiseArbStrategy struct {
    ID string

    leg1 *LegStrategy  // Leg1 独立对象
    leg2 *LegStrategy  // Leg2 独立对象

    // 只保留价差计算相关字段
    spreadAnalyzer *spread.SpreadAnalyzer
    entryZScore, exitZScore float64
}

func (pas *PairwiseArbStrategy) OnOrderUpdate(update *orspb.OrderUpdate) {
    // 根据 symbol 路由到对应的腿
    if update.Symbol == pas.leg1.symbol {
        pas.leg1.UpdatePosition(update)
        pas.leg1.UpdatePNL(bidPrice, askPrice)
    } else if update.Symbol == pas.leg2.symbol {
        pas.leg2.UpdatePosition(update)
        pas.leg2.UpdatePNL(bidPrice, askPrice)
    }

    // 计算配对策略的总 P&L
    pas.PNL.UnrealizedPnL = pas.leg1.PNL.UnrealizedPnL + pas.leg2.PNL.UnrealizedPnL
    pas.PNL.RealizedPnL = pas.leg1.PNL.RealizedPnL + pas.leg2.PNL.RealizedPnL
}
```

#### 优点
- ✅ 完全复用 BaseStrategy 的所有功能
- ✅ 每条腿完全独立，不会混淆
- ✅ 扩展到 3 条腿很容易
- ✅ 职责清晰（LegStrategy 管理单腿，PairwiseArbStrategy 管理价差）

#### 缺点
- ❌ 需要重构现有代码
- ❌ 增加内存开销（每条腿都是完整的 BaseStrategy）
- ❌ 需要实现订单路由逻辑
- ❌ 与当前的 Strategy 接口不兼容（Strategy 接口假设只有一个策略）

### 方案 B：独立持仓统计（当前实现）

#### 设计

```go
type PairwiseArbStrategy struct {
    *BaseStrategy

    // 每条腿的持仓统计（16 个字段）
    leg1BuyQty, leg1SellQty int64
    leg1BuyAvgPrice, leg1SellAvgPrice float64
    // ...

    leg2BuyQty, leg2SellQty int64
    leg2BuyAvgPrice, leg2SellAvgPrice float64
    // ...
}

func (pas *PairwiseArbStrategy) updateLeg1Position(...) { /* 实现 */ }
func (pas *PairwiseArbStrategy) updateLeg2Position(...) { /* 实现 */ }
```

#### 优点
- ✅ 实现简单，修改量小
- ✅ 性能好，内存开销小
- ✅ 与现有架构兼容
- ✅ 已经完成并验证通过

#### 缺点
- ❌ 代码重复（updateLeg1Position 和 updateLeg2Position）
- ❌ 扩展性差（添加第 3 条腿需要手动添加字段）
- ❌ 职责混合（配对策略既管理价差又管理持仓）

### 方案 C：混合方案（推荐）

#### 设计

创建一个轻量级的 `LegPosition` 结构体，封装单腿的持仓逻辑，但不需要完整的 Strategy 对象。

```go
// 单腿持仓管理器（轻量级）
type LegPosition struct {
    symbol string

    // 持仓统计
    netPosition int64
    buyQty, sellQty int64
    buyAvgPrice, sellAvgPrice float64
    buyTotalQty, sellTotalQty int64
    buyTotalValue, sellTotalValue float64

    // 持仓更新逻辑（复用 BaseStrategy 的逻辑）
    mu sync.RWMutex
}

func NewLegPosition(symbol string) *LegPosition {
    return &LegPosition{
        symbol: symbol,
    }
}

// 更新持仓（中国期货净持仓模型）
func (lp *LegPosition) UpdatePosition(side orspb.OrderSide, qty int64, price float64) {
    lp.mu.Lock()
    defer lp.mu.Unlock()

    // 实现中国期货净持仓逻辑（买入先平空再开多，卖出先平多再开空）
    // 这里的逻辑与 BaseStrategy.UpdatePosition 类似
}

// 计算浮动盈亏
func (lp *LegPosition) CalculateUnrealizedPnL(bidPrice, askPrice float64) float64 {
    if lp.netPosition > 0 {
        // 多头：使用卖一价
        return float64(lp.netPosition) * (bidPrice - lp.buyAvgPrice)
    } else if lp.netPosition < 0 {
        // 空头：使用买一价
        return float64(-lp.netPosition) * (lp.sellAvgPrice - askPrice)
    }
    return 0
}

// 配对策略
type PairwiseArbStrategy struct {
    *BaseStrategy

    leg1 *LegPosition  // Leg1 持仓管理器
    leg2 *LegPosition  // Leg2 持仓管理器

    // 价差计算相关
    spreadAnalyzer *spread.SpreadAnalyzer
    entryZScore, exitZScore float64
}

func NewPairwiseArbStrategy(id string) *PairwiseArbStrategy {
    return &PairwiseArbStrategy{
        BaseStrategy: NewBaseStrategy(id, "pairwise_arb"),
        leg1:         NewLegPosition(""),  // 在 Initialize 中设置 symbol
        leg2:         NewLegPosition(""),
    }
}

func (pas *PairwiseArbStrategy) OnOrderUpdate(update *orspb.OrderUpdate) {
    // 更新 BaseStrategy（用于整体统计）
    pas.UpdatePosition(update)

    // 更新对应腿的持仓
    if update.Status == orspb.OrderStatus_FILLED {
        if update.Symbol == pas.leg1.symbol {
            pas.leg1.UpdatePosition(update.Side, update.FilledQty, update.AvgPrice)
        } else if update.Symbol == pas.leg2.symbol {
            pas.leg2.UpdatePosition(update.Side, update.FilledQty, update.AvgPrice)
        }
    }
}

func (pas *PairwiseArbStrategy) updatePairwisePNL() {
    // 计算每条腿的浮动盈亏
    leg1PnL := pas.leg1.CalculateUnrealizedPnL(pas.bid1, pas.ask1)
    leg2PnL := pas.leg2.CalculateUnrealizedPnL(pas.bid2, pas.ask2)

    // 总浮动盈亏
    pas.PNL.UnrealizedPnL = leg1PnL + leg2PnL
    pas.PNL.TotalPnL = pas.PNL.RealizedPnL + pas.PNL.UnrealizedPnL
}
```

#### 优点
- ✅ 封装了单腿逻辑，避免代码重复
- ✅ 轻量级（LegPosition 只有持仓统计，没有 BaseStrategy 的其他功能）
- ✅ 易于扩展（添加第 3 条腿只需 `leg3 *LegPosition`）
- ✅ 职责清晰（LegPosition 管理持仓，PairwiseArbStrategy 管理价差）
- ✅ 与现有架构兼容

#### 缺点
- ⚠️ 需要一定的重构工作
- ⚠️ 比方案 B（当前实现）稍微复杂一点

---

## 推荐方案

### 短期方案（保持当前实现）

**结论**：✅ **保持方案 B（当前实现）**

**理由**：
1. 已经实现并验证通过
2. 性能好，内存开销小
3. 与现有架构兼容
4. 代码重复的问题在只有 2 条腿时是可以接受的

**何时需要重构**：
- 当需要支持 3 条腿或更多时
- 当需要为每条腿添加更复杂的逻辑时（如每条腿独立的风控、独立的订单管理等）

### 长期方案（如果需要扩展）

**结论**：✅ **采用方案 C（混合方案）**

**理由**：
1. 平衡了代码复用和实现复杂度
2. LegPosition 轻量级，内存开销可控
3. 易于扩展到多条腿
4. 职责清晰，易于维护

**不推荐方案 A（完整 Strategy 对象）**：
- 内存开销太大（每条腿都是完整的 BaseStrategy）
- 与当前的 Strategy 接口不兼容
- 重构工作量大

---

## 实施建议

### 当前（2026-01-30）

✅ **保持方案 B**（已实现）

- 系统已经修复并验证通过
- 与 tbsrc 逻辑一致（每条腿有独立平均价格）
- 性能和稳定性都没有问题

### 未来（如果需要）

如果出现以下情况，考虑重构为方案 C：

1. **需要支持 3 条腿或更多**
   - 添加 `leg3 *LegPosition` 即可
   - 不需要复制粘贴代码

2. **需要为每条腿添加更多功能**
   - 例如：每条腿独立的订单管理、独立的风控等
   - 这时 LegPosition 可以扩展更多方法

3. **代码维护成本增加**
   - updateLeg1Position 和 updateLeg2Position 的重复代码导致维护困难
   - 重构为 LegPosition 可以统一维护

### 重构步骤（如果采用方案 C）

1. **创建 LegPosition 结构体**
   - 提取 leg1/leg2 的所有字段到 LegPosition
   - 实现 UpdatePosition 和 CalculateUnrealizedPnL 方法

2. **修改 PairwiseArbStrategy**
   - 将 leg1/leg2 字段替换为 `leg1 *LegPosition`, `leg2 *LegPosition`
   - 修改 OnOrderUpdate 调用 `leg1.UpdatePosition()`
   - 修改 updatePairwisePNL 调用 `leg1.CalculateUnrealizedPnL()`

3. **测试验证**
   - 确保持仓更新逻辑正确
   - 确保 P&L 计算正确
   - 与当前实现对比验证

**预计工作量**：2-3 小时

---

## 结论

### 问题回答

**问题**：是否应该改成每条腿有独立的 Strategy 对象（类似 tbsrc）？

**答案**：❌ **不推荐**（完整的 Strategy 对象），✅ **当前实现已足够好**

### 关键点

1. **tbsrc 的设计有其历史原因**
   - C++ 中对象管理和继承是常见模式
   - ExecutionStrategy 承载了大量功能（60+ 个字段）
   - 复用 ExecutionStrategy 可以避免重复实现

2. **我们的实现更轻量级**
   - Golang 的组合优于继承的设计理念
   - 只添加必要的字段，避免不必要的开销
   - 当前实现已经解决了 P&L 计算的核心问题

3. **如果未来需要扩展**
   - 采用方案 C（LegPosition 轻量级对象）
   - 平衡代码复用和实现复杂度
   - 保持架构清晰和易维护

### 最终建议

✅ **保持当前实现（方案 B）**，不需要重构

- 已经验证通过
- 性能好，内存开销小
- 与 tbsrc 在核心逻辑上一致（每条腿独立平均价格）
- 如果未来需要支持 3 条腿或更复杂的功能，再考虑重构为方案 C

---

## 参考资料

- tbsrc 代码: `/Users/user/PWorks/RD/tbsrc/Strategies/`
  - `PairwiseArbStrategy.h/cpp` - 配对策略
  - `ExecutionStrategy.h/cpp` - 单腿策略基类
  - `ExtraStrategy.h/cpp` - 增强单腿策略
- 当前实现: `golang/pkg/strategy/pairwise_arb_strategy.go`
- 修复报告: `docs/实盘/中国期货市场规则修复报告_2026-01-30-20_01.md`

---

**最后更新**: 2026-01-30 20:10
