# tbsrc-golang：C++ tbsrc 完整 Go 翻译方案

**文档日期**: 2026-02-13
**版本**: v3.0（合并完整版）
**关联文档**:
- MWMR 技术规格: `docs/系统分析/hftbase_MWMR_Go复刻技术规格_2026-02-13-16_00.md`
- counter_bridge 改造: `docs/系统分析/counter_bridge_MWMR改造方案_2026-02-13-19_00.md`

---

## 概述

新建独立项目 `tbsrc-golang`，从 C++ `tbsrc/` 逐行翻译为 Go，不依赖任何现有 `golang/` 代码，最终删除 `golang/` 目录。

**核心原则**：
- 方法名、字段名尽可能与 C++ 一致
- CommonClient 直接翻译为 Go，不发明新的 StrategyEngine 抽象
- 所有参数从配置读取，不自设默认值
- SHM 直连：Go trader 直接读写 SysV 共享内存（MWMR 队列），不经过 NATS/gRPC
- CentOS 兼容：纯 Go syscall（无 CGO），支持 `GOOS=linux GOARCH=amd64` 交叉编译

---

## 1. 架构

### 1.1 架构对比

```
旧 golang/ 架构（5 进程）:
  trader → [gRPC] → ors_gateway → [POSIX SPSC SHM] → counter_bridge → CTP/Simulator

新 tbsrc-golang 架构（与 C++ 完全一致）:
  go_trader ──→ [SysV MWMR SHM, key=REQUEST_SHMKEY] ──→ ORS (Shengli/China)
            ←── [SysV MWMR SHM, key=RESPONSE_SHMKEY] ←──    └→ 交易所 (CTP/EES/YD)
            ←── [SysV MWMR SHM, key=MD_SHMKEY]       ←── MD feeder (C++)
```

**Go trader 直接对接原 ORS 进程**，与 C++ trader 使用完全相同的 SHM 队列。多个 Go/C++ trader 可同时连接同一个 ORS。

### 1.2 收益

| 收益 | 说明 |
|------|------|
| RMS 风控 | ORS 内建：订单限额、自成交检查、撤单次数限制 |
| 开平推断 | ORS 的 `SetCombOffsetFlag()` 根据持仓自动决定平今/平昨/开仓 |
| 多账户管理 | ORS 的 `m_accountMap[clientId]` 自动填充 AccountID |
| 持仓跟踪 | ORS 的 `mapContractPos` / `mapTsPos` 实时跟踪 |
| 生产验证 | hftbase MWMR 已在多个交易所长期生产运行 |
| 混合部署 | Go trader 和 C++ trader 可并行运行，共享 ORS |

### 1.3 关键技术选型

| 项目 | 选型 | 原因 |
|------|------|------|
| **SHM 类型** | SysV SHM（`shmget`/`shmat`，整数 key） | hftbase 用 SysV SHM |
| **消息结构体** | `RequestMsg`/`ResponseMsg`（hftbase） | 必须与原 ORS 二进制兼容 |
| **行情结构体** | `MarketUpdateNew`（hftbase） | 必须与原 md feeder 兼容 |
| **Queue Header** | 仅 `head`（8 bytes），初始值 1 | hftbase 的 tail 不在 SHM 中 |
| **QueueElem** | `{data, seqNo}`（data 在前） | C++ 源码 QueueElem 定义 |
| **OrderID** | `uint32 = clientId × 1000000 + seq` | 与 hftbase Connector 一致 |
| **回报过滤** | `OrderID / ORDERID_RANGE` | 与 C++ Connector 一致 |

---

## 2. 项目结构

```
quantlink-trade-system/
├── gateway/                    # C++ 网关（不动）
├── golang/                     # 旧 Go 代码（最终删除）
├── tbsrc-golang/               # ★ 新项目
│   ├── go.mod                  # module tbsrc-golang
│   ├── cmd/
│   │   ├── trader/
│   │   │   └── main.go         # ← main.cpp 翻译
│   │   └── offset_check/
│   │       └── main.go         # struct offset 验证工具
│   ├── pkg/
│   │   ├── shm/                # ★ SysV SHM + MWMR Queue
│   │   │   ├── sysv.go         #    SysV SHM 封装（shmget/shmat/shmdt）
│   │   │   ├── sysv_linux.go   #    Linux syscall 常量
│   │   │   ├── sysv_darwin.go  #    macOS syscall 常量
│   │   │   ├── mwmr_queue.go   #    MWMRQueue[T] 泛型实现
│   │   │   ├── client_store.go #    ClientStore（原子 clientId 分配）
│   │   │   ├── types.go        # ★ RequestMsg/ResponseMsg/MarketUpdateNew
│   │   │   ├── constants.go    #    ORDERID_RANGE、ExchangeType 等
│   │   │   └── queue_test.go   #    SHM 读写 + 结构对齐测试
│   │   ├── connector/          # ← Connector 翻译（SysV MWMR 版本）
│   │   │   └── connector.go    #    SHM 轮询 + 发单/撤单
│   │   ├── common/             # ← CommonClient.cpp 翻译
│   │   │   ├── client.go
│   │   │   └── signals.go
│   │   ├── strategy/           # ← Strategies/ 翻译
│   │   │   ├── execution_strategy.go
│   │   │   ├── extra_strategy.go
│   │   │   ├── pairwise_arb.go
│   │   │   ├── instrument.go
│   │   │   ├── threshold_set.go
│   │   │   ├── order_map.go
│   │   │   ├── daily_init.go
│   │   │   └── types.go
│   │   ├── indicator/          # ← Indicators/ 翻译
│   │   │   ├── indicator.go
│   │   │   ├── basket.go
│   │   │   ├── spread_ratio.go
│   │   │   ├── book_imbalance.go
│   │   │   ├── book_delta.go
│   │   │   ├── dynamic_beta.go
│   │   │   ├── static_beta.go
│   │   │   ├── vwap.go
│   │   │   ├── momentum.go
│   │   │   ├── bollinger.go
│   │   │   ├── trade_volume.go
│   │   │   ├── factory.go
│   │   │   └── target_pnl.go
│   │   └── config/             # 配置加载
│   │       ├── config.go       #    YAML 配置
│   │       ├── ors_config.go   # ★ ORS .cfg 配置解析（SHM key 等）
│   │       ├── control.go
│   │       └── model.go
│   ├── tools/
│   │   └── offset_check.cpp    # C++ offset_check 源码（在 hftbase 环境编译）
│   └── scripts/
│       └── verify_offsets.sh   # 编译运行 offset_check 对比 C++ 与 Go
├── config/
└── deploy/
```

---

## 3. C++ → Go 文件对照表

| C++ 文件 | 行数 | Go 文件 | C++ 类/函数 → Go 类型/方法 |
|----------|------|---------|---------------------------|
| `tbsrc/main/main.cpp` | 1,103 | `cmd/trader/main.go` | main() → main() |
| `tbsrc/main/CommonClient.cpp` | 1,136 | `pkg/common/client.go` | CommonClient → CommonClient |
| `tbsrc/main/include/CommonClient.h` | 131 | `pkg/common/client.go` | 字段定义 |
| `tbsrc/Strategies/ExecutionStrategy.cpp` | 2,506 | `pkg/strategy/execution_strategy.go` | ExecutionStrategy → ExecutionStrategy |
| `tbsrc/Strategies/include/ExecutionStrategy.h` | 579 | `pkg/strategy/execution_strategy.go` | 字段 + 虚函数签名 |
| `tbsrc/Strategies/PairwiseArbStrategy.cpp` | 947 | `pkg/strategy/pairwise_arb.go` | PairwiseArbStrategy → PairwiseArbStrategy |
| `tbsrc/Strategies/include/ExtraStrategy.h/.cpp` | ~655 | `pkg/strategy/extra_strategy.go` | ExtraStrategy → ExtraStrategy |
| `tbsrc/Strategies/include/ExecutionStrategyStructs.h` | ~70 | `pkg/strategy/order_map.go` | OrderMap → OrderMap |
| `tbsrc/main/include/TradeBotUtils.h` (ThresholdSet) | ~200 | `pkg/strategy/threshold_set.go` | ThresholdSet → ThresholdSet |
| `tbsrc/common/Instrument.h/.cpp` | ~500 | `pkg/strategy/instrument.go` | Instrument → Instrument |
| `hftbase/Ipc/include/multiwritermultireadershmqueue.h` | 256 | `pkg/shm/mwmr_queue.go` | MultiWriterMultiReaderShmQueue → MWMRQueue[T] |
| `hftbase/Ipc/include/locklessshmclientstore.h` | ~90 | `pkg/shm/client_store.go` | LocklessClientStore → ClientStore |
| `hftbase/CommonUtils/include/orderresponse.h` | — | `pkg/shm/types.go` | RequestMsg/ResponseMsg → Go struct |
| `hftbase/CommonUtils/include/marketupdateNew.h` | — | `pkg/shm/types.go` | MarketUpdateNew → Go struct |
| `hftbase/Connector/` | N/A | `pkg/connector/connector.go` | Connector → Connector（SHM 直连） |
| `tbsrc/Indicators/include/Indicator.h` | ~96 | `pkg/indicator/indicator.go` | Indicator → Indicator 接口 |
| `tbsrc/Indicators/include/IndicatorBasket.h` | ~50 | `pkg/indicator/basket.go` | IndicatorBasket → IndicatorBasket |
| `tbsrc/Indicators/SpreadRatio.cpp` | ~200 | `pkg/indicator/spread_ratio.go` | SpreadRatio → SpreadRatio |
| `tbsrc/Indicators/BookImbalance.cpp` | ~100 | `pkg/indicator/book_imbalance.go` | BookImbalance → BookImbalance |
| `tbsrc/Indicators/DynamicBeta.cpp` | ~150 | `pkg/indicator/dynamic_beta.go` | DynamicBeta → DynamicBeta |
| `tbsrc/main/TradeBotUtils.cpp` (GetIndicator) | ~200 | `pkg/indicator/factory.go` | 指标工厂 |
| `tbsrc/main/TradeBotUtils.cpp` (CalculateTargetPNL) | ~100 | `pkg/indicator/target_pnl.go` | 线性模型 |

---

## 4. 方法名对照表

| C++ 方法 | Go 方法 | 所属 |
|----------|---------|------|
| `CommonClient::SendINDUpdate()` | `(cc *CommonClient) SendINDUpdate()` | common/client.go |
| `CommonClient::SendInfraMDUpdate()` | `(cc *CommonClient) SendInfraMDUpdate()` | common/client.go |
| `CommonClient::SendInfraORSUpdate()` | `(cc *CommonClient) SendInfraORSUpdate()` | common/client.go |
| `CommonClient::SendNewOrder()` | `(cc *CommonClient) SendNewOrder()` | common/client.go |
| `CommonClient::SendCancelOrder()` | `(cc *CommonClient) SendCancelOrder()` | common/client.go |
| `CommonClient::HandleSignals()` | `(cc *CommonClient) HandleSignals()` | common/signals.go |
| `Connector::StartAsync()` | `(c *Connector) StartAsync()` | connector/connector.go |
| `Connector::SendNewOrder()` | `(c *Connector) SendNewOrder()` | connector/connector.go |
| `Connector::SendCancelOrder()` | `(c *Connector) SendCancelOrder()` | connector/connector.go |
| `ExecutionStrategy::MDCallBack()` | `(es *ExecutionStrategy) MDCallBack()` | strategy/ |
| `ExecutionStrategy::ORSCallBack()` | `(es *ExecutionStrategy) ORSCallBack()` | strategy/ |
| `ExecutionStrategy::SendOrder()` | 接口方法 `Strategy.SendOrder()` | strategy/ |
| `ExecutionStrategy::SetTargetValue()` | `(es *ExecutionStrategy) SetTargetValue()` | strategy/ |
| `ExecutionStrategy::SetThresholds()` | `(es *ExecutionStrategy) SetThresholds()` | strategy/ |
| `ExecutionStrategy::HandleSquareoff()` | `(es *ExecutionStrategy) HandleSquareoff()` | strategy/ |
| `ExecutionStrategy::HandleSquareON()` | `(es *ExecutionStrategy) HandleSquareON()` | strategy/ |
| `ExecutionStrategy::CalculatePNL()` | `(es *ExecutionStrategy) CalculatePNL()` | strategy/ |
| `ExecutionStrategy::ProcessTrade()` | `(es *ExecutionStrategy) ProcessTrade()` | strategy/ |
| `PairwiseArbStrategy::SendOrder()` | `(pas *PairwiseArbStrategy) SendOrder()` | strategy/ |
| `PairwiseArbStrategy::SendAggressiveOrder()` | `(pas *PairwiseArbStrategy) SendAggressiveOrder()` | strategy/ |
| `PairwiseArbStrategy::MDCallBack()` | `(pas *PairwiseArbStrategy) MDCallBack()` | strategy/ |
| `PairwiseArbStrategy::ORSCallBack()` | `(pas *PairwiseArbStrategy) ORSCallBack()` | strategy/ |
| `PairwiseArbStrategy::SetThresholds()` | `(pas *PairwiseArbStrategy) SetThresholds()` | strategy/ |
| `PairwiseArbStrategy::CalcPendingNetposAgg()` | `(pas *PairwiseArbStrategy) CalcPendingNetposAgg()` | strategy/ |

---

## 5. 回调架构

```
C++ (SHM 事件循环):                        Go (SHM 直连):
─────────────────                          ──────────────────

Connector SHM poll                         Connector SHM poll（同样方式）
  │                                          │
  ▼                                          ▼
CommonClient.SendInfraMDUpdate(update)     CommonClient.SendInfraMDUpdate(raw *shm.MarketUpdateNew)
  │                                          │
  ▼                                          ▼
CommonClient.SendINDUpdate(update)         CommonClient.SendINDUpdate(raw)
  ├→ 更新 Instrument                        ├→ 更新 Instrument
  ├→ 更新 Indicators                        ├→ 更新 Indicators
  ├→ m_INDCallBack → SetTargetValue         ├→ INDCallBack → SetTargetValue
  │    → SendOrder() [被动挂单 leg1]         │    → SendOrder() [被动挂单 leg1]
  └→ m_MDCallBack → Strategy.MDCallBack     └→ MDCallBack → Strategy.MDCallBack
       [EWMA, 风控, 时间检查]                     [EWMA, 风控, 时间检查]


Connector SHM poll (ORS)                   Connector SHM poll (ORS)（同样方式）
  │                                          │
  ▼                                          ▼
CommonClient.SendInfraORSUpdate(resp)      CommonClient.SendInfraORSUpdate(raw *shm.ResponseMsg)
  │                                          │
  ▼                                          ▼
m_ORSCallBack → Strategy.ORSCallBack       ORSCallBack → Strategy.ORSCallBack
  ├→ 更新持仓/订单状态                       ├→ 更新持仓/订单状态
  └→ SendAggressiveOrder() [直接发单]         └→ SendAggressiveOrder() [直接发单]
       via Connector.SendNewOrder() → SHM        via Connector.SendNewOrder() → SHM
```

Go 中不需要 Signal/GetSignals 机制。发单链路与 C++ 一致：
```
ExecutionStrategy.SendNewOrder() → CommonClient.SendNewOrder() → Connector.SendNewOrder() → SHM Push(RequestMsg)
```

---

## 6. Phase 1：SHM 包 + Connector

### 6.1 依赖

```
gopkg.in/yaml.v3
# SysV SHM 用 syscall 包，不需要 golang.org/x/sys
```

### 6.2 SysV SHM 封装

```go
// pkg/shm/sysv.go
func ShmOpen(key int, size int) (uintptr, error)   // 打开已存在的 SHM
func ShmCreate(key int, size int) (uintptr, error)  // 创建新 SHM（ORS 端用）
func ShmDetach(addr uintptr) error                  // 断开映射
```

### 6.3 MWMR Queue

```go
// pkg/shm/mwmr_queue.go
type MWMRHeader struct {
    Head int64  // atomic, 初始值 1
}

// QueueElem: data 在前、seqNo 在后
// tail 在进程本地内存，不在 SHM 中
type MWMRQueue[T any] struct {
    base      uintptr
    elemSize  uintptr   // sizeof(T) + 8 (seqNo)
    size      int64     // 2 的幂
    mask      int64     // size - 1
    localTail int64     // 初始值 = head（追最新）或 1（从头读）
}
```

完整技术规格见 `docs/系统分析/hftbase_MWMR_Go复刻技术规格_2026-02-13-16_00.md`。

### 6.4 消息结构体

| 结构体 | 来源 | 备注 |
|--------|------|------|
| `MarketUpdateNew`（~900+ bytes） | `hftbase/CommonUtils/include/marketupdateNew.h` | 含 `bookElement_t[20] × 2` |
| `RequestMsg`（aligned(64)） | `hftbase/CommonUtils/include/orderresponse.h` | `Transaction_Type` 为 `'B'`/`'S'` |
| `ResponseMsg` | `hftbase/CommonUtils/include/orderresponse.h` | `ResponseType` 19 种枚举 |

关键字段：

```
RequestMsg:
  - 方向:   Transaction_Type (char 'B'/'S')
  - 开平:   PosDirection (enum OPEN=10, CLOSE=11, CLOSE_INTRADAY=12)
  - OrderID: uint32 (clientId*1000000+seq)
  - 符号:   ContractDescription 嵌套结构体（Symbol[50]）
  - 策略:   int StrategyID

ResponseMsg:
  - 类型:   ResponseType enum (NEW_ORDER_CONFIRM=0, TRADE_CONFIRM=4, ORDER_ERROR=5, ...)
  - OpenClose: unsigned char (OPEN=1, CLOSE=2, CLOSE_TODAY=3)
  - ExchangeID: unsigned char (SHFE=1, INE=2, ...)
  - 符号:   Symbol[50]
```

`SendInfraMDUpdate` 中 Instrument 字段映射：

| 字段 | MarketUpdateNew |
|------|-----------------|
| 符号 | `raw.Symbol[:48]`（`m_symbol[48]`） |
| 买价 | `raw.BidUpdates[0].Price` |
| 买量 | `raw.BidUpdates[0].Quantity` |
| 卖价 | `raw.AskUpdates[0].Price` |
| 卖量 | `raw.AskUpdates[0].Quantity` |
| 最新价 | `raw.LastTradedPrice` |
| 最新量 | `raw.LastTradedQuantity` |
| 成交量 | `raw.TotalTradedQuantity` |
| 交易所 | `raw.ExchangeName`（byte: CHINA_SHFE=57） |

### 6.5 Offset Check

```
C++ offset_check:
  #include "orderresponse.h"
  #include "marketupdateNew.h"
  #include "multiwritermultireadershmqueue.h"
  编译环境: hftbase include 路径

Go offset_check:
  import "tbsrc-golang/pkg/shm"
```

**⚠️ 必须通过后才进入 MWMR Queue 实现。** `RequestMsg` 有 `__attribute__((aligned(64)))`，Go 需手动补 padding。

### 6.6 Connector

```go
// pkg/connector/connector.go
type Connector struct {
    mdQueue   *shm.MWMRQueue[shm.MarketUpdateNew]
    reqQueue  *shm.MWMRQueue[shm.RequestMsg]
    respQueue *shm.MWMRQueue[shm.ResponseMsg]

    clientStore *shm.ClientStore   // C++: LocklessShmClientStore
    clientID    int32              // C++: m_clientId[exchCode]
    orderCount  uint32             // C++: m_OrderCount

    mdCallback  MDCallback         // func(raw *shm.MarketUpdateNew)
    orsCallback ORSCallback        // func(raw *shm.ResponseMsg)
    running     atomic.Bool
}

// OrderID 生成（与 hftbase 一致）
const OrderIDRange = 1_000_000

func (c *Connector) GetUniqueOrderNumber() uint32 {
    c.orderCount++
    return uint32(c.clientID)*uint32(OrderIDRange) + c.orderCount
}

// 发单
func (c *Connector) SendNewOrder(req *shm.RequestMsg) uint32 {
    req.OrderID = c.GetUniqueOrderNumber()
    req.RequestType = shm.NEWORDER
    c.reqQueue.Enqueue(req)
    return req.OrderID
}

// 回报过滤
func (c *Connector) isMyOrder(resp *shm.ResponseMsg) bool {
    return int32(resp.OrderID/uint32(OrderIDRange)) == c.clientID
}
```

### 6.7 配置

ORS 使用 `.cfg` 格式（key=value），Go trader YAML 配置需与之对应：

```yaml
# config/trader.tbsrc.yaml
shm:
  request_key: 3872      # 必须与 ORS REQUEST_SHMKEY 一致
  request_size: 4096
  response_key: 4872
  response_size: 4096
  md_key: 872
  md_size: 4096
  client_store_key: 5872
```

### 6.8 Phase 1 步骤

```
Phase 1.1: 项目骨架
  ├─ mkdir + go mod init
  └─ 依赖: gopkg.in/yaml.v3

Phase 1.2: SysV SHM 封装
  ├─ pkg/shm/sysv.go         — ShmOpen/ShmCreate/ShmDetach
  ├─ pkg/shm/sysv_linux.go   — Linux 常量
  └─ pkg/shm/sysv_darwin.go  — macOS 常量

Phase 1.3: 消息结构体
  ├─ pkg/shm/types.go        — RequestMsg/ResponseMsg/MarketUpdateNew
  └─ pkg/shm/constants.go    — ORDERID_RANGE、ExchangeType、ResponseType 等

Phase 1.4: Offset Check 验证
  ├─ tools/offset_check.cpp  — C++ 版（引用 hftbase 头文件）
  ├─ cmd/offset_check/main.go — Go 版
  └─ ⚠️ 必须通过后才进入下一步

Phase 1.5: MWMR Queue 实现
  ├─ pkg/shm/mwmr_queue.go   — MWMRQueue[T] 泛型
  ├─ pkg/shm/client_store.go  — ClientStore
  └─ pkg/shm/queue_test.go    — Go 进程间测试

Phase 1.6: Connector
  ├─ pkg/connector/connector.go — SysV MWMR 版 Connector
  ├─ OrderID 生成: clientId × 1000000 + seq
  ├─ 回报过滤: OrderID / ORDERID_RANGE
  └─ 轮询: md + response 双线程

Phase 1.7: 配置
  ├─ pkg/config/ors_config.go  — SHM key 配置
  └─ config/trader.tbsrc.yaml  — 初始配置模板

Phase 1 验证标准:
  ✅ Offset Check C++ vs Go 完全一致
  ✅ Go 进程写 RequestMsg → 另一个 Go 进程通过 MWMR 读出正确
  ✅ Go 进程间 ClientStore 原子分配 clientId 正确
  ✅ （可选）Go 写 RequestMsg → C++ 读出正确（需 hftbase 编译环境）
```

---

## 7. Phase 2：CommonClient + ExecutionStrategy 基类

### 7.1 CommonClient

C++ 源: `tbsrc/main/CommonClient.cpp`（1,136 行）+ `CommonClient.h`

```go
// pkg/common/client.go

type MDCallback  func(raw *shm.MarketUpdateNew)
type ORSCallback func(raw *shm.ResponseMsg)
type INDCallback func(symbol string)

type CommonClient struct {
    // C++: Connector *m_connector
    Connector *connector.Connector

    // C++: MDcb m_MDCallBack, ORScb m_ORSCallBack, INDcb m_INDCallBack
    mdCallBack  MDCallback
    orsCallBack ORSCallback
    indCallBack INDCallback

    // C++: SimConfig *m_simConfig
    SimConfig    *config.SimConfig
    ConfigParams *config.ConfigParams

    // C++: bool m_isActive
    IsActive bool

    // Phase 5 新增
    IndicatorList []indicator.Indicator
}

// C++: CommonClient::Initialize(MDcb, ORScb, INDcb, ...)
func (cc *CommonClient) Initialize(mdcb MDCallback, orscb ORSCallback, indcb INDCallback, ...) {
    cc.mdCallBack = mdcb
    cc.orsCallBack = orscb
    cc.indCallBack = indcb
    cc.IsActive = true
    cc.Connector.SetMDCallback(func(raw *shm.MarketUpdateNew) { cc.SendInfraMDUpdate(raw) })
    cc.Connector.SetORSCallback(func(raw *shm.ResponseMsg) { cc.SendInfraORSUpdate(raw) })
}

// C++: CommonClient::SendInfraMDUpdate(MarketUpdateNew *update)
func (cc *CommonClient) SendInfraMDUpdate(raw *shm.MarketUpdateNew) {
    cc.SendINDUpdate(raw)
}

// C++: CommonClient::SendINDUpdate(MarketUpdateNew *update) — 370 行核心分发
func (cc *CommonClient) SendINDUpdate(raw *shm.MarketUpdateNew) {
    symbol := shm.CStr(raw.Symbol[:])
    // 1. 更新 Instrument（bid/ask/last price）— 从 MarketUpdateNew 字段拷贝
    // 2. 更新 Indicators（Phase 5）
    for _, ind := range cc.IndicatorList {
        ind.QuoteUpdate(instru)
    }
    // 3. 调用 indCallBack → SetTargetValue → SendOrder（被动挂单）
    cc.indCallBack(symbol)
    // 4. 调用 mdCallBack → Strategy.MDCallBack（EWMA、风控）
    cc.mdCallBack(raw)
}

// C++: CommonClient::SendInfraORSUpdate(ResponseMsg *response)
func (cc *CommonClient) SendInfraORSUpdate(raw *shm.ResponseMsg) {
    cc.orsCallBack(raw)
}

// C++: CommonClient::SendNewOrder(...) → m_connector->SendNewOrder()
func (cc *CommonClient) SendNewOrder(req *shm.RequestMsg) bool {
    return cc.Connector.SendNewOrder(req)
}

// C++: CommonClient::SendCancelOrder(...)
func (cc *CommonClient) SendCancelOrder(req *shm.RequestMsg) bool {
    return cc.Connector.SendCancelOrder(req)
}
```

### 7.2 信号处理

```go
// pkg/common/signals.go
// C++: CommonClient::HandleSignals(SquareOff sqoff)
// C++: SIGTSTP=全部平仓, SIGUSR1=重新激活, SIGUSR2=重载阈值
func (cc *CommonClient) HandleSignals(sqoff func(sig os.Signal)) {
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, syscall.SIGTSTP, syscall.SIGUSR1, syscall.SIGUSR2, syscall.SIGTERM)
    for sig := range sigChan {
        sqoff(sig)
    }
}
```

### 7.3 Strategy 接口 + ExecutionStrategy 基类

C++ 源: `ExecutionStrategy.h`（579 行）+ `ExecutionStrategy.cpp`（2,506 行）

```go
// pkg/strategy/execution_strategy.go

// Strategy 接口 — 对标 C++ 虚函数
type Strategy interface {
    MDCallBack(raw *shm.MarketUpdateNew)
    ORSCallBack(raw *shm.ResponseMsg)
    SendOrder()                           // C++: pure virtual
    SetTargetValue(currPrice, targetPrice float64, targetBidPNL, targetAskPNL float64)
    SetThresholds()
    HandleSquareoff()
    HandleSquareON()
    CheckSquareoff()
}

type ExecutionStrategy struct {
    // C++: CommonClient *m_client
    Client *common.CommonClient

    // C++: int32_t m_strategyID
    StrategyID int32

    // C++: Instrument *m_instru
    Instru *Instrument

    // 持仓 — C++: int m_netpos, m_netpos_pass, m_netpos_pass_ytd, m_netpos_agg
    NetPos        int32
    NetPosPass    int32
    NetPosPassYtd int32
    NetPosAgg     int32

    // PNL — C++: double m_realisedPNL, m_unrealisedPNL, m_netPNL
    RealPNL   float64
    UnrealPNL float64
    NetPNL    float64
    GrossPNL  float64
    MaxPNL    float64
    Drawdown  float64

    // 状态 — C++: bool m_onFlat, m_Active, m_onExit, callSquareOff
    OnFlat        bool
    Active        bool
    OnExit        bool
    CallSquareOff bool
    AggFlat       bool

    // 订单 — C++: OrderMap m_ordMap, m_bidMap, m_askMap
    OrdMap *OrderMap
    BidMap *PriceOrderMap
    AskMap *PriceOrderMap

    // 阈值
    Thold *ThresholdSet

    // 计数器
    TradeCount  int32
    OrderCount  int32
    CancelCount int32
    RejectCount int32

    // 子类 SendOrder 委托
    sendOrderFunc func()

    // ... 其余 C++ 字段按需翻译
}

// 核心方法（逐行翻译 C++）
func (es *ExecutionStrategy) CalculatePNL() { ... }
func (es *ExecutionStrategy) ProcessTrade(raw *shm.ResponseMsg) { ... }
func (es *ExecutionStrategy) ProcessCancelConfirm(raw *shm.ResponseMsg) { ... }
func (es *ExecutionStrategy) SendNewOrder(side byte, price float64, qty int32, posDir int32) uint32 {
    var req shm.RequestMsg
    req.ContractDesc.SetSymbol(es.Instru.Symbol)
    req.TransactionType = side   // 'B' 或 'S'
    req.Price = price
    req.Quantity = qty
    req.OrdType = shm.LIMIT
    req.Duration = shm.IOC
    req.PosDirection = posDir     // OPEN=10, CLOSE=11, CLOSE_INTRADAY=12
    req.ExchangeType = es.Instru.ExchangeCode
    req.StrategyID = es.StrategyID
    return es.Client.Connector.SendNewOrder(&req)
}
func (es *ExecutionStrategy) SendCancelOrder(orderID uint32) bool { ... }
func (es *ExecutionStrategy) GetBidPrice(price float64, level int) float64 { ... }
func (es *ExecutionStrategy) GetAskPrice(price float64, level int) float64 { ... }
func (es *ExecutionStrategy) SetThresholds() { ... }
func (es *ExecutionStrategy) SetLinearThresholds() { ... }
func (es *ExecutionStrategy) SetTargetValue(currPrice, targetPrice float64, bidPNL, askPNL float64) {
    if !es.OnFlat && es.Active {
        es.sendOrderFunc()  // 调用子类的 SendOrder()
    }
}
```

### 7.4 辅助类型

按 C++ 结构体逐字段翻译：
- `ExtraStrategy` — 多腿辅助（`tbsrc/Strategies/include/ExtraStrategy.h/.cpp`）
- `ThresholdSet` — 阈值集（`tbsrc/main/include/TradeBotUtils.h`）
- `Instrument` — 合约数据模型（`tbsrc/common/Instrument.h/.cpp`）
- `OrderMap` / `PriceOrderMap` — 订单管理（`tbsrc/Strategies/include/ExecutionStrategyStructs.h`）
- `types.go` — 枚举常量（TransactionType、OrderHitType 等）

### 7.5 验证

```bash
go build ./pkg/strategy/...
go build ./pkg/common/...
go test ./pkg/strategy/... -v
```

---

## 8. Phase 3：PairwiseArbStrategy 翻译

C++ 源: `tbsrc/Strategies/PairwiseArbStrategy.cpp`（947 行）

### 8.1 结构体

```go
// pkg/strategy/pairwise_arb.go
type PairwiseArbStrategy struct {
    *ExecutionStrategy
    FirstStrat  *ExtraStrategy  // leg1 被动
    SecondStrat *ExtraStrategy  // leg2 主动
    AvgSpreadRatioOri float64   // C++: avgSpreadRatio_ori
    AvgSpreadRatio    float64   // C++: avgSpreadRatio
    CurrSpreadRatio   float64   // C++: currSpreadRatio
    TValue            float64   // C++: tValue
    TholdFirst  *ThresholdSet
    TholdSecond *ThresholdSet
    AggRepeat   int32           // C++: m_agg_repeat
    MaxLossLimit float64        // C++: m_maxloss_limit
    OrdMap1 *OrderMap           // leg1 被动单
    OrdMap2 *OrderMap           // leg2 主动单

    // 动态阈值（由 SetThresholds 计算）
    tholdBidPlace  float64
    tholdAskPlace  float64
    tholdBidRemove float64
    tholdAskRemove float64
}
```

### 8.2 核心方法

| 方法 | 说明 | C++ 源码行 |
|------|------|-----------|
| `MDCallBack(raw *shm.MarketUpdateNew)` | EWMA 更新、价差异常检查、风控 | PairwiseArbStrategy.cpp:341-427 |
| `SendOrder()` | 被动 leg1 挂单逻辑 | PairwiseArbStrategy.cpp:173-340 |
| `ORSCallBack(raw *shm.ResponseMsg)` | 成交/撤单/拒单处理，触发对冲 | PairwiseArbStrategy.cpp:428-540 |
| `SendAggressiveOrder()` | 主动 leg2 追单（1-3 次） | PairwiseArbStrategy.cpp:541-650 |
| `SetThresholds()` | 动态阈值线性插值计算 | PairwiseArbStrategy.cpp:651-687 |
| `CalcPendingNetposAgg()` | 计算未成交主动单净仓 | PairwiseArbStrategy.cpp:688-699 |
| `LoadMatrix2() / SaveMatrix2()` | daily_init 文件读写 | PairwiseArbStrategy.cpp:30-62, 653-686 |

回报处理（ORSCallBack）使用 `ResponseMsg` 的 `ResponseType` 枚举：

```go
func (pas *PairwiseArbStrategy) ORSCallBack(resp *shm.ResponseMsg) {
    switch resp.ResponseType {
    case shm.NEW_ORDER_CONFIRM:    // 0
    case shm.TRADE_CONFIRM:        // 4 — 成交，更新持仓，触发对冲
        pas.ProcessTrade(resp)
    case shm.ORDER_ERROR:          // 5
    case shm.CANCEL_ORDER_CONFIRM: // 3
    case shm.ORS_REJECT:           // 8
    case shm.RMS_REJECT:           // 9
    }
}
```

### 8.3 验证

```bash
go build ./pkg/strategy/...
go test ./pkg/strategy/... -v
```

---

## 9. Phase 4：main.go + 配置 + 端到端

### 9.1 main.go

C++ 源: `tbsrc/main/main.cpp`（1,103 行）

```go
// cmd/trader/main.go
func main() {
    // 1. 加载配置（C++: LoadControlFile + LoadModelFile）
    cfg := config.LoadConfig(os.Args)

    // 2. 创建 Connector（SysV MWMR SHM 直连）
    conn := connector.NewConnector(cfg.SHM)

    // 3. 创建 CommonClient
    client := common.NewCommonClient(conn, cfg)

    // 4. 策略工厂（C++: if-else chain on m_execStrat）
    var strat strategy.Strategy
    switch cfg.StrategyType {
    case "TB_PAIR_STRAT":
        strat = strategy.NewPairwiseArbStrategy(client, cfg)
    }

    // 5. 注册回调
    client.Initialize(
        func(raw *shm.MarketUpdateNew) { strat.MDCallBack(raw) },
        func(raw *shm.ResponseMsg) { strat.ORSCallBack(raw) },
        func(symbol string) { /* SetTargetValue → SendOrder */ },
    )

    // 6. 启动 SHM 轮询
    conn.StartAsync()

    // 7. 信号处理
    client.HandleSignals(func(sig os.Signal) {
        switch sig {
        case syscall.SIGTSTP, syscall.SIGTERM:
            strat.HandleSquareoff()
        case syscall.SIGUSR1:
            strat.HandleSquareON()
        case syscall.SIGUSR2:
            config.ReloadThresholds(cfg, strat)
        }
    })
}
```

### 9.2 配置参数映射

| 配置字段 | C++ 原名 | 说明 |
|----------|----------|------|
| `shm.request_key` | REQUEST_SHMKEY | SysV SHM 请求队列 key |
| `shm.response_key` | RESPONSE_SHMKEY | SysV SHM 回报队列 key |
| `shm.md_key` | MD_SHMKEY | SysV SHM 行情队列 key |
| `begin_place` | BEGIN_PLACE | 开始挂单阈值 |
| `long_place` | LONG_PLACE | 做多挂单阈值 |
| `short_place` | SHORT_PLACE | 做空挂单阈值 |
| `begin_remove` | BEGIN_REMOVE | 开始撤单阈值 |
| `long_remove` | LONG_REMOVE | 做多撤单阈值 |
| `short_remove` | SHORT_REMOVE | 做空撤单阈值 |
| `alpha` | ALPHA | EWMA 衰减因子 |
| `avg_spread_away` | AVG_SPREAD_AWAY | 价差异常保护 |
| `max_quote_level` | MAX_QUOTE_LEVEL | 最大挂单层数 |
| `supporting_orders` | SUPPORTING_ORDERS | 每方向最大挂单数 |
| `size` | SIZE | 每单数量 |
| `max_size` | MAXSIZE | 最大持仓 |
| `slop` | SLOP | 第3次追单跳价 |

### 9.3 端到端测试

```
测试链路:
  方案 A（Go mock）: go_md_feeder → [SysV MWMR SHM] → go_trader → [SysV MWMR SHM] → go_mock_ors
  方案 B（C++ ORS）: ctp_md_handler → [SysV MWMR SHM] → go_trader → [SysV MWMR SHM] → ORS(China) → CTP
```

Phase 4 初期用方案 A（纯 Go 环境），避免依赖 C++ 编译。验证通过后切换方案 B。

**验证检查清单**：
- ✅ SHM 行情读取正常（无丢包）
- ✅ EWMA avgSpreadRatio 更新正确
- ✅ leg1 被动挂单在正确价差触发
- ✅ leg2 主动对冲在 ORSCallBack 后立即发出（不延迟）
- ✅ 撤单功能（CROSS 清理 + 价差偏离撤单 + 撤远挂近）
- ✅ 动态阈值线性插值正确
- ✅ daily_init 文件兼容
- ✅ SIGTSTP 平仓 / SIGUSR1 激活 / SIGUSR2 重载

### 9.4 CentOS 部署

```bash
# macOS 交叉编译
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o bin/trader_v2_linux cmd/trader/main.go

# 部署到 CentOS 服务器
scp bin/trader_v2_linux user@centos-server:/opt/quantlink/bin/trader_v2

# 远程验证
ssh user@centos-server
./bin/trader_v2 -config config/trader.live.yaml
```

### 9.5 REST API / 监控（后续）

端到端验证通过后，添加 REST API（port 9201）和 WebSocket dashboard。可引入 NATS 作为可选的监控数据分发通道（不在交易关键路径上）。

---

## 10. Phase 5：Indicator 框架翻译

背景：C++ `tbsrc/Indicators/` 下有 100+ 个指标类，通过 `CalculateTargetPNL()` 线性模型为非套利策略提供 targetPrice。PairwiseArbStrategy 不依赖此框架（它自己算 EWMA spread），但其他策略类型需要。

### 10.1 Indicator 基类接口

C++ 源: `tbsrc/Indicators/include/Indicator.h`

```go
// pkg/indicator/indicator.go

type Indicator interface {
    QuoteUpdate(instru *strategy.Instrument)  // C++: virtual void QuoteUpdate(Tick *t)
    TickUpdate(instru *strategy.Instrument)   // C++: virtual void TickUpdate(Tick *t)
    Reset()                                   // C++: virtual void Reset()
    Value() (float64, bool)                   // C++: virtual double Value(bool &status)
    Description() string
}

// BaseIndicator 提供共用字段（C++: Indicator 成员变量）
type BaseIndicator struct {
    Val       float64  // C++: double value
    LastVal   float64  // C++: double last_value
    DiffVal   float64  // C++: double diff_value
    IsValid   bool     // C++: bool isValid
    IsDep     bool     // C++: bool isDep
    Desc      string   // C++: string description
    Instru    *strategy.Instrument
    Coeff     float64  // C++: double m_coefficient（模型系数）
}
```

### 10.2 IndicatorBasket

C++ 源: `tbsrc/Indicators/include/IndicatorBasket.h`

```go
// pkg/indicator/basket.go
type IndicatorBasket struct {
    BaseIndicator
    Indicators []Indicator
    Weights    []float64
}
```

### 10.3 优先翻译指标

| 优先级 | C++ 指标 | Go 文件 | 说明 |
|--------|----------|---------|------|
| P0 | SpreadRatio | spread_ratio.go | 价差比率（EWA/SMA 模式） |
| P0 | BookImbalance | book_imbalance.go | 订单簿买卖失衡 |
| P0 | BookDelta | book_delta.go | 订单簿深度变化 |
| P0 | DynamicBeta | dynamic_beta.go | 动态 Beta 系数 |
| P1 | VWAP | vwap.go | 成交量加权均价 |
| P1 | PxMomentum | momentum.go | 价格动量 |
| P1 | Bollinger | bollinger.go | 布林带 |
| P1 | TradeVolume | trade_volume.go | 成交量统计 |
| P1 | AvgTradeSize | trade_volume.go | 平均成交量 |
| P1 | OrderBookSkew | book_imbalance.go | 订单簿偏斜 |
| P2 | StaticBeta | static_beta.go | 静态 Beta |
| P2 | ForceIndex | trade_volume.go | 成交力度 |
| P2 | CMF | trade_volume.go | Chaikin 资金流 |
| P2 | Simple_Trend | momentum.go | 趋势检测 |
| P2 | ExpMomentum | momentum.go | 指数动量 |

### 10.4 CalculateTargetPNL（线性模型）

C++ 源: `tbsrc/main/TradeBotUtils.cpp:3788+`

```go
// pkg/indicator/target_pnl.go
func CalculateTargetPNL(indicators []Indicator) (targetPrice, targetBidPNL, targetAskPNL float64) {
    for _, ind := range indicators {
        val, valid := ind.Value()
        if !valid { continue }
        targetPrice += val * ind.(*BaseIndicator).Coeff
    }
    // ... bidPNL/askPNL 计算
    return
}
```

### 10.5 指标工厂

C++ 源: `tbsrc/main/TradeBotUtils.cpp:504+`

```go
// pkg/indicator/factory.go
func GetIndicator(name string, instru *strategy.Instrument, params map[string]interface{}) (Indicator, error) {
    switch name {
    case "SpreadRatio":   return NewSpreadRatio(instru, params), nil
    case "BookImbalance": return NewBookImbalance(instru, params), nil
    case "DynamicBeta":   return NewDynamicBeta(instru, params), nil
    // ...
    default:              return nil, fmt.Errorf("unknown indicator: %s", name)
    }
}
```

### 10.6 验证

```bash
go build ./pkg/indicator/...
go test ./pkg/indicator/... -v

# 单指标验证：用 C++ 输出的指标值序列对比 Go 计算结果
go test -run TestSpreadRatio_MatchCpp ./pkg/indicator/... -v
```

---

## 11. 风险和待确认事项

### 11.1 行情 feeder 兼容性

当前开发环境使用新 gateway 的 `md_simulator`（写 `MarketDataRaw` 到 POSIX SPSC SHM），与 hftbase 的 `MarketUpdateNew` + SysV MWMR 不兼容。

**解决方案**：
- 开发阶段：写一个 Go mock MD feeder，直接往 SysV MWMR 写 `MarketUpdateNew`
- 生产环境：使用 ORS 自带的 `MDHandler`（已验证格式兼容）

### 11.2 ORS 部署环境

Go trader 需要与 ORS 运行在同一台机器上（SysV SHM 是本地 IPC）。这与 C++ 部署方式一致，但与 `golang/` 旧代码的网络分布式架构不同。

### 11.3 struct padding 精确验证

`RequestMsg` 有 `__attribute__((aligned(64)))` 属性，Go 没有等价机制。需要在 struct 末尾手动补 padding 使 `unsafe.Sizeof` 匹配 C++ 的 `sizeof`。**必须通过 offset_check 验证后才能进入 Phase 1.5。**

### 11.4 MarketUpdateNew 大小

`MarketUpdateNew` 继承 `MDHeaderPart` + `MDDataPart`，包含 `bookElement_t[20] × 2`（640 bytes 仅订单簿），整体 ~900+ bytes。加上 QueueElem 的 8 bytes seqNo，单个 slot 接近 1KB。MWMR 队列 4096 个 slot 约需 ~4MB SHM。

---

## 12. 不需要的依赖

改造后以下依赖可从交易关键路径中移除（REST API 阶段可选恢复）：

| 移除项 | 原因 |
|--------|------|
| protobuf | SHM 直连不需要序列化 |
| NATS | Go trader 直接读 SHM 行情 |
| gRPC | Go trader 直接写 SHM 订单 |
| md_gateway 进程 | Go trader 直接读 SHM |
| ors_gateway 进程 | Go trader 直接写 SHM |

保留 `golang/` 旧代码不动，验证完成后再删除。`daily_init.*` 文件格式保持兼容。

---

## 参考资料

- MWMR 技术规格: `docs/系统分析/hftbase_MWMR_Go复刻技术规格_2026-02-13-16_00.md`
- counter_bridge 改造: `docs/系统分析/counter_bridge_MWMR改造方案_2026-02-13-19_00.md`
- hftbase MWMR: `hftbase/Ipc/include/multiwritermultireadershmqueue.h`
- hftbase 消息: `hftbase/CommonUtils/include/orderresponse.h`
- hftbase 行情: `hftbase/CommonUtils/include/marketupdateNew.h`
- ORS 实现: `ors/Shengli/` + `ors/China/`
- C++ 策略: `tbsrc/Strategies/PairwiseArbStrategy.cpp`
- C++ 基类: `tbsrc/Strategies/ExecutionStrategy.cpp`
- C++ 主程序: `tbsrc/main/main.cpp`
- C++ 指标: `tbsrc/Indicators/`

---

**最后更新**: 2026-02-13（v3.0: 合并原计划 Phase 2-5 内容，移除对 tmp 文件的依赖）
