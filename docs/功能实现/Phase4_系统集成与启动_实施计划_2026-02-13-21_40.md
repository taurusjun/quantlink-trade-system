# Phase 4 实施计划：系统集成与启动

**文档日期**: 2026-02-13
**版本**: v1.0
**相关模块**: tbsrc-golang 全部模块

---

## 背景

Phase 1-3 已完成核心交易逻辑：
- Phase 1: SHM 通信层（pkg/shm/, pkg/connector/, pkg/config/）
- Phase 2: CommonClient + ExecutionStrategy 基础框架（pkg/types/, pkg/instrument/, pkg/client/, pkg/execution/）
- Phase 3: PairwiseArbStrategy 配对套利策略（pkg/strategy/）

130 个测试全部通过，交叉编译验证通过。

Phase 4 构建**"最后一公里"集成层**，使系统可以从命令行启动并运行完整的交易流程。

---

## 缺失组件分析

| # | 缺失项 | 优先级 | 说明 |
|---|--------|--------|------|
| 1 | `cmd/trader/main.go` | 关键 | 入口程序，CLI 参数、配置加载、组件装配、信号处理 |
| 2 | ThresholdSet 从配置加载 | 关键 | `map[string]float64` → `ThresholdSet` 字段映射 |
| 3 | Instrument 工厂方法 | 关键 | 从 `InstrumentConfig` 创建 `Instrument` |
| 4 | Config → Connector 装配 | 关键 | `ORSConfig` → `connector.Config` 映射 |
| 5 | 信号处理 + 优雅关闭 | 关键 | SIGINT/SIGTERM 处理，撤单，保存状态 |
| 6 | tvar SHM 接口 | 重要 | `hftlib::tvar<double>` 等价实现 |
| 7 | tValue 集成到 MDCallBack | 重要 | 每个行情更新时读取 tVar |
| 8 | daily_init 文件读写 | 重要 | 初始化和持久化 EWA + 持仓 |
| 9 | 交易所费率装配 | 重要 | 从配置调用 `LegManager.SetExchangeCosts()` |

---

## 文件清单（7 个新文件 + 3 个修改文件）

```
quantlink-trade-system/tbsrc-golang/
├── cmd/trader/
│   └── main.go                    # 新：入口程序
├── pkg/types/
│   └── threshold_set.go           # 修改：添加 LoadFromMap()
├── pkg/instrument/
│   └── instrument.go              # 修改：添加 NewFromConfig()
├── pkg/shm/
│   └── tvar.go                    # 新：tvar SHM 接口
├── pkg/config/
│   ├── config.go                  # 修改：完善 Config 结构
│   └── daily_init.go              # 新：daily_init 文件读写
├── pkg/strategy/
│   └── pairwise_callbacks.go      # 修改：集成 tValue 读取
└── config/
    └── trader.tbsrc.yaml          # 已存在，验证完整性
```

---

## 实施顺序（5 步）

```
步骤 1: ThresholdSet.LoadFromMap + Instrument.NewFromConfig  ← 无依赖
   ↓
步骤 2: tvar SHM 接口 + daily_init 读写                      ← 依赖 Step 1
   ↓
步骤 3: cmd/trader/main.go 组件装配                           ← 依赖 Step 1, 2
   ↓
步骤 4: 信号处理 + 优雅关闭 + tValue 集成                    ← 依赖 Step 3
   ↓
步骤 5: 集成测试 + 交叉编译验证                              ← 依赖 Step 4
```

---

## 各步骤详细说明

### 步骤 1：ThresholdSet.LoadFromMap + Instrument.NewFromConfig

**ThresholdSet.LoadFromMap** — 从 `map[string]float64` 填充字段：

```go
func (ts *ThresholdSet) LoadFromMap(m map[string]float64) {
    if v, ok := m["begin_place"]; ok { ts.BeginPlace = v }
    if v, ok := m["begin_remove"]; ok { ts.BeginRemove = v }
    // ... 所有 130+ 字段
}
```

字段名映射规则：YAML `snake_case` → Go `CamelCase`

**Instrument.NewFromConfig** — 从配置创建合约：

```go
func NewFromConfig(symbol string, cfg config.InstrumentConfig) *Instrument {
    return &Instrument{
        Symbol:          symbol,
        Exchange:        cfg.Exchange,
        TickSize:        cfg.TickSize,
        LotSize:         cfg.LotSize,
        ContractFactor:  cfg.ContractFactor,
        PriceMultiplier: cfg.PriceMultiplier,
        PriceFactor:     cfg.PriceFactor,
        SendInLots:      cfg.SendInLots,
        Token:           cfg.Token,
        ExpiryDate:      cfg.ExpiryDate,
    }
}
```

### 步骤 2：tvar SHM 接口 + daily_init 读写

**pkg/shm/tvar.go** — 对应 `hftlib::tvar<double>`：

```go
type TVar struct {
    ptr  *float64  // SHM 映射后的指针
    shmID int      // SysV SHM ID
}

func OpenTVar(key int32, flags int) (*TVar, error)
func (tv *TVar) Load() float64   // atomic read
func (tv *TVar) Store(v float64) // atomic write
func (tv *TVar) Close() error    // detach
```

实现：`shmget(key, 8, flags)` + `shmat` + `sync/atomic` 读写

**pkg/config/daily_init.go** — daily_init 文件格式：

C++ 格式：每行一个值，顺序固定
```
avgSpreadRatio_ori
netpos_ytd1
netpos_2day1
netpos_agg2
```

```go
func LoadDailyInit(strategyID int32) (*DailyInit, error)
func (d *DailyInit) Save(strategyID int32) error
```

### 步骤 3：cmd/trader/main.go

主程序骨架：

```go
func main() {
    // 1. CLI 参数
    configPath := flag.String("config", "config/trader.tbsrc.yaml", "config file")
    flag.Parse()

    // 2. 加载配置
    cfg := config.Load(*configPath)

    // 3. 创建 Connector
    conn := connector.New(connCfg, mdCallback, orsCallback)

    // 4. 创建 Client
    client := client.NewClient(conn, cfg.Strategy.StrategyID, ...)

    // 5. 创建 Instruments
    inst1 := instrument.NewFromConfig(symbols[0], cfg.Strategy.Instruments[symbols[0]])
    inst2 := instrument.NewFromConfig(symbols[1], cfg.Strategy.Instruments[symbols[1]])

    // 6. 创建 ThresholdSets
    thold1 := types.NewThresholdSet(); thold1.LoadFromMap(cfg.Strategy.Thresholds["first"])
    thold2 := types.NewThresholdSet(); thold2.LoadFromMap(cfg.Strategy.Thresholds["second"])

    // 7. 创建 PairwiseArbStrategy
    pas := strategy.NewPairwiseArbStrategy(client, inst1, inst2, thold1, thold2, ...)

    // 8. 设置交易所费率
    pas.Leg1.SetExchangeCosts(...)
    pas.Leg2.SetExchangeCosts(...)

    // 9. 注册策略
    client.RegisterStrategy(symbols[0], pas)
    client.RegisterStrategy(symbols[1], pas)

    // 10. 加载 daily_init
    daily := config.LoadDailyInit(strategyID)
    pas.Init(daily.AvgSpreadOri, daily.NetposYtd1, daily.Netpos2day1, daily.NetposAgg2)

    // 11. 打开 tvar SHM
    if thold1.TVarKey > 0 { tvar = shm.OpenTVar(thold1.TVarKey, 0666) }

    // 12. 启动
    conn.Start()
    pas.SetActive(true)

    // 13. 等待信号
    waitForSignal()

    // 14. 优雅关闭
    pas.HandleSquareoff()
    conn.Stop()
    daily.Save(strategyID)
}
```

### 步骤 4：信号处理 + tValue 集成

**信号处理**：
```go
sigCh := make(chan os.Signal, 1)
signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
<-sigCh
```

**tValue 集成**：在 `MDCallBack` 中添加 tvar 读取：
```go
if pas.TVar != nil {
    pas.Spread.SetTValue(pas.TVar.Load())
}
```

### 步骤 5：集成测试

- 编译验证：`go build ./cmd/trader/`
- 交叉编译：`CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build ./...`
- 单元测试：`go test ./pkg/...`
- 配置加载测试：验证完整 YAML → 所有组件创建成功

---

## 验证标准

| 步骤 | 验证 |
|------|------|
| 1 | ThresholdSet 从 YAML map 加载全部字段；Instrument 从配置创建正确 |
| 2 | tvar 读写原子性；daily_init 文件格式与 C++ 一致 |
| 3 | `go build ./cmd/trader/` 成功；配置加载 → 组件创建无错误 |
| 4 | SIGINT 触发优雅关闭；tValue 在行情回调中更新 |
| 5 | 全部测试通过；Linux 交叉编译通过 |

最终验证：
```bash
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build ./...
go test ./pkg/...
```

---

## Phase 4 不包含的内容（推迟）

| 功能 | 推迟到 | 原因 |
|------|-------|------|
| REST/API 管理接口 | Phase 5+ | 运维便利性，非核心 |
| 结构化日志 | Phase 5+ | 优化项 |
| 持仓方向（开/平） | Phase 5+ | SHFE 特定逻辑 |
| 监控端点 | Phase 5+ | 运维便利性 |
| 会话时间管理 | Phase 5+ | 可通过外部脚本控制 |
| Indicator 系统 | Phase 5+ | 信号计算链 |

---

**最后更新**: 2026-02-13 21:40
