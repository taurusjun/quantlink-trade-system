# 共享内存 (SHM) 实现文档

**文档日期**: 2026-02-10
**版本**: v1.0
**相关模块**: golang/pkg/shm

---

## 概述

本文档描述了 Go 策略引擎中共享内存（Shared Memory）功能的实现，该功能与 C++ 原代码完全一致，用于进程间通信。

## 功能用途

| 功能 | C++ 类 | Go 结构体 | 用途 |
|------|--------|----------|------|
| TVar | `hftlib::tvar<T>` | `shm.TVar` | 外部程序向策略传递实时参数（如 tValue 调整价差均值） |
| TCache | `hftlib::tcache<T>` | `shm.TCache` | 策略向外部程序共享数据（如持仓信息） |

## 系统架构

```
┌─────────────────────────────────────────────────────────────────┐
│                         物理内存                                 │
│  ┌──────────────────────────┐  ┌──────────────────────────────┐ │
│  │  TVar (key=TVAR_KEY)     │  │  TCache (key=TCACHE_KEY)     │ │
│  │  ┌────────────────────┐  │  │  ┌────────────────────────┐  │ │
│  │  │ tValue: float64    │  │  │  │ Header: tail           │  │ │
│  │  └────────────────────┘  │  │  │ Node[0]: key, value    │  │ │
│  └──────────────────────────┘  │  │ Node[1]: key, value    │  │ │
│                                │  │ ...                     │  │ │
│                                │  └────────────────────────┘  │ │
│                                └──────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
         ▲              │                  ▲              │
         │ Load()       │ Store()          │ Load()       │ Store()
         │              ▼                  │              ▼
┌────────┴──────────────────┐    ┌─────────┴──────────────────────┐
│      Go 策略进程           │    │      Python/外部进程            │
│                           │    │                                │
│  tValue = tvar.Load()     │    │  tvar.store(0.5)              │
│  tcache.Store("pos", 10)  │    │  pos = tcache.load("pos")     │
└───────────────────────────┘    └────────────────────────────────┘
```

## 核心原理

### System V IPC 共享内存

Go 和 C++ 都使用相同的 System V IPC 机制，通过三个系统调用实现：

```
┌─────────────────────────────────────────────────────────────────┐
│  1. shmget(key, size, flags)                                    │
│     - 根据 key 创建或获取共享内存段                               │
│     - 返回 shmid（共享内存标识符）                                │
│     - 多个进程使用相同 key 获取同一块内存                          │
├─────────────────────────────────────────────────────────────────┤
│  2. shmat(shmid, NULL, 0)                                       │
│     - 将共享内存映射到当前进程的虚拟地址空间                       │
│     - 返回映射后的虚拟地址                                        │
│     - 不同进程映射到不同虚拟地址，但指向同一物理内存               │
├─────────────────────────────────────────────────────────────────┤
│  3. shmdt(addr)                                                 │
│     - 解除共享内存映射                                            │
│     - 进程退出时应调用                                            │
└─────────────────────────────────────────────────────────────────┘
```

### 内存映射示意图

```
┌──────────────────────────────────────────────────────────────────┐
│                          内核空间                                 │
│                                                                  │
│   共享内存段表:                                                   │
│   ┌────────────┬──────────┬────────────┬─────────┐              │
│   │    key     │  shmid   │  物理地址   │  大小   │              │
│   ├────────────┼──────────┼────────────┼─────────┤              │
│   │   12345    │   100    │ 0x00ABC000 │   8B    │ ◄── TVar     │
│   │   12346    │   101    │ 0x00DEF000 │  7208B  │ ◄── TCache   │
│   └────────────┴──────────┴────────────┴─────────┘              │
│                      │              │                            │
└──────────────────────┼──────────────┼────────────────────────────┘
                       │              │
         ┌─────────────┘              └─────────────┐
         ▼                                         ▼
┌─────────────────────┐                 ┌─────────────────────┐
│    Go 策略进程       │                 │   Python 模型进程    │
│                     │                 │                     │
│ 页表:               │                 │ 页表:               │
│ 0x7F001000 ──────┐  │                 │ 0x7E002000 ──────┐  │
│                  │  │                 │                  │  │
│                  ▼  │                 │                  ▼  │
│         物理地址     │                 │         物理地址     │
│         0x00ABC000  │                 │         0x00ABC000  │
│                     │                 │                     │
│ 虚拟地址不同，       │                 │ 虚拟地址不同，       │
│ 但映射到同一物理内存 │                 │ 但映射到同一物理内存 │
└─────────────────────┘                 └─────────────────────┘
```

## Go 实现详解

### TVar 结构体

```go
// TVar 是一个共享内存变量，用于进程间通信
// C++: hftlib::tvar<T> in tbsrc/common/include/tvar.h
type TVar struct {
    shmID   int      // shmget 返回的共享内存标识符
    shmAddr uintptr  // shmat 返回的映射地址
    size    int      // 共享内存大小（8 字节 = sizeof(double)）
    key     int      // 共享内存键
    mu      sync.RWMutex
}
```

### TCache 内存布局

```
┌─────────────────────────────────────────────────────────────┐
│                    TCache 内存布局                           │
├─────────────────────────────────────────────────────────────┤
│  偏移量    │  大小   │  字段          │  说明               │
├───────────┼────────┼───────────────┼────────────────────────┤
│  0        │  8B    │  Header.Tail  │  当前条目数（uint64）  │
├───────────┼────────┼───────────────┼────────────────────────┤
│  8        │  64B   │  Node[0].Key  │  键（null结尾字符串）  │
│  72       │  8B    │  Node[0].Value│  值（float64）        │
├───────────┼────────┼───────────────┼────────────────────────┤
│  80       │  64B   │  Node[1].Key  │  键                   │
│  144      │  8B    │  Node[1].Value│  值                   │
├───────────┼────────┼───────────────┼────────────────────────┤
│  ...      │  ...   │  ...          │  ...                  │
└───────────┴────────┴───────────────┴────────────────────────┘

总大小 = 8 (Header) + 72 (Node) × maxNodes
默认 maxNodes=100 时，总大小 = 8 + 72×100 = 7208 字节
```

### 读写操作

```go
// 写入 - 通过 unsafe.Pointer 直接操作内存
func (tv *TVar) Store(value float64) {
    ptr := (*float64)(unsafe.Pointer(tv.shmAddr))
    *ptr = value  // 直接写入物理内存
}

// 读取 - 通过 unsafe.Pointer 直接读取内存
func (tv *TVar) Load() float64 {
    ptr := (*float64)(unsafe.Pointer(tv.shmAddr))
    return *ptr   // 直接读取物理内存
}
```

## C++ 与 Go 对比

| 操作 | C++ 代码 | Go 代码 |
|------|---------|---------|
| 获取共享内存 | `shmget(key, size, IPC_CREAT\|0666)` | `syscall.Syscall(SYS_SHMGET, key, size, IPC_CREAT\|0666)` |
| 映射到进程 | `shmat(shmid, NULL, 0)` | `syscall.Syscall(SYS_SHMAT, shmid, 0, 0)` |
| 读取值 | `*m_ptr` | `*(*float64)(unsafe.Pointer(addr))` |
| 写入值 | `*m_ptr = value` | `*(*float64)(unsafe.Pointer(addr)) = value` |
| 解除映射 | `shmdt(addr)` | `syscall.Syscall(SYS_SHMDT, addr, 0, 0)` |

**本质上 Go 直接调用 C 的系统调用，性能与 C++ 完全一致。**

## 配置参数

在策略配置文件中添加：

```yaml
strategy:
  parameters:
    # 共享内存配置
    tvar_key: 12345     # TVAR_KEY - 用于读取外部 tValue
    tcache_key: 12346   # TCACHE_KEY - 用于写入持仓数据
```

## 使用场景

### 场景 1: Python 模型调整价差均值

```
Python 量化模型                      Go 策略
      │                                 │
      │  根据市场状态计算 tValue          │
      │  tvar.store(0.0015)             │
      ▼                                 │
┌─────────────────────────────────┐     │
│  共享内存 TVar (key=12345)       │     │
│  tValue = 0.0015                │     │
└─────────────────────────────────┘     │
                                        │ tValue = tvar.Load()
                                        ▼
                            avgSpreadRatio = mean + tValue
                                        │
                            根据调整后的均值计算 Z-Score
                            决定是否开仓
```

**C++ 原代码位置**: `tbsrc/Strategies/PairwiseArbStrategy.cpp:482-522`

```cpp
// C++ 原代码
if (m_tvar) {
    tValue = m_tvar->load();
    TBLOG << "get tvar:" << fixed << tValue << endl;
}
// ...
avgSpreadRatio = avgSpreadRatio_ori + tValue;
```

### 场景 2: 向外部共享持仓数据

```
Go 策略                              外部监控系统
      │                                   │
      │  成交后更新持仓                     │
      │  tcache.Store("leg1_pos", 10)     │
      ▼                                   │
┌─────────────────────────────────┐       │
│  共享内存 TCache (key=12346)     │       │
│  "leg1_pos": 10                 │       │
│  "leg2_pos": -10                │       │
└─────────────────────────────────┘       │
                                          │ pos = tcache.load("leg1_pos")
                                          ▼
                                   显示实时持仓
                                   风控监控
```

## 调试命令

```bash
# 查看系统中的共享内存段
ipcs -m

# 删除指定的共享内存段
ipcrm -m <shmid>

# 删除所有当前用户的共享内存段
ipcs -m | grep $(whoami) | awk '{print $2}' | xargs -I {} ipcrm -m {}
```

## 注意事项

1. **进程崩溃**: 共享内存不会自动删除，需要手动清理或使用 `ipcrm`
2. **权限**: 创建时使用 `0666` 权限，确保其他进程可以访问
3. **原子性**: TVar 的 8 字节读写在 64 位系统上是原子的，但 TCache 的多字段操作不是
4. **平台依赖**: System V IPC 在 macOS 和 Linux 上都支持，但 Windows 不支持

## 文件清单

| 文件 | 说明 |
|------|------|
| `golang/pkg/shm/tvar.go` | TVar 实现 |
| `golang/pkg/shm/tcache.go` | TCache 实现 |
| `golang/pkg/shm/shm_test.go` | 单元测试 |

## 参考资料

- C++ 原代码: `tbsrc/common/include/tvar.h`
- C++ 初始化: `tbsrc/Strategies/ExecutionStrategy.cpp:99-113`
- C++ 使用: `tbsrc/Strategies/PairwiseArbStrategy.cpp:482-522`

---

**最后更新**: 2026-02-10 16:50
