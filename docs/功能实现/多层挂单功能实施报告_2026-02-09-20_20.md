# PairwiseArbStrategy 多层挂单功能实施报告

**文档日期**: 2026-02-09
**版本**: v1.0
**相关模块**: golang/pkg/strategy

---

## 概述

本次实施为 PairwiseArbStrategy 添加了多层挂单功能，对应 C++ 旧系统中的 `MAX_QUOTE_LEVEL` 多层挂单逻辑。该功能允许策略在多个价位同时挂单，提高成交概率并降低滑点。

## 功能说明

### 多层挂单的好处

1. **提高成交概率**：如果一档没有成交，二档、三档仍有机会
2. **降低滑点**：被动挂单而非主动吃单
3. **分散风险**：不同价位的仓位分配

### C++ 原实现参考

- C++ 多层挂单: `tbsrc/Strategies/PairwiseArbStrategy.cpp`
- C++ 价格优化: `tbsrc/Strategies/PairwiseArbStrategy.cpp:802-840`
- 配置示例: `production_configs/models/model.ag2502.ag2504.par.txt.92201`

---

## 代码变更清单

| 文件 | 变更类型 | 说明 |
|------|---------|------|
| `golang/pkg/strategy/types.go` | 修改 | 添加 SignalCategory 枚举，扩展 TradingSignal |
| `golang/pkg/strategy/order_map.go` | **新建** | 实现 OrderPriceMap 订单映射管理 |
| `golang/pkg/strategy/order_map_test.go` | **新建** | OrderPriceMap 单元测试 |
| `golang/pkg/strategy/pairwise_arb_strategy.go` | 修改 | 添加多层挂单、订单映射、价格优化 |
| `config/trader.test.yaml` | 修改 | 添加新配置参数 |

---

## 数据结构设计

### 1. SignalCategory 枚举 (`types.go`)

```go
// SignalCategory represents signal type for order management
// C++: STANDARD vs CROSS order types for passive vs aggressive orders
type SignalCategory int32

const (
    SignalCategoryPassive    SignalCategory = 1 // 被动单：挂单等待成交
    SignalCategoryAggressive SignalCategory = 2 // 主动单：吃单立即成交
)
```

### 2. TradingSignal 扩展 (`types.go`)

```go
type TradingSignal struct {
    // ... 现有字段

    // Multi-level quoting fields (C++: MAX_QUOTE_LEVEL support)
    Category   SignalCategory // 订单类别：被动单 vs 主动单
    QuoteLevel int            // 挂单层级：0=一档, 1=二档, ...
}
```

### 3. OrderPriceMap (`order_map.go`)

```go
// PriceOrder represents an order at a specific price level
type PriceOrder struct {
    Price     float64   // 挂单价格
    OrderID   string    // 订单ID
    Symbol    string    // 合约代码
    Side      OrderSide // 买卖方向
    Quantity  int64     // 委托数量
    FilledQty int64     // 已成交数量
    Level     int       // 挂单层级 (0=一档, 1=二档, ...)
}

// OrderPriceMap manages orders indexed by price
// C++: 对应 m_bidMap (买单价格→订单) 和 m_askMap (卖单价格→订单)
type OrderPriceMap struct {
    mu        sync.RWMutex
    bidOrders map[float64]*PriceOrder // 买单：价格 → 订单
    askOrders map[float64]*PriceOrder // 卖单：价格 → 订单
    orderByID map[string]*PriceOrder  // 订单ID → 订单
}
```

### 4. PairwiseArbStrategy 新增字段

```go
// 多层挂单参数（C++: MAX_QUOTE_LEVEL）
maxQuoteLevel    int       // 最大挂单层数 (默认: 1)
quoteLevelSizes  []int64   // 每层下单量
enableMultiLevel bool      // 是否启用多层挂单

// 订单簿深度（5档价格）
bidPrices1, askPrices1 []float64  // Leg1 5档价格
bidPrices2, askPrices2 []float64  // Leg2 5档价格

// 挂单映射（C++: m_bidMap/m_askMap）
leg1OrderMap, leg2OrderMap *OrderPriceMap

// 价格优化参数
enablePriceOptimize bool    // 是否启用价格优化
priceOptimizeGap    int     // 触发优化的 tick 跳跃数
tickSize1, tickSize2 float64 // 最小变动单位
```

---

## 核心方法实现

### 1. updateOrderbookDepth - 更新订单簿深度

```go
// updateOrderbookDepth 更新订单簿深度数据
// 用于多层挂单时获取各档价格
func (pas *PairwiseArbStrategy) updateOrderbookDepth(bidPrices, askPrices []float64, isLeg1 bool)
```

### 2. generateMultiLevelSignals - 多层信号生成

```go
// generateMultiLevelSignals 生成多层挂单信号
// C++: 对应 MAX_QUOTE_LEVEL 多层挂单逻辑
func (pas *PairwiseArbStrategy) generateMultiLevelSignals(md *mdpb.MarketDataUpdate)
```

**核心逻辑**:
1. 遍历每一层 (0 到 maxQuoteLevel-1)
2. 获取该层的挂单价格
3. 检查是否已有挂单（避免重复）
4. 计算该层的等效 Z-Score
5. 优化挂单价格（检测隐性订单簿）
6. 生成做多/做空信号

### 3. generateLevelSignal - 单层信号生成

```go
// generateLevelSignal 生成指定层级的挂单信号
func (pas *PairwiseArbStrategy) generateLevelSignal(
    direction string,
    level int,
    price float64,
    qty int64,
    stats spread.SpreadStats,
)
```

### 4. optimizeOrderPrice - 价格优化

```go
// optimizeOrderPrice 优化挂单价格
// C++: 对应 GetBidPrice_first() 等方法中的隐性订单簿检测
func (pas *PairwiseArbStrategy) optimizeOrderPrice(
    side OrderSide,
    level int,
    basePrice float64,
    tickSize float64,
) float64
```

**价格优化逻辑**:
- 检测相邻档位之间的价格跳跃
- 如果跳跃超过 `priceOptimizeGap` 个 tick，说明可能存在隐性流动性
- 将挂单价格优化一个 tick，提高成交概率

### 5. updateOrderMaps - 订单映射维护

```go
// updateOrderMaps 根据订单状态更新订单映射
// C++: 维护 m_bidMap/m_askMap 用于避免重复挂单
func (pas *PairwiseArbStrategy) updateOrderMaps(update *orspb.OrderUpdate)
```

**状态处理**:
- `ACCEPTED` / `PARTIALLY_FILLED`: 添加到映射
- `FILLED` / `CANCELED` / `REJECTED`: 从映射移除

---

## 配置参数

### 新增配置项

```yaml
strategy:
  parameters:
    # 多层挂单参数（C++: MAX_QUOTE_LEVEL）
    enable_multi_level: false       # 是否启用多层挂单（默认关闭）
    max_quote_level: 3              # 最大挂单层数
    quote_level_sizes: [4, 3, 2]    # 每层下单量

    # 价格优化参数
    enable_price_optimize: false    # 是否启用价格优化（默认关闭）
    price_optimize_gap: 2           # 触发优化的 tick 跳跃数
    tick_size_1: 1.0                # Leg1 最小变动单位
    tick_size_2: 1.0                # Leg2 最小变动单位
```

### 参数说明

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `enable_multi_level` | bool | false | 是否启用多层挂单 |
| `max_quote_level` | int | 1 | 最大挂单层数 (1-5) |
| `quote_level_sizes` | []int | [orderSize] | 每层下单量 |
| `enable_price_optimize` | bool | false | 是否启用价格优化 |
| `price_optimize_gap` | int | 2 | 触发优化的 tick 跳跃数 |
| `tick_size_1` | float | 1.0 | Leg1 最小变动单位 |
| `tick_size_2` | float | 1.0 | Leg2 最小变动单位 |

---

## 集成说明

### OnMarketData 修改

```go
func (pas *PairwiseArbStrategy) OnMarketData(md) {
    // 更新订单簿深度（新增）
    pas.updateOrderbookDepth(md.BidPrice, md.AskPrice, isLeg1)

    // ... 现有逻辑 ...

    // 信号生成（修改）
    if pas.enableMultiLevel {
        pas.generateMultiLevelSignals(md)
    } else {
        pas.generateSignals(md)
    }
}
```

### OnOrderUpdate 修改

```go
func (pas *PairwiseArbStrategy) OnOrderUpdate(update) {
    // 维护订单映射（新增）
    pas.updateOrderMaps(update)

    // ... 现有持仓更新逻辑 ...
}
```

---

## 测试验证

### 单元测试

```bash
# 运行 OrderPriceMap 测试
go test -v ./pkg/strategy/... -run "TestOrderPriceMap|TestPriceOrder" -count=1
```

**测试用例**:
1. `TestOrderPriceMap_AddAndRemove` - 添加和移除订单
2. `TestOrderPriceMap_GetOrderByID` - 按 ID 查询订单
3. `TestOrderPriceMap_GetAllPendingOrders` - 获取所有待成交订单
4. `TestOrderPriceMap_UpdateFilledQty` - 更新成交数量
5. `TestOrderPriceMap_Clear` - 清空订单映射
6. `TestPriceOrder_IsFilled` - 检查订单是否成交
7. `TestOrderPriceMap_ConcurrentAccess` - 并发访问测试

### 端到端测试

```bash
./scripts/test/e2e/test_simulator_e2e.sh
```

---

## 使用示例

### 启用多层挂单

在配置文件中启用：

```yaml
strategies:
  - id: "test_92201"
    type: "pairwise_arb"
    parameters:
      # 启用多层挂单
      enable_multi_level: true
      max_quote_level: 3
      quote_level_sizes: [4, 3, 2]

      # 可选：启用价格优化
      enable_price_optimize: true
      price_optimize_gap: 2
      tick_size_1: 1.0
      tick_size_2: 1.0
```

### 日志输出示例

启用多层挂单后，日志会显示：

```
[PairwiseArbStrategy:test_92201] Multi-level quoting enabled: max_level=3, sizes=[4 3 2]
[PairwiseArbStrategy:test_92201] Level 0 long spread: z=-0.85, leg1=BUY@5500.00 4, leg2=SELL@5520.00 4
[PairwiseArbStrategy:test_92201] Level 1 long spread: z=-0.75, leg1=BUY@5499.00 3, leg2=SELL@5521.00 3
```

---

## 注意事项

1. **默认关闭**：多层挂单和价格优化默认关闭，需要显式启用
2. **最大层数限制**：`max_quote_level` 最大为 5（订单簿深度限制）
3. **避免重复挂单**：通过 `OrderPriceMap` 检查同一价位是否已有挂单
4. **订单映射维护**：订单状态变化时自动维护映射

---

## 参考文档

- C++ 参考: `docs/系统分析/策略对比_PairwiseArbStrategy_2026-01-31.md`
- 动态阈值: `docs/cpp_reference/SetThresholds.cpp`
- 主动追单: `docs/cpp_reference/SendAggressiveOrder.cpp`

---

**最后更新**: 2026-02-09 20:20
