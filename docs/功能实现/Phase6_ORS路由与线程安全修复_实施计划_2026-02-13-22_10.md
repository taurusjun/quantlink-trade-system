# Phase 6：ORS 路由与线程安全修复

**文档日期**: 2026-02-13
**版本**: v1.0
**相关模块**: tbsrc-golang/pkg/strategy, tbsrc-golang/pkg/execution

---

## 概述

Phase 6 修复两个关键运行时缺陷，确保系统在实际运行环境中正确工作。

## 修正内容

### 1. ORS 回调路由修复（关键修复）

**问题**: `client.orderIDMap` 将 `orderID → LegManager` 映射，ORS 回调直接到达 `LegManager.ORSCallBack`，完全绕过了 `PairwiseArbStrategy.ORSCallBack`。这导致：
- `handleAggOrder`（CROSS/MATCH 计数器管理）永远不会被调用
- `SendAggressiveOrder`（ORS 回报后的对冲重试）永远不会被触发
- Leg1 成交后 `AggRepeat` 不会重置

**根因**: C++ 中 `CommonClient::SendInfraORSUpdate()` 调用 `ExecutionStrategy::ORSCallBack()`，而 `PairwiseArbStrategy` 重写了这个虚函数。Go 中没有虚函数机制，`LegManager` 作为 `StrategyCallback` 注册在 `orderIDMap` 中，ORS 回调直接到 `LegManager`，不经过 `PairwiseArbStrategy`。

**修复方案**: 在 `LegManager` 中添加 `ORSCallbackOverride` 字段：
- `LegManager.ORSCallBack()` 检查 `ORSCallbackOverride` 是否设置
- 如果设置，转发到 override（即 `PairwiseArbStrategy`）
- `PairwiseArbStrategy` 构造函数自动设置两腿的 override
- `PairwiseArbStrategy.ORSCallBack` 内部使用 `ProcessORSDirectly()` 避免递归

**修改文件**:
- `pkg/execution/leg_manager.go`: 添加 `ORSCallbackOverride` 字段、修改 `ORSCallBack` 方法、新增 `ProcessORSDirectly`
- `pkg/strategy/pairwise_arb.go`: 构造函数设置 override
- `pkg/strategy/pairwise_callbacks.go`: 使用 `ProcessORSDirectly` 替代 `ORSCallBack`

### 2. 线程安全修复（关键修复）

**问题**: `Connector` 使用两个 goroutine（`pollMD` 和 `pollORS`）分别处理行情和订单回报，两者并发修改 `PairwiseArbStrategy` 共享状态（持仓、订单映射、阈值等），可能导致数据竞争。

**根因**: C++ 中 SHM 回调在同一线程中序列化执行。Go 的 `pollMD` 和 `pollORS` 是独立 goroutine。

**修复方案**: 在 `PairwiseArbStrategy` 中添加 `sync.Mutex`，保护所有策略状态访问：
- `MDCallBack` 和 `ORSCallBack` 入口加锁
- `HandleSquareoff` 和 `HandleSquareON` 外部入口加锁
- `SetActive` 外部入口加锁
- 内部方法使用 `*Locked` 变体避免重复加锁/死锁：
  - `handleSquareoffLocked()` — 由 MDCallBack/ORSCallBack/SendAggressiveOrder 内部调用
  - `setActiveLocked()` — 由 handleSquareoffLocked/HandleSquareON 内部调用

**修改文件**:
- `pkg/strategy/pairwise_arb.go`: 添加 `mu sync.Mutex`，拆分锁方法
- `pkg/strategy/pairwise_callbacks.go`: 入口方法加锁，内部调用改用 locked 变体
- `pkg/strategy/pairwise_aggressive.go`: 内部调用改用 `handleSquareoffLocked`

### 3. SpreadTracker Alpha 验证（确认无问题）

**调查结果**: 经 C++ 原代码核实，`PairwiseArbStrategy` 使用 `ALPHA`（非 `SPREAD_EWA`）作为 EWA 衰减因子。`SPREAD_EWA` 仅由 `SpreadStrategy`（另一策略）使用。当前 Go 代码正确使用 `thold1.Alpha`，无需修改。

**C++ 参考**: `PairwiseArbStrategy.cpp:521`
```cpp
avgSpreadRatio_ori = (1 - m_firstStrat->m_thold->ALPHA) * avgSpreadRatio_ori + m_firstStrat->m_thold->ALPHA * currSpreadRatio;
```

## 新增测试

| 测试文件 | 测试数 | 覆盖内容 |
|---------|-------|---------|
| `pairwise_ors_routing_test.go` | 5 | ORS 回调路由：override leg1/leg2、无 override、构造函数自动设置、ProcessORSDirectly |
| `pairwise_mutex_test.go` | 2 | 并发 MD+ORS 回调无 panic、HandleSquareoff 无死锁 |

## 验证

- 164 个测试全部通过（+7）
- 8 个包编译通过
- Linux/amd64 交叉编译验证通过
- 并发测试确认无死锁/数据竞争

---

**最后更新**: 2026-02-13 22:10
