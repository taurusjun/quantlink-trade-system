# 回测系统评估报告

**文档日期**: 2026-02-10
**版本**: v1.0
**相关模块**: golang/pkg/backtest/, hftbase/ExchangeSimulator/

---

## 概述

本文档基于对以下三个方面的深入分析，评估当前回测系统的功能完整性、仿真精度和改进方向：
1. 项目文档 (`docs/回测/` 目录)
2. Go 新代码 (`golang/pkg/backtest/`)
3. C++ 原代码 (`hftbase/ExchangeSimulator/`)

---

## 一、三方对比总览

| 维度 | C++ 原系统 (hftbase) | Go 新系统 (quantlink) | 差距 |
|------|---------------------|----------------------|------|
| **撮合引擎** | 完整订单簿模拟，支持队列位置、部分成交 | 简单价格撮合（仅比较买一/卖一） | 较大 |
| **交易所支持** | 10+ 交易所专用引擎 | 通用引擎 | 中等 |
| **数据格式** | 二进制压缩(LZ4/Snappy)、差分编码 | CSV 纯文本 | 中等 |
| **时间模拟** | 微秒级精度、订单确认延迟 | 毫秒级、简单延迟 | 中等 |
| **统计指标** | Sharpe、Sortino、Impact% | Sharpe、Sortino、MDD、Calmar | 相当 |
| **参数优化** | 无（手动调参） | 网格搜索、并行优化 | 新系统更优 |
| **配置生成** | Control+Model 手动维护 | 自动生成新旧格式 | 新系统更优 |

---

## 二、Go 新系统功能清单

### 2.1 已完成功能

| 模块 | 功能 | 文件 | 状态 |
|------|------|------|------|
| **数据读取** | CSV 加载、多品种合并、时间过滤 | datareader.go | ✅ 已完成 |
| **回放模式** | Realtime/Fast/Instant 三种模式 | datareader.go | ✅ 已完成 |
| **订单撮合** | 简单价格撮合、滑点模拟 | order_router.go | ✅ 已完成 |
| **统计计算** | Sharpe、Sortino、MDD、Calmar、胜率 | statistics.go | ✅ 已完成 |
| **报告生成** | Markdown、JSON、CSV | report.go | ✅ 已完成 |
| **参数优化** | 网格搜索、并行执行、多目标 | optimizer.go | ✅ 已完成 |
| **配置导出** | YAML、Control、Model 文件生成 | production_config.go | ✅ 已完成 |
| **Trader 集成** | gRPC 接口、与实盘策略复用 | runner.go | ✅ 已完成 |

### 2.2 缺失功能

| 功能 | C++ 原系统实现 | 重要性 | 优先级 |
|------|---------------|--------|--------|
| **队列位置模拟** | `QuantAhead` 跟踪前置订单量 | 高 | P0 |
| **订单簿深度撮合** | 穿透多档位、价格冲击计算 | 高 | P0 |
| **部分成交** | 根据订单簿流动性部分成交 | 高 | P0 |
| **时间优先队列** | `TIMEWISEPRIORITY` 配置 | 中 | P1 |
| **订单确认延迟** | 微秒级 `EXCHDELAY` | 中 | P1 |
| **二进制数据格式** | LZ4/Snappy 压缩 | 中 | P1 |
| **Walk Forward 验证** | 滚动窗口前向测试 | 中 | P1 |

---

## 三、核心差距分析

### 3.1 撮合引擎差距（最关键）

#### C++ 原系统撮合逻辑

```cpp
// 文件: hftbase/ExchangeSimulator/src/simenginebase.cpp

// 1. 基于订单簿撮合 - 考虑队列位置
void SimEngineBase::MatchOrderAgainstOrderBook(int32_t orderId, bool &filled) {
    // 计算订单前面的数量
    int quantAhead = CalculateQuantAhead(order);
    // 只有当前置量被消耗后才能成交
    if (quantAhead <= 0) {
        filled = true;
        fillQty = min(order.qty, availableQty);
    }
}

// 2. 基于成交回报撮合 - 随机分配
void SimEngineBase::MatchOrderAgainstTrade(int32_t orderId, bool &filled) {
    // 使用最新成交价(LTP)和成交量(LTQ)
    // 根据队列位置概率性成交
}
```

#### Go 新系统撮合逻辑

```go
// 文件: golang/pkg/backtest/order_router.go

// 简单价格比较 - 不考虑队列位置
func (r *BacktestOrderRouter) TryMatchUnsafe(order *Order, md *MarketData) bool {
    if order.Side == BUY && order.Price >= md.AskPrice[0] {
        return true  // 立即全部成交
    }
    if order.Side == SELL && order.Price <= md.BidPrice[0] {
        return true  // 立即全部成交
    }
    return false
    // 无队列位置、无部分成交
}
```

#### 影响分析

| 影响项 | 描述 |
|--------|------|
| **收益高估** | 高频策略回测结果过于乐观，实盘可能无法复现 |
| **流动性盲区** | 无法评估大单对市场的冲击和流动性风险 |
| **滑点失真** | 滑点估算不准确，交易成本被低估 |

### 3.2 数据格式差距

| 特性 | C++ 原系统 | Go 新系统 |
|------|-----------|----------|
| 文件格式 | 二进制 + 压缩 | CSV 文本 |
| 读取速度 | ~100MB/s | ~10MB/s |
| 存储占用 | 1x (压缩后) | 5-10x |
| 时间精度 | 纳秒 | 毫秒 |

### 3.3 C++ 原系统架构参考

```
SimEngineBase (基类)
├── OrderLevelSimBase<T>  (订单级别模拟)
│   ├── CMESimEngine
│   ├── BrazilSimEngine
│   └── NSESimEngine
├── MultiChannelSimEngine
│   └── PriceLevelSimEngine
│       └── DataManipSimEngine
├── RussiaSimEngine
├── DisconnectedSimEngine (快照模式，中国市场使用)
└── ReplaySimEngine (回放模式)
```

**关键设计要点**：
- 通过 `InteractionMode` 枚举切换实盘/回测模式
- 策略代码无需修改即可在两种模式间切换
- 使用工厂模式创建特定交易所的撮合引擎

---

## 四、评估结论

### 4.1 系统评分

| 维度 | 评分 | 说明 |
|------|------|------|
| **功能完整性** | 80% | 核心功能完整，缺少高级撮合 |
| **易用性** | 95% | 配置简单，文档完善 |
| **性能** | 60% | CSV 读取慢，可优化 |
| **仿真精度** | 40% | 撮合过于简化 |
| **参数优化** | 95% | 优于 C++ 原系统 |

### 4.2 适用场景

| 场景 | 适用度 | 原因 |
|------|--------|------|
| **中低频策略验证** | 适合 | 简单撮合对中低频影响小 |
| **参数敏感性分析** | 适合 | 网格搜索功能强大 |
| **高频策略回测** | 不适合 | 撮合精度不足 |
| **流动性风险评估** | 不适合 | 无订单簿深度模拟 |
| **生产前验证** | 需谨慎 | 应结合实盘小规模测试 |

---

## 五、改进建议

### 5.1 高优先级（P0）

#### 任务 1: 实现订单簿深度撮合

**目标**: 支持多档位撮合、部分成交、价格冲击计算

**设计方案**:

```go
// 配置结构
type DepthMatchingConfig struct {
    Enabled         bool    `yaml:"enabled"`
    MaxDepthLevels  int     `yaml:"max_depth_levels"`  // 最大穿透档位 (1-10)
    MinFillRatio    float64 `yaml:"min_fill_ratio"`    // 最小成交比例 (0.5)
    RealisticMode   bool    `yaml:"realistic_mode"`    // 考虑流动性限制
}

// 配置示例
backtest:
  order_simulation:
    depth_matching:
      enabled: true
      max_depth_levels: 5
      min_fill_ratio: 0.5
      realistic_mode: true

// 新撮合逻辑
func (r *BacktestOrderRouter) MatchWithDepth(order *Order, md *MarketData) *Fill {
    remainQty := order.Quantity
    var fills []PartialFill
    totalCost := 0.0

    for level := 0; level < config.MaxDepthLevels && remainQty > 0; level++ {
        var price float64
        var availableQty int64

        if order.Side == BUY {
            price = md.AskPrice[level]
            availableQty = md.AskVolume[level]
        } else {
            price = md.BidPrice[level]
            availableQty = md.BidVolume[level]
        }

        fillQty := min(remainQty, availableQty)
        totalCost += price * float64(fillQty)
        fills = append(fills, PartialFill{Price: price, Qty: fillQty})
        remainQty -= fillQty
    }

    // 计算加权平均成交价
    avgPrice := totalCost / float64(order.Quantity - remainQty)
    return &Fill{
        Price:    avgPrice,
        Quantity: order.Quantity - remainQty,
        Partial:  remainQty > 0,
    }
}
```

**预期收益**:
- 交易成本估算准确性提升 30-50%
- 支持流动性风险评估
- 支持部分成交模拟

**参考文档**: `docs/回测/回测_P2优化_订单簿深度模拟设计_2026-01-24-21_15.md`

#### 任务 2: 添加队列位置模拟

**目标**: 模拟限价单的队列排队效果

**设计方案**:

```go
// 队列模拟器
type QueueSimulator struct {
    // 订单ID -> 该订单前面的挂单数量
    quantAhead map[string]int64
    // 价格档位 -> 当前挂单总量
    levelQuantity map[string]map[float64]int64
}

// 下单时记录队列位置
func (q *QueueSimulator) OnNewOrder(order *Order, md *MarketData) {
    var qtyAhead int64
    if order.Side == BUY {
        // 买单：计算在该价位之前的买单数量
        for i := 0; i < 5; i++ {
            if md.BidPrice[i] >= order.Price {
                qtyAhead += md.BidVolume[i]
            }
        }
    }
    q.quantAhead[order.ID] = qtyAhead
}

// 成交时消耗队列
func (q *QueueSimulator) OnTrade(symbol string, price float64, tradeQty int64) {
    for orderID, ahead := range q.quantAhead {
        // 同价位成交消耗队列
        if q.getOrderPrice(orderID) == price {
            q.quantAhead[orderID] = max(0, ahead - tradeQty)
        }
    }
}

// 检查是否可以成交
func (q *QueueSimulator) CanFill(orderID string) bool {
    ahead, exists := q.quantAhead[orderID]
    return exists && ahead == 0
}
```

**预期收益**:
- 限价单成交概率更真实
- 高频策略回测更准确

### 5.2 中优先级（P1）

#### 任务 3: 支持二进制数据格式

**目标**: 提升数据读取性能 5-10 倍

```go
// 支持的数据格式
type DataFormat string

const (
    FormatCSV     DataFormat = "csv"
    FormatParquet DataFormat = "parquet"
    FormatBinary  DataFormat = "binary"
)

// 配置
backtest:
  data:
    format: "parquet"  // csv | parquet | binary
    compression: "snappy"  // none | snappy | lz4
```

#### 任务 4: 添加 Walk Forward 验证

**目标**: 防止参数过拟合

```go
type WalkForwardConfig struct {
    TrainPeriod  int  `yaml:"train_period"`  // 训练窗口（天）
    TestPeriod   int  `yaml:"test_period"`   // 测试窗口（天）
    NumFolds     int  `yaml:"num_folds"`     // 折数
    Overlap      int  `yaml:"overlap"`       // 重叠天数
}

// 使用示例
./bin/backtest_optimize \
  -action walk-forward \
  -config config/backtest.yaml \
  -train-period 30 \
  -test-period 10 \
  -folds 5
```

### 5.3 低优先级（P2）

#### 任务 5: 添加更多优化算法

| 算法 | 适用场景 | 复杂度 |
|------|---------|--------|
| 贝叶斯优化 | 参数维度高、评估成本大 | 中 |
| 遗传算法 | 离散参数、组合优化 | 中 |
| 随机搜索 | 快速探索、基线对比 | 低 |

#### 任务 6: HTML 交互式报告

- 使用 ECharts/Plotly 生成图表
- 支持 PNL 曲线、回撤图、参数热力图
- 交互式筛选和对比

---

## 六、实施路线图

| 阶段 | 任务 | 预估工作量 | 优先级 |
|------|------|-----------|--------|
| **Phase 1** | 订单簿深度撮合 | 2-3 天 | P0 |
| **Phase 2** | 队列位置模拟 | 1-2 天 | P0 |
| **Phase 3** | 二进制数据格式 | 2-3 天 | P1 |
| **Phase 4** | Walk Forward 验证 | 1-2 天 | P1 |
| **Phase 5** | 高级优化算法 | 3-5 天 | P2 |
| **Phase 6** | HTML 报告 | 2-3 天 | P2 |

**建议执行顺序**: Phase 1 → Phase 2 → Phase 4 → Phase 3 → Phase 5 → Phase 6

---

## 七、相关文档

- 回测使用指南: `docs/回测/回测_使用指南_2026-01-24-19_00.md`
- 参数优化指南: `docs/回测/回测_参数优化使用指南_2026-01-24-20_30.md`
- 深度模拟设计: `docs/回测/回测_P2优化_订单簿深度模拟设计_2026-01-24-21_15.md`
- Control+Model 分析: `docs/回测/回测_Control+Model机制分析与启发_2026-01-24-20_05.md`

## 八、相关代码

- 回测核心包: `golang/pkg/backtest/`
- 回测主程序: `golang/cmd/backtest/main.go`
- 参数优化: `golang/cmd/backtest_optimize/main.go`
- C++ 撮合引擎: `hftbase/ExchangeSimulator/src/simenginebase.cpp`

---

**最后更新**: 2026-02-10
