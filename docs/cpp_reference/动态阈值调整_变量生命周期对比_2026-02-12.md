# 动态阈值调整 - 变量生命周期对比报告

**文档日期**: 2026-02-12  
**版本**: v1.0  
**参考文档**: `CODE_CONSISTENCY_CHECKLIST.md`  
**C++ 原代码**: `tbsrc/Strategies/PairwiseArbETFStrategy.cpp:612-651`  
**Go 实现**: `golang/pkg/strategy/pairwise_arb_strategy.go:1304-1362`

---

## 概述

本文档按照 `CODE_CONSISTENCY_CHECKLIST.md` 中的变量生命周期追踪方法论，对动态阈值调整功能（`SetThresholds`）进行 C++ 与 Go 代码的完整对比分析。

### 变量生命周期追踪方法

```
┌─────────────────┐
│   初始化        │  ← 从哪里读取？默认值是什么？
├─────────────────┤
│   更新          │  ← 何时更新？更新公式是什么？
├─────────────────┤
│   使用          │  ← 在哪里使用？如何影响交易逻辑？
├─────────────────┤
│   保存          │  ← 保存到哪里？保存的是什么值？
└─────────────────┘
```

---

## 1. 入场阈值变量

### 1.1 m_tholdBidPlace / entryZScoreBid (做多入场阈值)

| 生命周期 | C++ 实现 | Go 实现 | 状态 |
|---------|---------|---------|------|
| **定义位置** | `ExecutionStrategy.h:169` | `pairwise_arb_strategy.go:69` | ✅ |
| **初始化来源** | `BEGIN_PLACE` (ThresholdSet 配置) | `beginZScore` (从配置读取) | ✅ 一致 |
| **初始化代码** | `PairwiseArbETFStrategy.cpp:632` | `pairwise_arb_strategy.go:357` | ✅ |
| **默认值** | 由配置文件决定 | 由配置文件决定 | ✅ 一致 |

#### 更新逻辑对比

**空仓 (netpos == 0)**:
| 项目 | C++ | Go |
|-----|-----|-----|
| 公式 | `= BEGIN_PLACE` | `= beginZScore` |
| 代码位置 | `PairwiseArbETFStrategy.cpp:632` | `pairwise_arb_strategy.go:1338` |
| 状态 | ✅ 一致 | |

**多头持仓 (netpos > 0)**:
| 项目 | C++ | Go |
|-----|-----|-----|
| 公式 | `= BEGIN_PLACE + long_place_diff * netpos / maxPos` | `= beginZScore + longPlaceDiff * posRatio` |
| 代码位置 | `PairwiseArbETFStrategy.cpp:639` | `pairwise_arb_strategy.go:1345` |
| 状态 | ✅ 一致 | |

**空头持仓 (netpos < 0)**:
| 项目 | C++ | Go |
|-----|-----|-----|
| 公式 | `= BEGIN_PLACE + short_place_diff * netpos / maxPos` | `= beginZScore + shortPlaceDiff * posRatio` |
| 代码位置 | `PairwiseArbETFStrategy.cpp:646` | `pairwise_arb_strategy.go:1355` |
| 状态 | ✅ 一致 | |

#### 使用位置

| 用途 | C++ 位置 | Go 位置 | 状态 |
|-----|---------|---------|------|
| 做多信号判断 | `PairwiseArbETFStrategy.cpp:233` | `pairwise_arb_strategy.go:1115` | ✅ |
| 多层挂单 | `PairwiseArbETFStrategy.cpp:233` | `pairwise_arb_strategy.go:826` | ✅ |

#### 保存

- **不保存** - 运行时动态计算的变量

---

### 1.2 m_tholdAskPlace / entryZScoreAsk (做空入场阈值)

| 生命周期 | C++ 实现 | Go 实现 | 状态 |
|---------|---------|---------|------|
| **定义位置** | `ExecutionStrategy.h:171` | `pairwise_arb_strategy.go:70` | ✅ |
| **初始化来源** | `BEGIN_PLACE` | `beginZScore` | ✅ 一致 |

#### 更新逻辑对比

**空仓 (netpos == 0)**:
| C++ | Go | 状态 |
|-----|-----|------|
| `= BEGIN_PLACE` | `= beginZScore` | ✅ 一致 |

**多头持仓 (netpos > 0)**:
| C++ | Go | 状态 |
|-----|-----|------|
| `= BEGIN_PLACE - short_place_diff * netpos / maxPos` | `= beginZScore - shortPlaceDiff * posRatio` | ✅ 一致 |

**空头持仓 (netpos < 0)**:
| C++ | Go | 状态 |
|-----|-----|------|
| `= BEGIN_PLACE - long_place_diff * netpos / maxPos` | `= beginZScore - longPlaceDiff * posRatio` | ✅ 一致 |

---

## 2. 撤单阈值变量

### 2.1 m_tholdBidRemove / exitZScoreBid (做多撤单阈值)

| 生命周期 | C++ 实现 | Go 实现 | 状态 |
|---------|---------|---------|------|
| **定义位置** | `ExecutionStrategy.h:170` | `pairwise_arb_strategy.go:74` | ✅ |
| **初始化来源** | `BEGIN_REMOVE` (ThresholdSet) | `exitZScore` (配置) | ✅ 一致 |
| **初始化代码** | `PairwiseArbETFStrategy.cpp:633` | `pairwise_arb_strategy.go:359` | ✅ |

#### 更新逻辑对比

| 持仓状态 | C++ 公式 | Go 公式 | 状态 |
|---------|---------|---------|------|
| 空仓 | `= BEGIN_REMOVE` | `= exitZScore` | ✅ |
| 多头 | `= BEGIN_REMOVE + long_remove_diff * netpos / maxPos` | `= exitZScore + longRemoveDiff * posRatio` | ✅ |
| 空头 | `= BEGIN_REMOVE + short_remove_diff * netpos / maxPos` | `= exitZScore + shortRemoveDiff * posRatio` | ✅ |

#### 使用位置

| 用途 | C++ 代码 | Go 代码 | 状态 |
|-----|---------|---------|------|
| 撤单判断 | `if (LongSpreadRatio > avgSpread - m_tholdBidRemove)` | `if longSpreadRatio > avgSpreadRatio - pas.exitZScoreBid` | ✅ |
| 代码位置 | `PairwiseArbETFStrategy.cpp:139` | `pairwise_arb_strategy.go:1400` | ✅ |

---

### 2.2 m_tholdAskRemove / exitZScoreAsk (做空撤单阈值)

| 生命周期 | C++ 实现 | Go 实现 | 状态 |
|---------|---------|---------|------|
| **定义位置** | `ExecutionStrategy.h:172` | `pairwise_arb_strategy.go:75` | ✅ |
| **初始化来源** | `BEGIN_REMOVE` | `exitZScore` | ✅ 一致 |

#### 更新逻辑对比

| 持仓状态 | C++ 公式 | Go 公式 | 状态 |
|---------|---------|---------|------|
| 空仓 | `= BEGIN_REMOVE` | `= exitZScore` | ✅ |
| 多头 | `= BEGIN_REMOVE - short_remove_diff * netpos / maxPos` | `= exitZScore - shortRemoveDiff * posRatio` | ✅ |
| 空头 | `= BEGIN_REMOVE - long_remove_diff * netpos / maxPos` | `= exitZScore - longRemoveDiff * posRatio` | ✅ |

#### 使用位置

| 用途 | C++ 代码 | Go 代码 | 状态 |
|-----|---------|---------|------|
| 撤单判断 | `if (ShortSpreadRatio < avgSpread + m_tholdAskRemove)` | `if shortSpreadRatio < avgSpreadRatio + pas.exitZScoreAsk` | ✅ |
| 代码位置 | `PairwiseArbETFStrategy.cpp:149` | `pairwise_arb_strategy.go:1421` | ✅ |

---

## 3. 持仓变量 (关键依赖)

### 3.1 m_netpos_pass / NetPosPass (Leg1 被动持仓)

| 生命周期 | C++ 实现 | Go 实现 | 状态 |
|---------|---------|---------|------|
| **定义位置** | `ExecutionStrategy.h:112` | `execution_strategy.go:93` | ✅ |
| **初始化来源** | `daily_init: ytd1 + 2day1` | `daily_init: ytd1 + 2day1` | ✅ 一致 |
| **初始化代码** | `m_firstStrat->m_netpos_pass = netpos_ytd1 + netpos_2day1` | `pas.firstStrat.NetPosPass = netpos_ytd1 + netpos_2day1` | ✅ |
| **代码位置** | `PairwiseArbETFStrategy.cpp:23` | `pairwise_arb_strategy.go:575` | ✅ |

#### 更新逻辑

| 触发条件 | C++ | Go | 状态 |
|---------|-----|-----|------|
| 被动买单成交 | `m_netpos_pass += Quantity` | `NetPosPass += Quantity` | ✅ |
| 被动卖单成交 | `m_netpos_pass -= Quantity` | `NetPosPass -= Quantity` | ✅ |
| 代码位置 | `ExecutionStrategy.cpp:2052` | `execution_strategy.go:509-511` | ✅ |

#### 在 SetThresholds 中的使用

| 项目 | C++ | Go | 状态 |
|-----|-----|-----|------|
| 使用变量 | `m_firstStrat->m_netpos_pass` | `pas.firstStrat.NetPosPass` | ✅ **已修复** |
| 计算公式 | `netpos / m_tholdMaxPos` | `float64(netPosPass) / float64(pas.maxPositionSize)` | ✅ |

> ⚠️ **重要**: 此问题在 CODE_CONSISTENCY_CHECKLIST.md #5 中标记为已修复。Go 代码使用 `firstStrat.NetPosPass` 而非旧的 `leg1Position`。

#### 保存

| 项目 | C++ | Go | 状态 |
|-----|-----|-----|------|
| 保存位置 | `daily_init` 文件 | `daily_init` 文件 | ✅ |
| 保存字段 | `ytd` 和 `2day` | `ytd` 和 `2day` | ✅ |
| 保存代码 | `PairwiseArbETFStrategy.cpp:439-440` | `pairwise_arb_strategy.go:2547-2548` | ✅ |

---

### 3.2 m_tholdMaxPos / maxPositionSize (最大仓位)

| 生命周期 | C++ 实现 | Go 实现 | 状态 |
|---------|---------|---------|------|
| **定义位置** | `ExecutionStrategy.h:174` | `pairwise_arb_strategy.go:50` | ✅ |
| **初始化来源** | `MAX_SIZE * lotSize` (配置) | `config.MaxPositionSize` 或 `Parameters["max_position_size"]` | ✅ **已修复** |
| **默认值** | 由配置决定 | 50 (如果配置未指定) | ✅ |

#### 零值保护

| 项目 | C++ | Go | 状态 |
|-----|-----|-----|------|
| 零值检查 | 未显式检查 | `if pas.maxPositionSize == 0 { return }` | ✅ Go 更安全 |

> ⚠️ **已修复问题**: Go 代码现在支持从顶层 `config.MaxPositionSize` 读取，解决了实盘配置问题。

---

## 4. 配置参数映射

### 4.1 阈值差值计算

| 差值变量 | C++ 公式 | Go 公式 | 状态 |
|---------|---------|---------|------|
| `long_place_diff` | `LONG_PLACE - BEGIN_PLACE` | `longZScore - beginZScore` | ✅ |
| `short_place_diff` | `BEGIN_PLACE - SHORT_PLACE` | `beginZScore - shortZScore` | ✅ |
| `long_remove_diff` | `LONG_REMOVE - BEGIN_REMOVE` | `longExitZScore - exitZScore` | ✅ |
| `short_remove_diff` | `BEGIN_REMOVE - SHORT_REMOVE` | `exitZScore - shortExitZScore` | ✅ |

### 4.2 配置文件参数映射

| C++ 参数 (ThresholdSet) | Go 参数 | 配置文件字段 | 说明 |
|-------------------------|---------|-------------|------|
| `BEGIN_PLACE` | `beginZScore` | `begin_zscore` | 空仓入场阈值 |
| `LONG_PLACE` | `longZScore` | `long_zscore` | 满仓多头做多阈值 |
| `SHORT_PLACE` | `shortZScore` | `short_zscore` | 满仓空头做空阈值 |
| `BEGIN_REMOVE` | `exitZScore` | `exit_zscore` | 空仓撤单阈值 |
| `LONG_REMOVE` | `longExitZScore` | `long_exit_zscore` | 满仓多头撤单阈值 |
| `SHORT_REMOVE` | `shortExitZScore` | `short_exit_zscore` | 满仓空头撤单阈值 |
| `MAX_SIZE` | `maxPositionSize` | `max_position_size` | 最大持仓 |

---

## 5. 算法公式完整对照

### 5.1 C++ SetThresholds() 原代码

```cpp
// PairwiseArbETFStrategy.cpp:612-651
void PairwiseArbETFStrategy::SetThresholds() {
    // 阈值差值计算
    auto long_place_diff_thold = m_thold_first->LONG_PLACE - m_thold_first->BEGIN_PLACE;
    auto short_place_diff_thold = m_thold_first->BEGIN_PLACE - m_thold_first->SHORT_PLACE;
    auto long_remove_diff_thold = m_thold_first->LONG_REMOVE - m_thold_first->BEGIN_REMOVE;
    auto short_remove_diff_thold = m_thold_first->BEGIN_REMOVE - m_thold_first->SHORT_REMOVE;
    
    if (m_firstStrat->m_netpos_pass == 0) {
        // 空仓：使用初始阈值
        m_firstStrat->m_tholdBidPlace = m_thold_first->BEGIN_PLACE;
        m_firstStrat->m_tholdBidRemove = m_thold_first->BEGIN_REMOVE;
        m_firstStrat->m_tholdAskPlace = m_thold_first->BEGIN_PLACE;
        m_firstStrat->m_tholdAskRemove = m_thold_first->BEGIN_REMOVE;
    } else if (m_firstStrat->m_netpos_pass > 0) {
        // 多头持仓
        m_firstStrat->m_tholdBidPlace = m_thold_first->BEGIN_PLACE 
            + long_place_diff_thold * m_firstStrat->m_netpos_pass / m_firstStrat->m_tholdMaxPos;
        m_firstStrat->m_tholdBidRemove = m_thold_first->BEGIN_REMOVE 
            + long_remove_diff_thold * m_firstStrat->m_netpos_pass / m_firstStrat->m_tholdMaxPos;
        m_firstStrat->m_tholdAskPlace = m_thold_first->BEGIN_PLACE 
            - short_place_diff_thold * m_firstStrat->m_netpos_pass / m_firstStrat->m_tholdMaxPos;
        m_firstStrat->m_tholdAskRemove = m_thold_first->BEGIN_REMOVE 
            - short_remove_diff_thold * m_firstStrat->m_netpos_pass / m_firstStrat->m_tholdMaxPos;
    } else {
        // 空头持仓
        m_firstStrat->m_tholdBidPlace = m_thold_first->BEGIN_PLACE 
            + short_place_diff_thold * m_firstStrat->m_netpos_pass / m_firstStrat->m_tholdMaxPos;
        m_firstStrat->m_tholdBidRemove = m_thold_first->BEGIN_REMOVE 
            + short_remove_diff_thold * m_firstStrat->m_netpos_pass / m_firstStrat->m_tholdMaxPos;
        m_firstStrat->m_tholdAskPlace = m_thold_first->BEGIN_PLACE 
            - long_place_diff_thold * m_firstStrat->m_netpos_pass / m_firstStrat->m_tholdMaxPos;
        m_firstStrat->m_tholdAskRemove = m_thold_first->BEGIN_REMOVE 
            - long_remove_diff_thold * m_firstStrat->m_netpos_pass / m_firstStrat->m_tholdMaxPos;
    }
}
```

### 5.2 Go setDynamicThresholds() 实现

```go
// pairwise_arb_strategy.go:1304-1362
func (pas *PairwiseArbStrategy) setDynamicThresholds() {
    if !pas.useDynamicThreshold || pas.maxPositionSize == 0 {
        // 未启用动态阈值，使用静态值
        pas.entryZScoreBid = pas.entryZScore
        pas.entryZScoreAsk = pas.entryZScore
        pas.exitZScoreBid = pas.exitZScore
        pas.exitZScoreAsk = pas.exitZScore
        return
    }

    // 阈值差值计算
    longPlaceDiff := pas.longZScore - pas.beginZScore
    shortPlaceDiff := pas.beginZScore - pas.shortZScore
    longRemoveDiff := pas.longExitZScore - pas.exitZScore
    shortRemoveDiff := pas.exitZScore - pas.shortExitZScore

    // 使用 firstStrat.NetPosPass (与 C++ 一致)
    var netPosPass int32 = 0
    if pas.firstStrat != nil {
        netPosPass = pas.firstStrat.NetPosPass
    }
    posRatio := float64(netPosPass) / float64(pas.maxPositionSize)

    if netPosPass == 0 {
        // 空仓
        pas.entryZScoreBid = pas.beginZScore
        pas.entryZScoreAsk = pas.beginZScore
        pas.exitZScoreBid = pas.exitZScore
        pas.exitZScoreAsk = pas.exitZScore
    } else if netPosPass > 0 {
        // 多头持仓
        pas.entryZScoreBid = pas.beginZScore + longPlaceDiff*posRatio
        pas.entryZScoreAsk = pas.beginZScore - shortPlaceDiff*posRatio
        pas.exitZScoreBid = pas.exitZScore + longRemoveDiff*posRatio
        pas.exitZScoreAsk = pas.exitZScore - shortRemoveDiff*posRatio
    } else {
        // 空头持仓
        pas.entryZScoreBid = pas.beginZScore + shortPlaceDiff*posRatio
        pas.entryZScoreAsk = pas.beginZScore - longPlaceDiff*posRatio
        pas.exitZScoreBid = pas.exitZScore + shortRemoveDiff*posRatio
        pas.exitZScoreAsk = pas.exitZScore - longRemoveDiff*posRatio
    }
}
```

---

## 6. 计算示例验证

### 配置参数
```
BEGIN_PLACE = 2.0
LONG_PLACE = 3.5
SHORT_PLACE = 0.5
maxPos = 100
```

### 差值计算
```
long_place_diff = 3.5 - 2.0 = 1.5
short_place_diff = 2.0 - 0.5 = 1.5
```

### 场景验证

| 场景 | netpos | posRatio | C++ tholdBid | Go entryBid | C++ tholdAsk | Go entryAsk | 状态 |
|------|--------|----------|-------------|-------------|-------------|-------------|------|
| 空仓 | 0 | 0.0 | 2.0 | 2.0 | 2.0 | 2.0 | ✅ |
| 满仓多头 | 100 | 1.0 | 3.5 | 3.5 | 0.5 | 0.5 | ✅ |
| 满仓空头 | -100 | -1.0 | 0.5 | 0.5 | 3.5 | 3.5 | ✅ |
| 半仓多头 | 50 | 0.5 | 2.75 | 2.75 | 1.25 | 1.25 | ✅ |
| 25%多头 | 25 | 0.25 | 2.375 | 2.375 | 1.625 | 1.625 | ✅ |

---

## 7. 已修复问题清单

| # | 问题 | 严重程度 | 修复日期 | 修复内容 |
|---|------|---------|---------|---------|
| 1 | setDynamicThresholds 使用 leg1Position 而非 NetPosPass | 高 | 2026-02-10 | 改为使用 `firstStrat.NetPosPass` |
| 2 | maxPositionSize 只从 Parameters 读取 | 高 | 2026-02-12 | 添加从顶层 `config.MaxPositionSize` 回退读取 |

---

## 8. 测试验证

### 端到端测试文件
`golang/pkg/strategy/dynamic_threshold_e2e_test.go`

### 测试用例

| 测试名称 | 覆盖场景 | 状态 |
|---------|---------|------|
| `TestDynamicThreshold_E2E_FullLifecycle` | 完整生命周期 (9阶段) | ✅ PASS |
| `TestDynamicThreshold_E2E_DisabledMode` | 禁用动态阈值 | ✅ PASS |
| `TestDynamicThreshold_E2E_ZeroMaxPosition` | 最大仓位为0边界 | ✅ PASS |
| `TestDynamicThreshold_E2E_CPPComparison` | C++ 对照验证 | ✅ PASS |
| `TestDynamicThreshold_E2E_TopLevelMaxPositionSize` | 顶层配置读取 | ✅ PASS |

### 运行测试命令
```bash
cd golang && go test -v -run "TestDynamicThreshold_E2E" ./pkg/strategy/
```

---

## 9. 总结

### 一致性结论

| 检查项 | 结果 |
|--------|------|
| 入场阈值公式 | ✅ 完全一致 |
| 撤单阈值公式 | ✅ 完全一致 |
| 持仓变量来源 | ✅ 已修复，使用 NetPosPass |
| 配置参数映射 | ✅ 完全一致 |
| 分支逻辑 (空仓/多头/空头) | ✅ 完全一致 |

### Go 额外实现

| 功能 | 说明 |
|------|------|
| 动态阈值开关 | `useDynamicThreshold` 可禁用功能 |
| 零值保护 | `maxPositionSize == 0` 时安全返回 |
| 配置回退 | 支持从顶层和 Parameters 两处读取 |

---

**文档维护者**: Claude  
**最后更新**: 2026-02-12
