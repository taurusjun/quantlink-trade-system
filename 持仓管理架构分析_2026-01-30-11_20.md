# 持仓管理架构分析

**分析时间**: 2026-01-30 11:20
**问题**: counter_bridge持仓查询的合理性

---

## 📊 当前持仓管理架构

### 层次1: 策略层持仓追踪（主要方式）

**位置**: `golang/pkg/strategy/strategy.go`

**机制**: 从订单回报（OrderUpdate）中实时追踪持仓

```go
// BaseStrategy.UpdatePosition()
func (bs *BaseStrategy) UpdatePosition(update *orspb.OrderUpdate) {
    if update.Status == orspb.OrderStatus_FILLED {
        if update.Side == orspb.OrderSide_BUY {
            bs.Position.LongQty += qty
            bs.Position.AvgLongPrice = (totalCost + price*qty) / LongQty
        } else {
            bs.Position.ShortQty += qty
            bs.Position.AvgShortPrice = (totalCost + price*qty) / ShortQty
        }
        bs.Position.NetQty = LongQty - ShortQty
    }
}
```

**调用流程**:
```
CTP成交回报 → counter_bridge → ors_gateway → NATS →
  StrategyEngine.OnOrderUpdate() → Strategy.OnOrderUpdate() →
    BaseStrategy.UpdatePosition()
```

**特点**:
- ✅ **实时性高**: 订单成交后立即更新持仓
- ✅ **准确性高**: 直接从成交回报计算，不会丢失
- ✅ **分层追踪**: BaseStrategy追踪总持仓，子策略追踪leg持仓
- ✅ **PNL计算**: 同时计算已实现和未实现盈亏

### 层次2: Pairwise策略的Leg持仓追踪

**位置**: `golang/pkg/strategy/pairwise_arb_strategy.go`

**机制**: 在BaseStrategy基础上，额外追踪每条腿的持仓

```go
// PairwiseArbStrategy 字段
leg1Position int64  // 品种1的持仓（净持仓）
leg2Position int64  // 品种2的持仓（净持仓）

// OnOrderUpdate 中更新
func (pas *PairwiseArbStrategy) OnOrderUpdate(update *orspb.OrderUpdate) {
    // 先调用基类更新总持仓
    pas.UpdatePosition(update)

    // 再更新leg持仓
    if symbol == pas.symbol1 {
        if update.Side == BUY {
            pas.leg1Position += qty
        } else {
            pas.leg1Position -= qty
        }
    }
}
```

**用途**:
- 追踪每条腿的净持仓
- 判断是否需要平仓或开仓
- 日志输出：`Pos=[leg1, leg2]`

### 层次3: Trader层持仓存储（仅启动时）

**位置**: `golang/pkg/trader/trader.go`

**机制**: 启动时从counter_bridge查询持仓，存储在Trader结构中

```go
// Trader 字段
positionsByExchange map[string][]client.PositionInfo  // 按交易所分组
positionsMu         sync.RWMutex

// queryInitialPositions() 在 Initialize() 时调用
func (t *Trader) queryInitialPositions() error {
    positions, err := orsClient.QueryPositions(ctx, "", "")
    t.positionsByExchange = positions  // 存储
    t.printPositionSummary()           // 打印
    return nil
}
```

**问题**:
1. ❌ **只在启动时查询一次** - 后续不再同步
2. ❌ **未传递给策略** - 策略从0开始追踪，忽略历史持仓
3. ❌ **存储后未使用** - 仅用于打印日志

---

## 🔍 问题分析

### 问题1: counter_bridge持仓查询的合理性

**您的质疑是对的！**

**当前设计**:
```
启动时：Trader → HTTP → Counter Bridge → CTP → 查询持仓 → Trader存储
运行时：策略从订单回报实时追踪持仓（不依赖Counter Bridge）
```

**问题**:
1. **职责混乱**:
   - Counter Bridge主要职责是转发订单和回报
   - 让它提供HTTP接口查询持仓，增加了职责

2. **HTTP服务卡顿**:
   - Counter Bridge当前的HTTP服务实现有问题（超时）
   - 可能是CTP查询持仓阻塞了HTTP线程

3. **查询结果未使用**:
   - Trader查询到持仓后，仅打印日志
   - 策略层不知道这些持仓，从0开始追踪
   - 导致历史持仓和实时追踪的持仓不一致

### 问题2: 策略重启后的持仓问题

**场景**: Trader重启（策略已有持仓）

**当前行为**:
```
1. Trader启动，查询持仓: ag2603 = 4 lots LONG
2. 策略初始化，持仓: leg1Position = 0  ← 问题：忽略了历史持仓
3. 策略生成信号，认为当前无持仓
4. 下单可能导致持仓超限
```

**应该的行为**:
```
1. Trader启动，查询持仓
2. 策略初始化，从Trader接收历史持仓
3. 策略leg1Position = 4  ← 正确
4. 策略根据实际持仓生成信号
```

---

## 💡 合理的持仓管理架构

### 方案A: 策略层自主追踪（推荐）

**理念**: 策略从订单回报完全自主追踪持仓，不依赖外部查询

**优点**:
- ✅ 实时性高
- ✅ 准确性高（不会丢失成交）
- ✅ 架构简单
- ✅ 不依赖CTP查询接口

**缺点**:
- ❌ 重启后丢失持仓（需要持久化）

**实现**:
```
1. 策略订单回报 → UpdatePosition() → 持仓变化
2. 定期持久化策略持仓到本地文件/数据库
3. 重启时从持久化文件恢复持仓
4. 可选：启动时查询CTP持仓对比校验
```

### 方案B: 混合追踪（当前改进方向）

**理念**: 启动时从CTP查询，运行时从回报追踪

**流程**:
```
1. Trader启动 → 查询CTP持仓
2. 传递给每个策略 → 策略初始化持仓
3. 运行时：策略从订单回报更新持仓
4. 定期（每5分钟）：查询CTP持仓对比校验
```

**优点**:
- ✅ 重启后正确处理历史持仓
- ✅ 定期校验防止漂移

**缺点**:
- ❌ 依赖CTP查询接口（可能慢/超时）
- ❌ 需要处理持仓不一致的情况

### 方案C: Portfolio层统一管理（未来方向）

**理念**: 由Portfolio Manager统一管理全局持仓

**架构**:
```
PortfolioManager
  ├─ 持仓管理: 按品种聚合所有策略持仓
  ├─ 持仓校验: 定期与CTP对比
  ├─ 持仓限制: 全局持仓不超限
  └─ 持仓分配: 多策略持仓协调

Strategy1: ag2603 = +4
Strategy2: ag2603 = -2
Portfolio: ag2603 = +2 (聚合后)
```

**优点**:
- ✅ 全局视图
- ✅ 多策略协调
- ✅ 风控统一

**缺点**:
- ❌ 实现复杂
- ❌ 需要重构

---

## 🎯 当前架构的问题总结

### 问题清单

1. **❌ Counter Bridge职责过重**
   - 主职责：转发订单和回报
   - 附加职责：提供HTTP接口查询持仓 ← 不合理

2. **❌ Trader查询持仓未使用**
   - 查询到持仓后，仅打印日志
   - 未传递给策略层
   - 策略从0开始追踪 ← 重启后持仓丢失

3. **❌ HTTP服务实现有问题**
   - Counter Bridge的HTTP请求超时
   - 可能是CTP查询阻塞了HTTP线程

4. **❌ 持仓数据结构不清晰**
   - BaseStrategy.Position: 策略总持仓
   - PairwiseArb.leg1Position: leg持仓
   - Trader.positionsByExchange: CTP持仓
   - 三者未关联，容易混乱

---

## 📋 改进建议

### 立即改进（修复当前问题）

**建议1: 移除counter_bridge的HTTP接口** ✅

**理由**:
- Counter Bridge主职责是订单转发，不应提供查询接口
- HTTP服务实现有问题（超时）
- Trader查询的持仓未被使用

**实施**:
1. 注释掉Trader.queryInitialPositions()调用
2. 移除Counter Bridge的HTTP服务代码
3. 策略完全依赖订单回报追踪持仓

**建议2: 策略持仓持久化** 🔄

**理由**: 重启后能恢复持仓

**实施**:
```go
// 策略停止时保存持仓
func (pas *PairwiseArbStrategy) Stop() error {
    savePositionToFile(pas.ID, pas.leg1Position, pas.leg2Position)
}

// 策略启动时恢复持仓
func (pas *PairwiseArbStrategy) Initialize(config) error {
    if pos := loadPositionFromFile(pas.ID); pos != nil {
        pas.leg1Position = pos.Leg1
        pas.leg2Position = pos.Leg2
    }
}
```

**建议3: 通过ORS Gateway查询持仓** 🔄

**理由**:
- ORS Gateway是订单路由层，查询持仓更合理
- 可以通过gRPC提供查询接口
- 不影响Counter Bridge的核心职责

**实施**:
```
Trader → gRPC → ORS Gateway → 共享内存 → Counter Bridge → CTP → 持仓数据
```

### 中期改进（架构优化）

**建议4: 将持仓传递给策略**

**实施**:
```go
// StrategyConfig 添加初始持仓字段
type StrategyConfig struct {
    InitialPositions map[string]int64  // symbol -> qty
}

// 策略初始化时应用
func (pas *PairwiseArbStrategy) Initialize(config) error {
    if qty, ok := config.InitialPositions[pas.symbol1]; ok {
        pas.leg1Position = qty
    }
    if qty, ok := config.InitialPositions[pas.symbol2]; ok {
        pas.leg2Position = qty
    }
}
```

**建议5: 定期持仓校验**

**实施**:
```go
// 每5分钟校验一次
func (t *Trader) periodicPositionCheck() {
    ticker := time.NewTicker(5 * time.Minute)
    for range ticker.C {
        ctpPos := queryCTPPositions()        // 从CTP查询
        strategyPos := getStrategyPositions() // 从策略聚合

        if diff := compare(ctpPos, strategyPos); diff > 0 {
            log.Warnf("Position mismatch: CTP=%v, Strategy=%v", ctpPos, strategyPos)
            // 可选：自动同步或告警
        }
    }
}
```

### 长期改进（未来规划）

**建议6: Portfolio层统一持仓管理**
- 所有策略持仓注册到Portfolio
- Portfolio统一查询、校验、风控
- 支持多策略持仓协调

---

## 🎯 结论

### 您的质疑完全正确！

**当前设计的问题**:
1. ❌ Counter Bridge职责过重（不应提供HTTP查询接口）
2. ❌ Trader查询持仓未传递给策略（浪费）
3. ❌ 策略重启后持仓丢失（从0开始）
4. ❌ HTTP服务实现有问题（超时）

### 推荐的改进方向

**短期** (立即):
- 移除counter_bridge的HTTP接口
- 策略完全依赖订单回报追踪持仓
- 添加策略持仓持久化

**中期** (1-2周):
- 通过ORS Gateway gRPC查询持仓
- 将查询的持仓传递给策略初始化
- 定期持仓校验（策略 vs CTP）

**长期** (未来):
- Portfolio层统一持仓管理
- 支持多策略持仓协调

---

**分析时间**: 2026-01-30 11:20
**结论**: ✅ 当前持仓管理架构需要重构
**优先级**: 🟡 中等（不影响交易，但影响重启场景）

